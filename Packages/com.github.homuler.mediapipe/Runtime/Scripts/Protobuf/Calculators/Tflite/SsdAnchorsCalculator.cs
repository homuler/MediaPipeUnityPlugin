// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/tflite/ssd_anchors_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/tflite/ssd_anchors_calculator.proto</summary>
  public static partial class SsdAnchorsCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/tflite/ssd_anchors_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static SsdAnchorsCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjltZWRpYXBpcGUvY2FsY3VsYXRvcnMvdGZsaXRlL3NzZF9hbmNob3JzX2Nh",
            "bGN1bGF0b3IucHJvdG8SCW1lZGlhcGlwZRokbWVkaWFwaXBlL2ZyYW1ld29y",
            "ay9jYWxjdWxhdG9yLnByb3RvGjltZWRpYXBpcGUvZnJhbWV3b3JrL2Zvcm1h",
            "dHMvb2JqZWN0X2RldGVjdGlvbi9hbmNob3IucHJvdG8i1wUKG1NzZEFuY2hv",
            "cnNDYWxjdWxhdG9yT3B0aW9ucxIYChBpbnB1dF9zaXplX3dpZHRoGAEgASgF",
            "EhkKEWlucHV0X3NpemVfaGVpZ2h0GAIgASgFEhEKCW1pbl9zY2FsZRgDIAEo",
            "AhIRCgltYXhfc2NhbGUYBCABKAISHAoPYW5jaG9yX29mZnNldF94GAUgASgC",
            "OgMwLjUSHAoPYW5jaG9yX29mZnNldF95GAYgASgCOgMwLjUSEgoKbnVtX2xh",
            "eWVycxgHIAEoBRIZChFmZWF0dXJlX21hcF93aWR0aBgIIAMoBRIaChJmZWF0",
            "dXJlX21hcF9oZWlnaHQYCSADKAUSDwoHc3RyaWRlcxgKIAMoBRIVCg1hc3Bl",
            "Y3RfcmF0aW9zGAsgAygCEisKHHJlZHVjZV9ib3hlc19pbl9sb3dlc3RfbGF5",
            "ZXIYDCABKAg6BWZhbHNlEioKH2ludGVycG9sYXRlZF9zY2FsZV9hc3BlY3Rf",
            "cmF0aW8YDSABKAI6ATESIAoRZml4ZWRfYW5jaG9yX3NpemUYDiABKAg6BWZh",
            "bHNlEisKHG11bHRpc2NhbGVfYW5jaG9yX2dlbmVyYXRpb24YDyABKAg6BWZh",
            "bHNlEhQKCW1pbl9sZXZlbBgQIAEoBToBMxIUCgltYXhfbGV2ZWwYESABKAU6",
            "ATcSFwoMYW5jaG9yX3NjYWxlGBIgASgCOgE0EhwKEXNjYWxlc19wZXJfb2N0",
            "YXZlGBMgASgFOgEyEiMKFW5vcm1hbGl6ZV9jb29yZGluYXRlcxgUIAEoCDoE",
            "dHJ1ZRIoCg1maXhlZF9hbmNob3JzGBUgAygLMhEubWVkaWFwaXBlLkFuY2hv",
            "cjJUCgNleHQSHC5tZWRpYXBpcGUuQ2FsY3VsYXRvck9wdGlvbnMY/7jzdSAB",
            "KAsyJi5tZWRpYXBpcGUuU3NkQW5jaG9yc0NhbGN1bGF0b3JPcHRpb25z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, global::Mediapipe.AnchorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.SsdAnchorsCalculatorOptions), global::Mediapipe.SsdAnchorsCalculatorOptions.Parser, new[]{ "InputSizeWidth", "InputSizeHeight", "MinScale", "MaxScale", "AnchorOffsetX", "AnchorOffsetY", "NumLayers", "FeatureMapWidth", "FeatureMapHeight", "Strides", "AspectRatios", "ReduceBoxesInLowestLayer", "InterpolatedScaleAspectRatio", "FixedAnchorSize", "MultiscaleAnchorGeneration", "MinLevel", "MaxLevel", "AnchorScale", "ScalesPerOctave", "NormalizeCoordinates", "FixedAnchors" }, null, null, new pb::Extension[] { global::Mediapipe.SsdAnchorsCalculatorOptions.Extensions.Ext }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Options to generate anchors for SSD object detection models.
  /// </summary>
  public sealed partial class SsdAnchorsCalculatorOptions : pb::IMessage<SsdAnchorsCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SsdAnchorsCalculatorOptions> _parser = new pb::MessageParser<SsdAnchorsCalculatorOptions>(() => new SsdAnchorsCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SsdAnchorsCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.SsdAnchorsCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions(SsdAnchorsCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      inputSizeWidth_ = other.inputSizeWidth_;
      inputSizeHeight_ = other.inputSizeHeight_;
      minScale_ = other.minScale_;
      maxScale_ = other.maxScale_;
      anchorOffsetX_ = other.anchorOffsetX_;
      anchorOffsetY_ = other.anchorOffsetY_;
      numLayers_ = other.numLayers_;
      featureMapWidth_ = other.featureMapWidth_.Clone();
      featureMapHeight_ = other.featureMapHeight_.Clone();
      strides_ = other.strides_.Clone();
      aspectRatios_ = other.aspectRatios_.Clone();
      reduceBoxesInLowestLayer_ = other.reduceBoxesInLowestLayer_;
      interpolatedScaleAspectRatio_ = other.interpolatedScaleAspectRatio_;
      fixedAnchorSize_ = other.fixedAnchorSize_;
      multiscaleAnchorGeneration_ = other.multiscaleAnchorGeneration_;
      minLevel_ = other.minLevel_;
      maxLevel_ = other.maxLevel_;
      anchorScale_ = other.anchorScale_;
      scalesPerOctave_ = other.scalesPerOctave_;
      normalizeCoordinates_ = other.normalizeCoordinates_;
      fixedAnchors_ = other.fixedAnchors_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions Clone() {
      return new SsdAnchorsCalculatorOptions(this);
    }

    /// <summary>Field number for the "input_size_width" field.</summary>
    public const int InputSizeWidthFieldNumber = 1;
    private readonly static int InputSizeWidthDefaultValue = 0;

    private int inputSizeWidth_;
    /// <summary>
    /// Size of input images.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InputSizeWidth {
      get { if ((_hasBits0 & 1) != 0) { return inputSizeWidth_; } else { return InputSizeWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        inputSizeWidth_ = value;
      }
    }
    /// <summary>Gets whether the "input_size_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputSizeWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "input_size_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputSizeWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "input_size_height" field.</summary>
    public const int InputSizeHeightFieldNumber = 2;
    private readonly static int InputSizeHeightDefaultValue = 0;

    private int inputSizeHeight_;
    /// <summary>
    /// required for generating anchros.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InputSizeHeight {
      get { if ((_hasBits0 & 2) != 0) { return inputSizeHeight_; } else { return InputSizeHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        inputSizeHeight_ = value;
      }
    }
    /// <summary>Gets whether the "input_size_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputSizeHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "input_size_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputSizeHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "min_scale" field.</summary>
    public const int MinScaleFieldNumber = 3;
    private readonly static float MinScaleDefaultValue = 0F;

    private float minScale_;
    /// <summary>
    /// Min and max scales for generating anchor boxes on feature maps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinScale {
      get { if ((_hasBits0 & 4) != 0) { return minScale_; } else { return MinScaleDefaultValue; } }
      set {
        _hasBits0 |= 4;
        minScale_ = value;
      }
    }
    /// <summary>Gets whether the "min_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinScale {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "min_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinScale() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_scale" field.</summary>
    public const int MaxScaleFieldNumber = 4;
    private readonly static float MaxScaleDefaultValue = 0F;

    private float maxScale_;
    /// <summary>
    /// required for generating anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MaxScale {
      get { if ((_hasBits0 & 8) != 0) { return maxScale_; } else { return MaxScaleDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxScale_ = value;
      }
    }
    /// <summary>Gets whether the "max_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxScale {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxScale() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "anchor_offset_x" field.</summary>
    public const int AnchorOffsetXFieldNumber = 5;
    private readonly static float AnchorOffsetXDefaultValue = 0.5F;

    private float anchorOffsetX_;
    /// <summary>
    /// The offset for the center of anchors. The value is in the scale of stride.
    /// E.g. 0.5 meaning 0.5 * |current_stride| in pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AnchorOffsetX {
      get { if ((_hasBits0 & 16) != 0) { return anchorOffsetX_; } else { return AnchorOffsetXDefaultValue; } }
      set {
        _hasBits0 |= 16;
        anchorOffsetX_ = value;
      }
    }
    /// <summary>Gets whether the "anchor_offset_x" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnchorOffsetX {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "anchor_offset_x" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnchorOffsetX() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "anchor_offset_y" field.</summary>
    public const int AnchorOffsetYFieldNumber = 6;
    private readonly static float AnchorOffsetYDefaultValue = 0.5F;

    private float anchorOffsetY_;
    /// <summary>
    /// required for generating anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AnchorOffsetY {
      get { if ((_hasBits0 & 32) != 0) { return anchorOffsetY_; } else { return AnchorOffsetYDefaultValue; } }
      set {
        _hasBits0 |= 32;
        anchorOffsetY_ = value;
      }
    }
    /// <summary>Gets whether the "anchor_offset_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnchorOffsetY {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "anchor_offset_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnchorOffsetY() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "num_layers" field.</summary>
    public const int NumLayersFieldNumber = 7;
    private readonly static int NumLayersDefaultValue = 0;

    private int numLayers_;
    /// <summary>
    /// Number of output feature maps to generate the anchors on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumLayers {
      get { if ((_hasBits0 & 64) != 0) { return numLayers_; } else { return NumLayersDefaultValue; } }
      set {
        _hasBits0 |= 64;
        numLayers_ = value;
      }
    }
    /// <summary>Gets whether the "num_layers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumLayers {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "num_layers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumLayers() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "feature_map_width" field.</summary>
    public const int FeatureMapWidthFieldNumber = 8;
    private static readonly pb::FieldCodec<int> _repeated_featureMapWidth_codec
        = pb::FieldCodec.ForInt32(64);
    private readonly pbc::RepeatedField<int> featureMapWidth_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Sizes of output feature maps to create anchors. Either feature_map size or
    /// stride should be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> FeatureMapWidth {
      get { return featureMapWidth_; }
    }

    /// <summary>Field number for the "feature_map_height" field.</summary>
    public const int FeatureMapHeightFieldNumber = 9;
    private static readonly pb::FieldCodec<int> _repeated_featureMapHeight_codec
        = pb::FieldCodec.ForInt32(72);
    private readonly pbc::RepeatedField<int> featureMapHeight_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> FeatureMapHeight {
      get { return featureMapHeight_; }
    }

    /// <summary>Field number for the "strides" field.</summary>
    public const int StridesFieldNumber = 10;
    private static readonly pb::FieldCodec<int> _repeated_strides_codec
        = pb::FieldCodec.ForInt32(80);
    private readonly pbc::RepeatedField<int> strides_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Strides of each output feature maps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Strides {
      get { return strides_; }
    }

    /// <summary>Field number for the "aspect_ratios" field.</summary>
    public const int AspectRatiosFieldNumber = 11;
    private static readonly pb::FieldCodec<float> _repeated_aspectRatios_codec
        = pb::FieldCodec.ForFloat(93);
    private readonly pbc::RepeatedField<float> aspectRatios_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// List of different aspect ratio to generate anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> AspectRatios {
      get { return aspectRatios_; }
    }

    /// <summary>Field number for the "reduce_boxes_in_lowest_layer" field.</summary>
    public const int ReduceBoxesInLowestLayerFieldNumber = 12;
    private readonly static bool ReduceBoxesInLowestLayerDefaultValue = false;

    private bool reduceBoxesInLowestLayer_;
    /// <summary>
    /// A boolean to indicate whether the fixed 3 boxes per location is used in the
    /// lowest layer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReduceBoxesInLowestLayer {
      get { if ((_hasBits0 & 128) != 0) { return reduceBoxesInLowestLayer_; } else { return ReduceBoxesInLowestLayerDefaultValue; } }
      set {
        _hasBits0 |= 128;
        reduceBoxesInLowestLayer_ = value;
      }
    }
    /// <summary>Gets whether the "reduce_boxes_in_lowest_layer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReduceBoxesInLowestLayer {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "reduce_boxes_in_lowest_layer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReduceBoxesInLowestLayer() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "interpolated_scale_aspect_ratio" field.</summary>
    public const int InterpolatedScaleAspectRatioFieldNumber = 13;
    private readonly static float InterpolatedScaleAspectRatioDefaultValue = 1F;

    private float interpolatedScaleAspectRatio_;
    /// <summary>
    /// An additional anchor is added with this aspect ratio and a scale
    /// interpolated between the scale for a layer and the scale for the next layer
    /// (1.0 for the last layer). This anchor is not included if this value is 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float InterpolatedScaleAspectRatio {
      get { if ((_hasBits0 & 256) != 0) { return interpolatedScaleAspectRatio_; } else { return InterpolatedScaleAspectRatioDefaultValue; } }
      set {
        _hasBits0 |= 256;
        interpolatedScaleAspectRatio_ = value;
      }
    }
    /// <summary>Gets whether the "interpolated_scale_aspect_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInterpolatedScaleAspectRatio {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "interpolated_scale_aspect_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInterpolatedScaleAspectRatio() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "fixed_anchor_size" field.</summary>
    public const int FixedAnchorSizeFieldNumber = 14;
    private readonly static bool FixedAnchorSizeDefaultValue = false;

    private bool fixedAnchorSize_;
    /// <summary>
    /// Whether use fixed width and height (e.g. both 1.0f) for each anchor.
    /// This option can be used when the predicted anchor width and height are in
    /// pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FixedAnchorSize {
      get { if ((_hasBits0 & 512) != 0) { return fixedAnchorSize_; } else { return FixedAnchorSizeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        fixedAnchorSize_ = value;
      }
    }
    /// <summary>Gets whether the "fixed_anchor_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFixedAnchorSize {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "fixed_anchor_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFixedAnchorSize() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "multiscale_anchor_generation" field.</summary>
    public const int MultiscaleAnchorGenerationFieldNumber = 15;
    private readonly static bool MultiscaleAnchorGenerationDefaultValue = false;

    private bool multiscaleAnchorGeneration_;
    /// <summary>
    /// Generates grid anchors on the fly corresponding to multiple CNN layers as
    /// described in:
    /// "Focal Loss for Dense Object Detection" (https://arxiv.org/abs/1708.02002)
    ///  T.-Y. Lin, P. Goyal, R. Girshick, K. He, P. Dollar
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool MultiscaleAnchorGeneration {
      get { if ((_hasBits0 & 1024) != 0) { return multiscaleAnchorGeneration_; } else { return MultiscaleAnchorGenerationDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        multiscaleAnchorGeneration_ = value;
      }
    }
    /// <summary>Gets whether the "multiscale_anchor_generation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMultiscaleAnchorGeneration {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "multiscale_anchor_generation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMultiscaleAnchorGeneration() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "min_level" field.</summary>
    public const int MinLevelFieldNumber = 16;
    private readonly static int MinLevelDefaultValue = 3;

    private int minLevel_;
    /// <summary>
    /// minimum level in feature pyramid
    /// for multiscale_anchor_generation only!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinLevel {
      get { if ((_hasBits0 & 2048) != 0) { return minLevel_; } else { return MinLevelDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        minLevel_ = value;
      }
    }
    /// <summary>Gets whether the "min_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinLevel {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "min_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinLevel() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "max_level" field.</summary>
    public const int MaxLevelFieldNumber = 17;
    private readonly static int MaxLevelDefaultValue = 7;

    private int maxLevel_;
    /// <summary>
    /// maximum level in feature pyramid
    /// for multiscale_anchor_generation only!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxLevel {
      get { if ((_hasBits0 & 4096) != 0) { return maxLevel_; } else { return MaxLevelDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        maxLevel_ = value;
      }
    }
    /// <summary>Gets whether the "max_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxLevel {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "max_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxLevel() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "anchor_scale" field.</summary>
    public const int AnchorScaleFieldNumber = 18;
    private readonly static float AnchorScaleDefaultValue = 4F;

    private float anchorScale_;
    /// <summary>
    /// Scale of anchor to feature stride
    /// for multiscale_anchor_generation only!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AnchorScale {
      get { if ((_hasBits0 & 8192) != 0) { return anchorScale_; } else { return AnchorScaleDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        anchorScale_ = value;
      }
    }
    /// <summary>Gets whether the "anchor_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnchorScale {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "anchor_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnchorScale() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "scales_per_octave" field.</summary>
    public const int ScalesPerOctaveFieldNumber = 19;
    private readonly static int ScalesPerOctaveDefaultValue = 2;

    private int scalesPerOctave_;
    /// <summary>
    /// Number of intermediate scale each scale octave
    /// for multiscale_anchor_generation only!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ScalesPerOctave {
      get { if ((_hasBits0 & 16384) != 0) { return scalesPerOctave_; } else { return ScalesPerOctaveDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        scalesPerOctave_ = value;
      }
    }
    /// <summary>Gets whether the "scales_per_octave" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScalesPerOctave {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "scales_per_octave" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScalesPerOctave() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "normalize_coordinates" field.</summary>
    public const int NormalizeCoordinatesFieldNumber = 20;
    private readonly static bool NormalizeCoordinatesDefaultValue = true;

    private bool normalizeCoordinates_;
    /// <summary>
    /// Whether to produce anchors in normalized coordinates.
    /// for multiscale_anchor_generation only!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NormalizeCoordinates {
      get { if ((_hasBits0 & 32768) != 0) { return normalizeCoordinates_; } else { return NormalizeCoordinatesDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        normalizeCoordinates_ = value;
      }
    }
    /// <summary>Gets whether the "normalize_coordinates" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNormalizeCoordinates {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "normalize_coordinates" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNormalizeCoordinates() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "fixed_anchors" field.</summary>
    public const int FixedAnchorsFieldNumber = 21;
    private static readonly pb::FieldCodec<global::Mediapipe.Anchor> _repeated_fixedAnchors_codec
        = pb::FieldCodec.ForMessage(170, global::Mediapipe.Anchor.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.Anchor> fixedAnchors_ = new pbc::RepeatedField<global::Mediapipe.Anchor>();
    /// <summary>
    /// Fixed list of anchors. If set, all the other options to generate anchors
    /// are ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.Anchor> FixedAnchors {
      get { return fixedAnchors_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SsdAnchorsCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SsdAnchorsCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InputSizeWidth != other.InputSizeWidth) return false;
      if (InputSizeHeight != other.InputSizeHeight) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinScale, other.MinScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxScale, other.MaxScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorOffsetX, other.AnchorOffsetX)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorOffsetY, other.AnchorOffsetY)) return false;
      if (NumLayers != other.NumLayers) return false;
      if(!featureMapWidth_.Equals(other.featureMapWidth_)) return false;
      if(!featureMapHeight_.Equals(other.featureMapHeight_)) return false;
      if(!strides_.Equals(other.strides_)) return false;
      if(!aspectRatios_.Equals(other.aspectRatios_)) return false;
      if (ReduceBoxesInLowestLayer != other.ReduceBoxesInLowestLayer) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterpolatedScaleAspectRatio, other.InterpolatedScaleAspectRatio)) return false;
      if (FixedAnchorSize != other.FixedAnchorSize) return false;
      if (MultiscaleAnchorGeneration != other.MultiscaleAnchorGeneration) return false;
      if (MinLevel != other.MinLevel) return false;
      if (MaxLevel != other.MaxLevel) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorScale, other.AnchorScale)) return false;
      if (ScalesPerOctave != other.ScalesPerOctave) return false;
      if (NormalizeCoordinates != other.NormalizeCoordinates) return false;
      if(!fixedAnchors_.Equals(other.fixedAnchors_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasInputSizeWidth) hash ^= InputSizeWidth.GetHashCode();
      if (HasInputSizeHeight) hash ^= InputSizeHeight.GetHashCode();
      if (HasMinScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinScale);
      if (HasMaxScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxScale);
      if (HasAnchorOffsetX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorOffsetX);
      if (HasAnchorOffsetY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorOffsetY);
      if (HasNumLayers) hash ^= NumLayers.GetHashCode();
      hash ^= featureMapWidth_.GetHashCode();
      hash ^= featureMapHeight_.GetHashCode();
      hash ^= strides_.GetHashCode();
      hash ^= aspectRatios_.GetHashCode();
      if (HasReduceBoxesInLowestLayer) hash ^= ReduceBoxesInLowestLayer.GetHashCode();
      if (HasInterpolatedScaleAspectRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterpolatedScaleAspectRatio);
      if (HasFixedAnchorSize) hash ^= FixedAnchorSize.GetHashCode();
      if (HasMultiscaleAnchorGeneration) hash ^= MultiscaleAnchorGeneration.GetHashCode();
      if (HasMinLevel) hash ^= MinLevel.GetHashCode();
      if (HasMaxLevel) hash ^= MaxLevel.GetHashCode();
      if (HasAnchorScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorScale);
      if (HasScalesPerOctave) hash ^= ScalesPerOctave.GetHashCode();
      if (HasNormalizeCoordinates) hash ^= NormalizeCoordinates.GetHashCode();
      hash ^= fixedAnchors_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasInputSizeWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(InputSizeHeight);
      }
      if (HasMinScale) {
        output.WriteRawTag(29);
        output.WriteFloat(MinScale);
      }
      if (HasMaxScale) {
        output.WriteRawTag(37);
        output.WriteFloat(MaxScale);
      }
      if (HasAnchorOffsetX) {
        output.WriteRawTag(45);
        output.WriteFloat(AnchorOffsetX);
      }
      if (HasAnchorOffsetY) {
        output.WriteRawTag(53);
        output.WriteFloat(AnchorOffsetY);
      }
      if (HasNumLayers) {
        output.WriteRawTag(56);
        output.WriteInt32(NumLayers);
      }
      featureMapWidth_.WriteTo(output, _repeated_featureMapWidth_codec);
      featureMapHeight_.WriteTo(output, _repeated_featureMapHeight_codec);
      strides_.WriteTo(output, _repeated_strides_codec);
      aspectRatios_.WriteTo(output, _repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        output.WriteRawTag(96);
        output.WriteBool(ReduceBoxesInLowestLayer);
      }
      if (HasInterpolatedScaleAspectRatio) {
        output.WriteRawTag(109);
        output.WriteFloat(InterpolatedScaleAspectRatio);
      }
      if (HasFixedAnchorSize) {
        output.WriteRawTag(112);
        output.WriteBool(FixedAnchorSize);
      }
      if (HasMultiscaleAnchorGeneration) {
        output.WriteRawTag(120);
        output.WriteBool(MultiscaleAnchorGeneration);
      }
      if (HasMinLevel) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(MinLevel);
      }
      if (HasMaxLevel) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(MaxLevel);
      }
      if (HasAnchorScale) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(AnchorScale);
      }
      if (HasScalesPerOctave) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(ScalesPerOctave);
      }
      if (HasNormalizeCoordinates) {
        output.WriteRawTag(160, 1);
        output.WriteBool(NormalizeCoordinates);
      }
      fixedAnchors_.WriteTo(output, _repeated_fixedAnchors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasInputSizeWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(InputSizeHeight);
      }
      if (HasMinScale) {
        output.WriteRawTag(29);
        output.WriteFloat(MinScale);
      }
      if (HasMaxScale) {
        output.WriteRawTag(37);
        output.WriteFloat(MaxScale);
      }
      if (HasAnchorOffsetX) {
        output.WriteRawTag(45);
        output.WriteFloat(AnchorOffsetX);
      }
      if (HasAnchorOffsetY) {
        output.WriteRawTag(53);
        output.WriteFloat(AnchorOffsetY);
      }
      if (HasNumLayers) {
        output.WriteRawTag(56);
        output.WriteInt32(NumLayers);
      }
      featureMapWidth_.WriteTo(ref output, _repeated_featureMapWidth_codec);
      featureMapHeight_.WriteTo(ref output, _repeated_featureMapHeight_codec);
      strides_.WriteTo(ref output, _repeated_strides_codec);
      aspectRatios_.WriteTo(ref output, _repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        output.WriteRawTag(96);
        output.WriteBool(ReduceBoxesInLowestLayer);
      }
      if (HasInterpolatedScaleAspectRatio) {
        output.WriteRawTag(109);
        output.WriteFloat(InterpolatedScaleAspectRatio);
      }
      if (HasFixedAnchorSize) {
        output.WriteRawTag(112);
        output.WriteBool(FixedAnchorSize);
      }
      if (HasMultiscaleAnchorGeneration) {
        output.WriteRawTag(120);
        output.WriteBool(MultiscaleAnchorGeneration);
      }
      if (HasMinLevel) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(MinLevel);
      }
      if (HasMaxLevel) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(MaxLevel);
      }
      if (HasAnchorScale) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(AnchorScale);
      }
      if (HasScalesPerOctave) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(ScalesPerOctave);
      }
      if (HasNormalizeCoordinates) {
        output.WriteRawTag(160, 1);
        output.WriteBool(NormalizeCoordinates);
      }
      fixedAnchors_.WriteTo(ref output, _repeated_fixedAnchors_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasInputSizeWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputSizeHeight);
      }
      if (HasMinScale) {
        size += 1 + 4;
      }
      if (HasMaxScale) {
        size += 1 + 4;
      }
      if (HasAnchorOffsetX) {
        size += 1 + 4;
      }
      if (HasAnchorOffsetY) {
        size += 1 + 4;
      }
      if (HasNumLayers) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumLayers);
      }
      size += featureMapWidth_.CalculateSize(_repeated_featureMapWidth_codec);
      size += featureMapHeight_.CalculateSize(_repeated_featureMapHeight_codec);
      size += strides_.CalculateSize(_repeated_strides_codec);
      size += aspectRatios_.CalculateSize(_repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        size += 1 + 1;
      }
      if (HasInterpolatedScaleAspectRatio) {
        size += 1 + 4;
      }
      if (HasFixedAnchorSize) {
        size += 1 + 1;
      }
      if (HasMultiscaleAnchorGeneration) {
        size += 1 + 1;
      }
      if (HasMinLevel) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MinLevel);
      }
      if (HasMaxLevel) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxLevel);
      }
      if (HasAnchorScale) {
        size += 2 + 4;
      }
      if (HasScalesPerOctave) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(ScalesPerOctave);
      }
      if (HasNormalizeCoordinates) {
        size += 2 + 1;
      }
      size += fixedAnchors_.CalculateSize(_repeated_fixedAnchors_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SsdAnchorsCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasInputSizeWidth) {
        InputSizeWidth = other.InputSizeWidth;
      }
      if (other.HasInputSizeHeight) {
        InputSizeHeight = other.InputSizeHeight;
      }
      if (other.HasMinScale) {
        MinScale = other.MinScale;
      }
      if (other.HasMaxScale) {
        MaxScale = other.MaxScale;
      }
      if (other.HasAnchorOffsetX) {
        AnchorOffsetX = other.AnchorOffsetX;
      }
      if (other.HasAnchorOffsetY) {
        AnchorOffsetY = other.AnchorOffsetY;
      }
      if (other.HasNumLayers) {
        NumLayers = other.NumLayers;
      }
      featureMapWidth_.Add(other.featureMapWidth_);
      featureMapHeight_.Add(other.featureMapHeight_);
      strides_.Add(other.strides_);
      aspectRatios_.Add(other.aspectRatios_);
      if (other.HasReduceBoxesInLowestLayer) {
        ReduceBoxesInLowestLayer = other.ReduceBoxesInLowestLayer;
      }
      if (other.HasInterpolatedScaleAspectRatio) {
        InterpolatedScaleAspectRatio = other.InterpolatedScaleAspectRatio;
      }
      if (other.HasFixedAnchorSize) {
        FixedAnchorSize = other.FixedAnchorSize;
      }
      if (other.HasMultiscaleAnchorGeneration) {
        MultiscaleAnchorGeneration = other.MultiscaleAnchorGeneration;
      }
      if (other.HasMinLevel) {
        MinLevel = other.MinLevel;
      }
      if (other.HasMaxLevel) {
        MaxLevel = other.MaxLevel;
      }
      if (other.HasAnchorScale) {
        AnchorScale = other.AnchorScale;
      }
      if (other.HasScalesPerOctave) {
        ScalesPerOctave = other.ScalesPerOctave;
      }
      if (other.HasNormalizeCoordinates) {
        NormalizeCoordinates = other.NormalizeCoordinates;
      }
      fixedAnchors_.Add(other.fixedAnchors_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            InputSizeWidth = input.ReadInt32();
            break;
          }
          case 16: {
            InputSizeHeight = input.ReadInt32();
            break;
          }
          case 29: {
            MinScale = input.ReadFloat();
            break;
          }
          case 37: {
            MaxScale = input.ReadFloat();
            break;
          }
          case 45: {
            AnchorOffsetX = input.ReadFloat();
            break;
          }
          case 53: {
            AnchorOffsetY = input.ReadFloat();
            break;
          }
          case 56: {
            NumLayers = input.ReadInt32();
            break;
          }
          case 66:
          case 64: {
            featureMapWidth_.AddEntriesFrom(input, _repeated_featureMapWidth_codec);
            break;
          }
          case 74:
          case 72: {
            featureMapHeight_.AddEntriesFrom(input, _repeated_featureMapHeight_codec);
            break;
          }
          case 82:
          case 80: {
            strides_.AddEntriesFrom(input, _repeated_strides_codec);
            break;
          }
          case 90:
          case 93: {
            aspectRatios_.AddEntriesFrom(input, _repeated_aspectRatios_codec);
            break;
          }
          case 96: {
            ReduceBoxesInLowestLayer = input.ReadBool();
            break;
          }
          case 109: {
            InterpolatedScaleAspectRatio = input.ReadFloat();
            break;
          }
          case 112: {
            FixedAnchorSize = input.ReadBool();
            break;
          }
          case 120: {
            MultiscaleAnchorGeneration = input.ReadBool();
            break;
          }
          case 128: {
            MinLevel = input.ReadInt32();
            break;
          }
          case 136: {
            MaxLevel = input.ReadInt32();
            break;
          }
          case 149: {
            AnchorScale = input.ReadFloat();
            break;
          }
          case 152: {
            ScalesPerOctave = input.ReadInt32();
            break;
          }
          case 160: {
            NormalizeCoordinates = input.ReadBool();
            break;
          }
          case 170: {
            fixedAnchors_.AddEntriesFrom(input, _repeated_fixedAnchors_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            InputSizeWidth = input.ReadInt32();
            break;
          }
          case 16: {
            InputSizeHeight = input.ReadInt32();
            break;
          }
          case 29: {
            MinScale = input.ReadFloat();
            break;
          }
          case 37: {
            MaxScale = input.ReadFloat();
            break;
          }
          case 45: {
            AnchorOffsetX = input.ReadFloat();
            break;
          }
          case 53: {
            AnchorOffsetY = input.ReadFloat();
            break;
          }
          case 56: {
            NumLayers = input.ReadInt32();
            break;
          }
          case 66:
          case 64: {
            featureMapWidth_.AddEntriesFrom(ref input, _repeated_featureMapWidth_codec);
            break;
          }
          case 74:
          case 72: {
            featureMapHeight_.AddEntriesFrom(ref input, _repeated_featureMapHeight_codec);
            break;
          }
          case 82:
          case 80: {
            strides_.AddEntriesFrom(ref input, _repeated_strides_codec);
            break;
          }
          case 90:
          case 93: {
            aspectRatios_.AddEntriesFrom(ref input, _repeated_aspectRatios_codec);
            break;
          }
          case 96: {
            ReduceBoxesInLowestLayer = input.ReadBool();
            break;
          }
          case 109: {
            InterpolatedScaleAspectRatio = input.ReadFloat();
            break;
          }
          case 112: {
            FixedAnchorSize = input.ReadBool();
            break;
          }
          case 120: {
            MultiscaleAnchorGeneration = input.ReadBool();
            break;
          }
          case 128: {
            MinLevel = input.ReadInt32();
            break;
          }
          case 136: {
            MaxLevel = input.ReadInt32();
            break;
          }
          case 149: {
            AnchorScale = input.ReadFloat();
            break;
          }
          case 152: {
            ScalesPerOctave = input.ReadInt32();
            break;
          }
          case 160: {
            NormalizeCoordinates = input.ReadBool();
            break;
          }
          case 170: {
            fixedAnchors_.AddEntriesFrom(ref input, _repeated_fixedAnchors_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the SsdAnchorsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.SsdAnchorsCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.SsdAnchorsCalculatorOptions>(247258239, pb::FieldCodec.ForMessage(1978065914, global::Mediapipe.SsdAnchorsCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/tflite/tflite_tensors_to_segmentation_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/tflite/tflite_tensors_to_segmentation_calculator.proto</summary>
  public static partial class TfliteTensorsToSegmentationCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/tflite/tflite_tensors_to_segmentation_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TfliteTensorsToSegmentationCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkxtZWRpYXBpcGUvY2FsY3VsYXRvcnMvdGZsaXRlL3RmbGl0ZV90ZW5zb3Jz",
            "X3RvX3NlZ21lbnRhdGlvbl9jYWxjdWxhdG9yLnByb3RvEgltZWRpYXBpcGUa",
            "JG1lZGlhcGlwZS9mcmFtZXdvcmsvY2FsY3VsYXRvci5wcm90byK7AgosVGZM",
            "aXRlVGVuc29yc1RvU2VnbWVudGF0aW9uQ2FsY3VsYXRvck9wdGlvbnMSFAoM",
            "dGVuc29yX3dpZHRoGAEgASgFEhUKDXRlbnNvcl9oZWlnaHQYAiABKAUSFwoP",
            "dGVuc29yX2NoYW5uZWxzGAMgASgFEiYKG2NvbWJpbmVfd2l0aF9wcmV2aW91",
            "c19yYXRpbxgEIAEoAjoBMRIdChJvdXRwdXRfbGF5ZXJfaW5kZXgYBSABKAU6",
            "ATESFwoPZmxpcF92ZXJ0aWNhbGx5GAYgASgIMmUKA2V4dBIcLm1lZGlhcGlw",
            "ZS5DYWxjdWxhdG9yT3B0aW9ucxjK+7R4IAEoCzI3Lm1lZGlhcGlwZS5UZkxp",
            "dGVUZW5zb3JzVG9TZWdtZW50YXRpb25DYWxjdWxhdG9yT3B0aW9ucw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions), global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions.Parser, new[]{ "TensorWidth", "TensorHeight", "TensorChannels", "CombineWithPreviousRatio", "OutputLayerIndex", "FlipVertically" }, null, null, new pb::Extension[] { global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions.Extensions.Ext }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class TfLiteTensorsToSegmentationCalculatorOptions : pb::IMessage<TfLiteTensorsToSegmentationCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TfLiteTensorsToSegmentationCalculatorOptions> _parser = new pb::MessageParser<TfLiteTensorsToSegmentationCalculatorOptions>(() => new TfLiteTensorsToSegmentationCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TfLiteTensorsToSegmentationCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.TfliteTensorsToSegmentationCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TfLiteTensorsToSegmentationCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TfLiteTensorsToSegmentationCalculatorOptions(TfLiteTensorsToSegmentationCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      tensorWidth_ = other.tensorWidth_;
      tensorHeight_ = other.tensorHeight_;
      tensorChannels_ = other.tensorChannels_;
      combineWithPreviousRatio_ = other.combineWithPreviousRatio_;
      outputLayerIndex_ = other.outputLayerIndex_;
      flipVertically_ = other.flipVertically_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TfLiteTensorsToSegmentationCalculatorOptions Clone() {
      return new TfLiteTensorsToSegmentationCalculatorOptions(this);
    }

    /// <summary>Field number for the "tensor_width" field.</summary>
    public const int TensorWidthFieldNumber = 1;
    private readonly static int TensorWidthDefaultValue = 0;

    private int tensorWidth_;
    /// <summary>
    /// Dimensions of input segmentation tensor to process.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TensorWidth {
      get { if ((_hasBits0 & 1) != 0) { return tensorWidth_; } else { return TensorWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        tensorWidth_ = value;
      }
    }
    /// <summary>Gets whether the "tensor_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTensorWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "tensor_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTensorWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tensor_height" field.</summary>
    public const int TensorHeightFieldNumber = 2;
    private readonly static int TensorHeightDefaultValue = 0;

    private int tensorHeight_;
    /// <summary>
    /// required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TensorHeight {
      get { if ((_hasBits0 & 2) != 0) { return tensorHeight_; } else { return TensorHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tensorHeight_ = value;
      }
    }
    /// <summary>Gets whether the "tensor_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTensorHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tensor_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTensorHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "tensor_channels" field.</summary>
    public const int TensorChannelsFieldNumber = 3;
    private readonly static int TensorChannelsDefaultValue = 0;

    private int tensorChannels_;
    /// <summary>
    /// required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TensorChannels {
      get { if ((_hasBits0 & 4) != 0) { return tensorChannels_; } else { return TensorChannelsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        tensorChannels_ = value;
      }
    }
    /// <summary>Gets whether the "tensor_channels" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTensorChannels {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tensor_channels" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTensorChannels() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "combine_with_previous_ratio" field.</summary>
    public const int CombineWithPreviousRatioFieldNumber = 4;
    private readonly static float CombineWithPreviousRatioDefaultValue = 1F;

    private float combineWithPreviousRatio_;
    /// <summary>
    /// How much to use previous mask when computing current one; range [0-1].
    /// This is a tradeoff between responsiveness (0.0) and accuracy (1.0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float CombineWithPreviousRatio {
      get { if ((_hasBits0 & 8) != 0) { return combineWithPreviousRatio_; } else { return CombineWithPreviousRatioDefaultValue; } }
      set {
        _hasBits0 |= 8;
        combineWithPreviousRatio_ = value;
      }
    }
    /// <summary>Gets whether the "combine_with_previous_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCombineWithPreviousRatio {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "combine_with_previous_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCombineWithPreviousRatio() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "output_layer_index" field.</summary>
    public const int OutputLayerIndexFieldNumber = 5;
    private readonly static int OutputLayerIndexDefaultValue = 1;

    private int outputLayerIndex_;
    /// <summary>
    /// Model specific: Channel to use for processing tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int OutputLayerIndex {
      get { if ((_hasBits0 & 16) != 0) { return outputLayerIndex_; } else { return OutputLayerIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        outputLayerIndex_ = value;
      }
    }
    /// <summary>Gets whether the "output_layer_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutputLayerIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "output_layer_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutputLayerIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "flip_vertically" field.</summary>
    public const int FlipVerticallyFieldNumber = 6;
    private readonly static bool FlipVerticallyDefaultValue = false;

    private bool flipVertically_;
    /// <summary>
    /// Flip result image mask along y-axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FlipVertically {
      get { if ((_hasBits0 & 32) != 0) { return flipVertically_; } else { return FlipVerticallyDefaultValue; } }
      set {
        _hasBits0 |= 32;
        flipVertically_ = value;
      }
    }
    /// <summary>Gets whether the "flip_vertically" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFlipVertically {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "flip_vertically" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFlipVertically() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TfLiteTensorsToSegmentationCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TfLiteTensorsToSegmentationCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TensorWidth != other.TensorWidth) return false;
      if (TensorHeight != other.TensorHeight) return false;
      if (TensorChannels != other.TensorChannels) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(CombineWithPreviousRatio, other.CombineWithPreviousRatio)) return false;
      if (OutputLayerIndex != other.OutputLayerIndex) return false;
      if (FlipVertically != other.FlipVertically) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTensorWidth) hash ^= TensorWidth.GetHashCode();
      if (HasTensorHeight) hash ^= TensorHeight.GetHashCode();
      if (HasTensorChannels) hash ^= TensorChannels.GetHashCode();
      if (HasCombineWithPreviousRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(CombineWithPreviousRatio);
      if (HasOutputLayerIndex) hash ^= OutputLayerIndex.GetHashCode();
      if (HasFlipVertically) hash ^= FlipVertically.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTensorWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(TensorWidth);
      }
      if (HasTensorHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(TensorHeight);
      }
      if (HasTensorChannels) {
        output.WriteRawTag(24);
        output.WriteInt32(TensorChannels);
      }
      if (HasCombineWithPreviousRatio) {
        output.WriteRawTag(37);
        output.WriteFloat(CombineWithPreviousRatio);
      }
      if (HasOutputLayerIndex) {
        output.WriteRawTag(40);
        output.WriteInt32(OutputLayerIndex);
      }
      if (HasFlipVertically) {
        output.WriteRawTag(48);
        output.WriteBool(FlipVertically);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTensorWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(TensorWidth);
      }
      if (HasTensorHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(TensorHeight);
      }
      if (HasTensorChannels) {
        output.WriteRawTag(24);
        output.WriteInt32(TensorChannels);
      }
      if (HasCombineWithPreviousRatio) {
        output.WriteRawTag(37);
        output.WriteFloat(CombineWithPreviousRatio);
      }
      if (HasOutputLayerIndex) {
        output.WriteRawTag(40);
        output.WriteInt32(OutputLayerIndex);
      }
      if (HasFlipVertically) {
        output.WriteRawTag(48);
        output.WriteBool(FlipVertically);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTensorWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TensorWidth);
      }
      if (HasTensorHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TensorHeight);
      }
      if (HasTensorChannels) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TensorChannels);
      }
      if (HasCombineWithPreviousRatio) {
        size += 1 + 4;
      }
      if (HasOutputLayerIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(OutputLayerIndex);
      }
      if (HasFlipVertically) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TfLiteTensorsToSegmentationCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasTensorWidth) {
        TensorWidth = other.TensorWidth;
      }
      if (other.HasTensorHeight) {
        TensorHeight = other.TensorHeight;
      }
      if (other.HasTensorChannels) {
        TensorChannels = other.TensorChannels;
      }
      if (other.HasCombineWithPreviousRatio) {
        CombineWithPreviousRatio = other.CombineWithPreviousRatio;
      }
      if (other.HasOutputLayerIndex) {
        OutputLayerIndex = other.OutputLayerIndex;
      }
      if (other.HasFlipVertically) {
        FlipVertically = other.FlipVertically;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TensorWidth = input.ReadInt32();
            break;
          }
          case 16: {
            TensorHeight = input.ReadInt32();
            break;
          }
          case 24: {
            TensorChannels = input.ReadInt32();
            break;
          }
          case 37: {
            CombineWithPreviousRatio = input.ReadFloat();
            break;
          }
          case 40: {
            OutputLayerIndex = input.ReadInt32();
            break;
          }
          case 48: {
            FlipVertically = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TensorWidth = input.ReadInt32();
            break;
          }
          case 16: {
            TensorHeight = input.ReadInt32();
            break;
          }
          case 24: {
            TensorChannels = input.ReadInt32();
            break;
          }
          case 37: {
            CombineWithPreviousRatio = input.ReadFloat();
            break;
          }
          case 40: {
            OutputLayerIndex = input.ReadInt32();
            break;
          }
          case 48: {
            FlipVertically = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the TfLiteTensorsToSegmentationCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions>(252526026, pb::FieldCodec.ForMessage(2020208210, global::Mediapipe.TfLiteTensorsToSegmentationCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/util/detections_to_rects_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/util/detections_to_rects_calculator.proto</summary>
  public static partial class DetectionsToRectsCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/util/detections_to_rects_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DetectionsToRectsCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cj9tZWRpYXBpcGUvY2FsY3VsYXRvcnMvdXRpbC9kZXRlY3Rpb25zX3RvX3Jl",
            "Y3RzX2NhbGN1bGF0b3IucHJvdG8SCW1lZGlhcGlwZRokbWVkaWFwaXBlL2Zy",
            "YW1ld29yay9jYWxjdWxhdG9yLnByb3RvIv0DCiJEZXRlY3Rpb25zVG9SZWN0",
            "c0NhbGN1bGF0b3JPcHRpb25zEiwKJHJvdGF0aW9uX3ZlY3Rvcl9zdGFydF9r",
            "ZXlwb2ludF9pbmRleBgBIAEoBRIqCiJyb3RhdGlvbl92ZWN0b3JfZW5kX2tl",
            "eXBvaW50X2luZGV4GAIgASgFEiQKHHJvdGF0aW9uX3ZlY3Rvcl90YXJnZXRf",
            "YW5nbGUYAyABKAISLAokcm90YXRpb25fdmVjdG9yX3RhcmdldF9hbmdsZV9k",
            "ZWdyZWVzGAQgASgCEi0KJW91dHB1dF96ZXJvX3JlY3RfZm9yX2VtcHR5X2Rl",
            "dGVjdGlvbnMYBSABKAgSVQoPY29udmVyc2lvbl9tb2RlGAYgASgOMjwubWVk",
            "aWFwaXBlLkRldGVjdGlvbnNUb1JlY3RzQ2FsY3VsYXRvck9wdGlvbnMuQ29u",
            "dmVyc2lvbk1vZGUiRgoOQ29udmVyc2lvbk1vZGUSCwoHREVGQVVMVBAAEhQK",
            "EFVTRV9CT1VORElOR19CT1gQARIRCg1VU0VfS0VZUE9JTlRTEAIyWwoDZXh0",
            "EhwubWVkaWFwaXBlLkNhbGN1bGF0b3JPcHRpb25zGN+3oX0gASgLMi0ubWVk",
            "aWFwaXBlLkRldGVjdGlvbnNUb1JlY3RzQ2FsY3VsYXRvck9wdGlvbnM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.DetectionsToRectsCalculatorOptions), global::Mediapipe.DetectionsToRectsCalculatorOptions.Parser, new[]{ "RotationVectorStartKeypointIndex", "RotationVectorEndKeypointIndex", "RotationVectorTargetAngle", "RotationVectorTargetAngleDegrees", "OutputZeroRectForEmptyDetections", "ConversionMode" }, null, new[]{ typeof(global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode) }, new pb::Extension[] { global::Mediapipe.DetectionsToRectsCalculatorOptions.Extensions.Ext }, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class DetectionsToRectsCalculatorOptions : pb::IMessage<DetectionsToRectsCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DetectionsToRectsCalculatorOptions> _parser = new pb::MessageParser<DetectionsToRectsCalculatorOptions>(() => new DetectionsToRectsCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DetectionsToRectsCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.DetectionsToRectsCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DetectionsToRectsCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DetectionsToRectsCalculatorOptions(DetectionsToRectsCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      rotationVectorStartKeypointIndex_ = other.rotationVectorStartKeypointIndex_;
      rotationVectorEndKeypointIndex_ = other.rotationVectorEndKeypointIndex_;
      rotationVectorTargetAngle_ = other.rotationVectorTargetAngle_;
      rotationVectorTargetAngleDegrees_ = other.rotationVectorTargetAngleDegrees_;
      outputZeroRectForEmptyDetections_ = other.outputZeroRectForEmptyDetections_;
      conversionMode_ = other.conversionMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DetectionsToRectsCalculatorOptions Clone() {
      return new DetectionsToRectsCalculatorOptions(this);
    }

    /// <summary>Field number for the "rotation_vector_start_keypoint_index" field.</summary>
    public const int RotationVectorStartKeypointIndexFieldNumber = 1;
    private readonly static int RotationVectorStartKeypointIndexDefaultValue = 0;

    private int rotationVectorStartKeypointIndex_;
    /// <summary>
    /// Specify the rotation angle of the output rect with a vector formed by
    /// connecting two keypoints in the detection, together with the target angle
    /// (can be in radians or in degrees) of that vector after rotation. The target
    /// angle is counter-clockwise starting from the positive x-axis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RotationVectorStartKeypointIndex {
      get { if ((_hasBits0 & 1) != 0) { return rotationVectorStartKeypointIndex_; } else { return RotationVectorStartKeypointIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        rotationVectorStartKeypointIndex_ = value;
      }
    }
    /// <summary>Gets whether the "rotation_vector_start_keypoint_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRotationVectorStartKeypointIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "rotation_vector_start_keypoint_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRotationVectorStartKeypointIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "rotation_vector_end_keypoint_index" field.</summary>
    public const int RotationVectorEndKeypointIndexFieldNumber = 2;
    private readonly static int RotationVectorEndKeypointIndexDefaultValue = 0;

    private int rotationVectorEndKeypointIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RotationVectorEndKeypointIndex {
      get { if ((_hasBits0 & 2) != 0) { return rotationVectorEndKeypointIndex_; } else { return RotationVectorEndKeypointIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        rotationVectorEndKeypointIndex_ = value;
      }
    }
    /// <summary>Gets whether the "rotation_vector_end_keypoint_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRotationVectorEndKeypointIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "rotation_vector_end_keypoint_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRotationVectorEndKeypointIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "rotation_vector_target_angle" field.</summary>
    public const int RotationVectorTargetAngleFieldNumber = 3;
    private readonly static float RotationVectorTargetAngleDefaultValue = 0F;

    private float rotationVectorTargetAngle_;
    /// <summary>
    /// In radians.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RotationVectorTargetAngle {
      get { if ((_hasBits0 & 4) != 0) { return rotationVectorTargetAngle_; } else { return RotationVectorTargetAngleDefaultValue; } }
      set {
        _hasBits0 |= 4;
        rotationVectorTargetAngle_ = value;
      }
    }
    /// <summary>Gets whether the "rotation_vector_target_angle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRotationVectorTargetAngle {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "rotation_vector_target_angle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRotationVectorTargetAngle() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "rotation_vector_target_angle_degrees" field.</summary>
    public const int RotationVectorTargetAngleDegreesFieldNumber = 4;
    private readonly static float RotationVectorTargetAngleDegreesDefaultValue = 0F;

    private float rotationVectorTargetAngleDegrees_;
    /// <summary>
    /// In degrees.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RotationVectorTargetAngleDegrees {
      get { if ((_hasBits0 & 8) != 0) { return rotationVectorTargetAngleDegrees_; } else { return RotationVectorTargetAngleDegreesDefaultValue; } }
      set {
        _hasBits0 |= 8;
        rotationVectorTargetAngleDegrees_ = value;
      }
    }
    /// <summary>Gets whether the "rotation_vector_target_angle_degrees" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRotationVectorTargetAngleDegrees {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "rotation_vector_target_angle_degrees" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRotationVectorTargetAngleDegrees() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "output_zero_rect_for_empty_detections" field.</summary>
    public const int OutputZeroRectForEmptyDetectionsFieldNumber = 5;
    private readonly static bool OutputZeroRectForEmptyDetectionsDefaultValue = false;

    private bool outputZeroRectForEmptyDetections_;
    /// <summary>
    /// Whether to output a zero-rect (with origin and size both zero) when the
    /// input detection vector is empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OutputZeroRectForEmptyDetections {
      get { if ((_hasBits0 & 16) != 0) { return outputZeroRectForEmptyDetections_; } else { return OutputZeroRectForEmptyDetectionsDefaultValue; } }
      set {
        _hasBits0 |= 16;
        outputZeroRectForEmptyDetections_ = value;
      }
    }
    /// <summary>Gets whether the "output_zero_rect_for_empty_detections" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutputZeroRectForEmptyDetections {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "output_zero_rect_for_empty_detections" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutputZeroRectForEmptyDetections() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "conversion_mode" field.</summary>
    public const int ConversionModeFieldNumber = 6;
    private readonly static global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode ConversionModeDefaultValue = global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode.Default;

    private global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode conversionMode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode ConversionMode {
      get { if ((_hasBits0 & 32) != 0) { return conversionMode_; } else { return ConversionModeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        conversionMode_ = value;
      }
    }
    /// <summary>Gets whether the "conversion_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConversionMode {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "conversion_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConversionMode() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DetectionsToRectsCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DetectionsToRectsCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RotationVectorStartKeypointIndex != other.RotationVectorStartKeypointIndex) return false;
      if (RotationVectorEndKeypointIndex != other.RotationVectorEndKeypointIndex) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RotationVectorTargetAngle, other.RotationVectorTargetAngle)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RotationVectorTargetAngleDegrees, other.RotationVectorTargetAngleDegrees)) return false;
      if (OutputZeroRectForEmptyDetections != other.OutputZeroRectForEmptyDetections) return false;
      if (ConversionMode != other.ConversionMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRotationVectorStartKeypointIndex) hash ^= RotationVectorStartKeypointIndex.GetHashCode();
      if (HasRotationVectorEndKeypointIndex) hash ^= RotationVectorEndKeypointIndex.GetHashCode();
      if (HasRotationVectorTargetAngle) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RotationVectorTargetAngle);
      if (HasRotationVectorTargetAngleDegrees) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RotationVectorTargetAngleDegrees);
      if (HasOutputZeroRectForEmptyDetections) hash ^= OutputZeroRectForEmptyDetections.GetHashCode();
      if (HasConversionMode) hash ^= ConversionMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRotationVectorStartKeypointIndex) {
        output.WriteRawTag(8);
        output.WriteInt32(RotationVectorStartKeypointIndex);
      }
      if (HasRotationVectorEndKeypointIndex) {
        output.WriteRawTag(16);
        output.WriteInt32(RotationVectorEndKeypointIndex);
      }
      if (HasRotationVectorTargetAngle) {
        output.WriteRawTag(29);
        output.WriteFloat(RotationVectorTargetAngle);
      }
      if (HasRotationVectorTargetAngleDegrees) {
        output.WriteRawTag(37);
        output.WriteFloat(RotationVectorTargetAngleDegrees);
      }
      if (HasOutputZeroRectForEmptyDetections) {
        output.WriteRawTag(40);
        output.WriteBool(OutputZeroRectForEmptyDetections);
      }
      if (HasConversionMode) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ConversionMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRotationVectorStartKeypointIndex) {
        output.WriteRawTag(8);
        output.WriteInt32(RotationVectorStartKeypointIndex);
      }
      if (HasRotationVectorEndKeypointIndex) {
        output.WriteRawTag(16);
        output.WriteInt32(RotationVectorEndKeypointIndex);
      }
      if (HasRotationVectorTargetAngle) {
        output.WriteRawTag(29);
        output.WriteFloat(RotationVectorTargetAngle);
      }
      if (HasRotationVectorTargetAngleDegrees) {
        output.WriteRawTag(37);
        output.WriteFloat(RotationVectorTargetAngleDegrees);
      }
      if (HasOutputZeroRectForEmptyDetections) {
        output.WriteRawTag(40);
        output.WriteBool(OutputZeroRectForEmptyDetections);
      }
      if (HasConversionMode) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ConversionMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRotationVectorStartKeypointIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RotationVectorStartKeypointIndex);
      }
      if (HasRotationVectorEndKeypointIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RotationVectorEndKeypointIndex);
      }
      if (HasRotationVectorTargetAngle) {
        size += 1 + 4;
      }
      if (HasRotationVectorTargetAngleDegrees) {
        size += 1 + 4;
      }
      if (HasOutputZeroRectForEmptyDetections) {
        size += 1 + 1;
      }
      if (HasConversionMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConversionMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DetectionsToRectsCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasRotationVectorStartKeypointIndex) {
        RotationVectorStartKeypointIndex = other.RotationVectorStartKeypointIndex;
      }
      if (other.HasRotationVectorEndKeypointIndex) {
        RotationVectorEndKeypointIndex = other.RotationVectorEndKeypointIndex;
      }
      if (other.HasRotationVectorTargetAngle) {
        RotationVectorTargetAngle = other.RotationVectorTargetAngle;
      }
      if (other.HasRotationVectorTargetAngleDegrees) {
        RotationVectorTargetAngleDegrees = other.RotationVectorTargetAngleDegrees;
      }
      if (other.HasOutputZeroRectForEmptyDetections) {
        OutputZeroRectForEmptyDetections = other.OutputZeroRectForEmptyDetections;
      }
      if (other.HasConversionMode) {
        ConversionMode = other.ConversionMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RotationVectorStartKeypointIndex = input.ReadInt32();
            break;
          }
          case 16: {
            RotationVectorEndKeypointIndex = input.ReadInt32();
            break;
          }
          case 29: {
            RotationVectorTargetAngle = input.ReadFloat();
            break;
          }
          case 37: {
            RotationVectorTargetAngleDegrees = input.ReadFloat();
            break;
          }
          case 40: {
            OutputZeroRectForEmptyDetections = input.ReadBool();
            break;
          }
          case 48: {
            ConversionMode = (global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RotationVectorStartKeypointIndex = input.ReadInt32();
            break;
          }
          case 16: {
            RotationVectorEndKeypointIndex = input.ReadInt32();
            break;
          }
          case 29: {
            RotationVectorTargetAngle = input.ReadFloat();
            break;
          }
          case 37: {
            RotationVectorTargetAngleDegrees = input.ReadFloat();
            break;
          }
          case 40: {
            OutputZeroRectForEmptyDetections = input.ReadBool();
            break;
          }
          case 48: {
            ConversionMode = (global::Mediapipe.DetectionsToRectsCalculatorOptions.Types.ConversionMode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the DetectionsToRectsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ConversionMode {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("USE_BOUNDING_BOX")] UseBoundingBox = 1,
        [pbr::OriginalName("USE_KEYPOINTS")] UseKeypoints = 2,
      }

    }
    #endregion

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the DetectionsToRectsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.DetectionsToRectsCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.DetectionsToRectsCalculatorOptions>(262691807, pb::FieldCodec.ForMessage(2101534458, global::Mediapipe.DetectionsToRectsCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

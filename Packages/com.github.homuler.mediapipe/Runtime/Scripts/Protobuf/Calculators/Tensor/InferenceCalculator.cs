// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/tensor/inference_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/tensor/inference_calculator.proto</summary>
  public static partial class InferenceCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/tensor/inference_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static InferenceCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjdtZWRpYXBpcGUvY2FsY3VsYXRvcnMvdGVuc29yL2luZmVyZW5jZV9jYWxj",
            "dWxhdG9yLnByb3RvEgltZWRpYXBpcGUaJG1lZGlhcGlwZS9mcmFtZXdvcmsv",
            "Y2FsY3VsYXRvci5wcm90bxosbWVkaWFwaXBlL2ZyYW1ld29yay9jYWxjdWxh",
            "dG9yX29wdGlvbnMucHJvdG8i+BEKGkluZmVyZW5jZUNhbGN1bGF0b3JPcHRp",
            "b25zEhIKCm1vZGVsX3BhdGgYASABKAkSFgoOdHJ5X21tYXBfbW9kZWwYByAB",
            "KAgSGgoHdXNlX2dwdRgCIAEoCDoFZmFsc2VCAhgBEhwKCXVzZV9ubmFwaRgD",
            "IAEoCDoFZmFsc2VCAhgBEhoKDmNwdV9udW1fdGhyZWFkGAQgASgFOgItMRJA",
            "CghkZWxlZ2F0ZRgFIAEoCzIuLm1lZGlhcGlwZS5JbmZlcmVuY2VDYWxjdWxh",
            "dG9yT3B0aW9ucy5EZWxlZ2F0ZRJUChNpbnB1dF9vdXRwdXRfY29uZmlnGAgg",
            "ASgLMjcubWVkaWFwaXBlLkluZmVyZW5jZUNhbGN1bGF0b3JPcHRpb25zLklu",
            "cHV0T3V0cHV0Q29uZmlnGt4ICghEZWxlZ2F0ZRJHCgZ0ZmxpdGUYASABKAsy",
            "NS5tZWRpYXBpcGUuSW5mZXJlbmNlQ2FsY3VsYXRvck9wdGlvbnMuRGVsZWdh",
            "dGUuVGZMaXRlSAASQQoDZ3B1GAIgASgLMjIubWVkaWFwaXBlLkluZmVyZW5j",
            "ZUNhbGN1bGF0b3JPcHRpb25zLkRlbGVnYXRlLkdwdUgAEkUKBW5uYXBpGAMg",
            "ASgLMjQubWVkaWFwaXBlLkluZmVyZW5jZUNhbGN1bGF0b3JPcHRpb25zLkRl",
            "bGVnYXRlLk5uYXBpSAASSQoHeG5ucGFjaxgEIAEoCzI2Lm1lZGlhcGlwZS5J",
            "bmZlcmVuY2VDYWxjdWxhdG9yT3B0aW9ucy5EZWxlZ2F0ZS5Ybm5wYWNrSAAa",
            "CAoGVGZMaXRlGoQFCgNHcHUSIwoUdXNlX2FkdmFuY2VkX2dwdV9hcGkYASAB",
            "KAg6BWZhbHNlEkgKA2FwaRgEIAEoDjI2Lm1lZGlhcGlwZS5JbmZlcmVuY2VD",
            "YWxjdWxhdG9yT3B0aW9ucy5EZWxlZ2F0ZS5HcHUuQXBpOgNBTlkSIgoUYWxs",
            "b3dfcHJlY2lzaW9uX2xvc3MYAyABKAg6BHRydWUSGgoSY2FjaGVkX2tlcm5l",
            "bF9wYXRoGAIgASgJEhwKFHNlcmlhbGl6ZWRfbW9kZWxfZGlyGAcgASgJEncK",
            "FmNhY2hlX3dyaXRpbmdfYmVoYXZpb3IYCiABKA4yRy5tZWRpYXBpcGUuSW5m",
            "ZXJlbmNlQ2FsY3VsYXRvck9wdGlvbnMuRGVsZWdhdGUuR3B1LkNhY2hlV3Jp",
            "dGluZ0JlaGF2aW9yOg5XUklURV9PUl9FUlJPUhITCgttb2RlbF90b2tlbhgI",
            "IAEoCRJhCgV1c2FnZRgFIAEoDjJBLm1lZGlhcGlwZS5JbmZlcmVuY2VDYWxj",
            "dWxhdG9yT3B0aW9ucy5EZWxlZ2F0ZS5HcHUuSW5mZXJlbmNlVXNhZ2U6D1NV",
            "U1RBSU5FRF9TUEVFRCImCgNBcGkSBwoDQU5ZEAASCgoGT1BFTkdMEAESCgoG",
            "T1BFTkNMEAIiRwoUQ2FjaGVXcml0aW5nQmVoYXZpb3ISDAoITk9fV1JJVEUQ",
            "ABINCglUUllfV1JJVEUQARISCg5XUklURV9PUl9FUlJPUhACIk4KDkluZmVy",
            "ZW5jZVVzYWdlEg8KC1VOU1BFQ0lGSUVEEAASFgoSRkFTVF9TSU5HTEVfQU5T",
            "V0VSEAESEwoPU1VTVEFJTkVEX1NQRUVEEAIaSQoFTm5hcGkSEQoJY2FjaGVf",
            "ZGlyGAEgASgJEhMKC21vZGVsX3Rva2VuGAIgASgJEhgKEGFjY2VsZXJhdG9y",
            "X25hbWUYAyABKAkaTAoHWG5ucGFjaxIXCgtudW1fdGhyZWFkcxgBIAEoBToC",
            "LTESIgoaZW5hYmxlX3plcm9fY29weV90ZW5zb3JfaW8YByABKAhKBAgDEARC",
            "CgoIZGVsZWdhdGUaiAYKEUlucHV0T3V0cHV0Q29uZmlnEmwKGGlucHV0X3Rl",
            "bnNvcl9pbmRpY2VzX21hcBgBIAEoCzJILm1lZGlhcGlwZS5JbmZlcmVuY2VD",
            "YWxjdWxhdG9yT3B0aW9ucy5JbnB1dE91dHB1dENvbmZpZy5UZW5zb3JJbmRp",
            "Y2VzTWFwSAASaAoWaW5wdXRfdGVuc29yX25hbWVzX21hcBgDIAEoCzJGLm1l",
            "ZGlhcGlwZS5JbmZlcmVuY2VDYWxjdWxhdG9yT3B0aW9ucy5JbnB1dE91dHB1",
            "dENvbmZpZy5UZW5zb3JOYW1lc01hcEgAEm0KGW91dHB1dF90ZW5zb3JfaW5k",
            "aWNlc19tYXAYAiABKAsySC5tZWRpYXBpcGUuSW5mZXJlbmNlQ2FsY3VsYXRv",
            "ck9wdGlvbnMuSW5wdXRPdXRwdXRDb25maWcuVGVuc29ySW5kaWNlc01hcEgB",
            "EmkKF291dHB1dF90ZW5zb3JfbmFtZXNfbWFwGAQgASgLMkYubWVkaWFwaXBl",
            "LkluZmVyZW5jZUNhbGN1bGF0b3JPcHRpb25zLklucHV0T3V0cHV0Q29uZmln",
            "LlRlbnNvck5hbWVzTWFwSAESaQoVZmVlZGJhY2tfdGVuc29yX2xpbmtzGAUg",
            "AygLMkoubWVkaWFwaXBlLkluZmVyZW5jZUNhbGN1bGF0b3JPcHRpb25zLklu",
            "cHV0T3V0cHV0Q29uZmlnLkZlZWRiYWNrVGVuc29yTGluaxo0ChBUZW5zb3JJ",
            "bmRpY2VzTWFwEiAKFG1vZGVsX3RlbnNvcl9pbmRpY2VzGAEgAygFQgIQARom",
            "Cg5UZW5zb3JOYW1lc01hcBIUCgx0ZW5zb3JfbmFtZXMYASADKAkaUwoSRmVl",
            "ZGJhY2tUZW5zb3JMaW5rEh8KF2Zyb21fb3V0cHV0X3RlbnNvcl9uYW1lGAEg",
            "ASgJEhwKFHRvX2lucHV0X3RlbnNvcl9uYW1lGAIgASgJQhAKDklucHV0VGVu",
            "c29yTWFwQhEKD091dHB1dFRlbnNvck1hcDJUCgNleHQSHC5tZWRpYXBpcGUu",
            "Q2FsY3VsYXRvck9wdGlvbnMY99PLoAEgASgLMiUubWVkaWFwaXBlLkluZmVy",
            "ZW5jZUNhbGN1bGF0b3JPcHRpb25zQkEKJWNvbS5nb29nbGUubWVkaWFwaXBl",
            "LmNhbGN1bGF0b3IucHJvdG9CGEluZmVyZW5jZUNhbGN1bGF0b3JQcm90bw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, global::Mediapipe.CalculatorOptionsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions), global::Mediapipe.InferenceCalculatorOptions.Parser, new[]{ "ModelPath", "TryMmapModel", "UseGpu", "UseNnapi", "CpuNumThread", "Delegate", "InputOutputConfig" }, null, null, new pb::Extension[] { global::Mediapipe.InferenceCalculatorOptions.Extensions.Ext }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate), global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Parser, new[]{ "Tflite", "Gpu", "Nnapi", "Xnnpack" }, new[]{ "Delegate" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite), global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu), global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Parser, new[]{ "UseAdvancedGpuApi", "Api", "AllowPrecisionLoss", "CachedKernelPath", "SerializedModelDir", "CacheWritingBehavior", "ModelToken", "Usage" }, null, new[]{ typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api), typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior), typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi), global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi.Parser, new[]{ "CacheDir", "ModelToken", "AcceleratorName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack), global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack.Parser, new[]{ "NumThreads", "EnableZeroCopyTensorIo" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig), global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Parser, new[]{ "InputTensorIndicesMap", "InputTensorNamesMap", "OutputTensorIndicesMap", "OutputTensorNamesMap", "FeedbackTensorLinks" }, new[]{ "InputTensorMap", "OutputTensorMap" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap), global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap.Parser, new[]{ "ModelTensorIndices" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap), global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap.Parser, new[]{ "TensorNames" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink), global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink.Parser, new[]{ "FromOutputTensorName", "ToInputTensorName" }, null, null, null, null)})})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Full Example:
  ///
  /// node {
  ///   calculator: "InferenceCalculator"
  ///   input_stream: "TENSOR_IN:image_tensors"
  ///   output_stream: "TENSOR_OUT:result_tensors"
  ///   options {
  ///     [mediapipe.InferenceCalculatorOptions.ext] {
  ///       model_path: "model.tflite"
  ///       try_mmap_model: true
  ///       delegate { gpu {} }
  ///     }
  ///   }
  /// }
  /// </summary>
  public sealed partial class InferenceCalculatorOptions : pb::IMessage<InferenceCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InferenceCalculatorOptions> _parser = new pb::MessageParser<InferenceCalculatorOptions>(() => new InferenceCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InferenceCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.InferenceCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InferenceCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InferenceCalculatorOptions(InferenceCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      modelPath_ = other.modelPath_;
      tryMmapModel_ = other.tryMmapModel_;
      useGpu_ = other.useGpu_;
      useNnapi_ = other.useNnapi_;
      cpuNumThread_ = other.cpuNumThread_;
      delegate_ = other.delegate_ != null ? other.delegate_.Clone() : null;
      inputOutputConfig_ = other.inputOutputConfig_ != null ? other.inputOutputConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InferenceCalculatorOptions Clone() {
      return new InferenceCalculatorOptions(this);
    }

    /// <summary>Field number for the "model_path" field.</summary>
    public const int ModelPathFieldNumber = 1;
    private readonly static string ModelPathDefaultValue = "";

    private string modelPath_;
    /// <summary>
    /// Path to the TF Lite model (ex: /path/to/modelname.tflite).
    /// On mobile, this is generally just modelname.tflite.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ModelPath {
      get { return modelPath_ ?? ModelPathDefaultValue; }
      set {
        modelPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "model_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasModelPath {
      get { return modelPath_ != null; }
    }
    /// <summary>Clears the value of the "model_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearModelPath() {
      modelPath_ = null;
    }

    /// <summary>Field number for the "try_mmap_model" field.</summary>
    public const int TryMmapModelFieldNumber = 7;
    private readonly static bool TryMmapModelDefaultValue = false;

    private bool tryMmapModel_;
    /// <summary>
    /// If true, and model_path is specified, tries to load the model as memory
    /// mapped file if available. This can be significantly faster that loading the
    /// model into a buffer first. If memory mapping is not available or fails,
    /// falls back to loading from buffer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TryMmapModel {
      get { if ((_hasBits0 & 8) != 0) { return tryMmapModel_; } else { return TryMmapModelDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tryMmapModel_ = value;
      }
    }
    /// <summary>Gets whether the "try_mmap_model" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTryMmapModel {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "try_mmap_model" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTryMmapModel() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "use_gpu" field.</summary>
    public const int UseGpuFieldNumber = 2;
    private readonly static bool UseGpuDefaultValue = false;

    private bool useGpu_;
    /// <summary>
    /// Whether the TF Lite GPU or CPU backend should be used. Effective only when
    /// input tensors are on CPU. For input tensors on GPU, GPU backend is always
    /// used.
    /// DEPRECATED: configure "delegate" instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseGpu {
      get { if ((_hasBits0 & 1) != 0) { return useGpu_; } else { return UseGpuDefaultValue; } }
      set {
        _hasBits0 |= 1;
        useGpu_ = value;
      }
    }
    /// <summary>Gets whether the "use_gpu" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseGpu {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "use_gpu" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseGpu() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "use_nnapi" field.</summary>
    public const int UseNnapiFieldNumber = 3;
    private readonly static bool UseNnapiDefaultValue = false;

    private bool useNnapi_;
    /// <summary>
    /// Android only. When true, an NNAPI delegate will be used for inference.
    /// If NNAPI is not available, then the default CPU delegate will be used
    /// automatically.
    /// DEPRECATED: configure "delegate" instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseNnapi {
      get { if ((_hasBits0 & 2) != 0) { return useNnapi_; } else { return UseNnapiDefaultValue; } }
      set {
        _hasBits0 |= 2;
        useNnapi_ = value;
      }
    }
    /// <summary>Gets whether the "use_nnapi" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseNnapi {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "use_nnapi" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseNnapi() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "cpu_num_thread" field.</summary>
    public const int CpuNumThreadFieldNumber = 4;
    private readonly static int CpuNumThreadDefaultValue = -1;

    private int cpuNumThread_;
    /// <summary>
    /// The number of threads available to the interpreter. Effective only when
    /// input tensors are on CPU and 'use_gpu' is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CpuNumThread {
      get { if ((_hasBits0 & 4) != 0) { return cpuNumThread_; } else { return CpuNumThreadDefaultValue; } }
      set {
        _hasBits0 |= 4;
        cpuNumThread_ = value;
      }
    }
    /// <summary>Gets whether the "cpu_num_thread" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCpuNumThread {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "cpu_num_thread" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCpuNumThread() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "delegate" field.</summary>
    public const int DelegateFieldNumber = 5;
    private global::Mediapipe.InferenceCalculatorOptions.Types.Delegate delegate_;
    /// <summary>
    /// TfLite delegate to run inference.
    /// If not specified, TFLite GPU delegate is used by default (as if "gpu {}"
    /// is specified) unless GPU support is disabled in the build (i.e., with
    /// --define MEDIAPIPE_DISABLE_GPU=1), in which case regular TFLite on CPU is
    /// used (as if "tflite {}" is specified) except when building with emscripten
    /// where xnnpack is used.
    /// NOTE: use_gpu/use_nnapi are ignored if specified. (Delegate takes
    /// precedence over use_* deprecated options.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate Delegate {
      get { return delegate_; }
      set {
        delegate_ = value;
      }
    }

    /// <summary>Field number for the "input_output_config" field.</summary>
    public const int InputOutputConfigFieldNumber = 8;
    private global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig inputOutputConfig_;
    /// <summary>
    /// Optionally remaps input and output tensors to align with TfLite model and
    /// InferenceCalculator input/output stream order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig InputOutputConfig {
      get { return inputOutputConfig_; }
      set {
        inputOutputConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InferenceCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InferenceCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ModelPath != other.ModelPath) return false;
      if (TryMmapModel != other.TryMmapModel) return false;
      if (UseGpu != other.UseGpu) return false;
      if (UseNnapi != other.UseNnapi) return false;
      if (CpuNumThread != other.CpuNumThread) return false;
      if (!object.Equals(Delegate, other.Delegate)) return false;
      if (!object.Equals(InputOutputConfig, other.InputOutputConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasModelPath) hash ^= ModelPath.GetHashCode();
      if (HasTryMmapModel) hash ^= TryMmapModel.GetHashCode();
      if (HasUseGpu) hash ^= UseGpu.GetHashCode();
      if (HasUseNnapi) hash ^= UseNnapi.GetHashCode();
      if (HasCpuNumThread) hash ^= CpuNumThread.GetHashCode();
      if (delegate_ != null) hash ^= Delegate.GetHashCode();
      if (inputOutputConfig_ != null) hash ^= InputOutputConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasModelPath) {
        output.WriteRawTag(10);
        output.WriteString(ModelPath);
      }
      if (HasUseGpu) {
        output.WriteRawTag(16);
        output.WriteBool(UseGpu);
      }
      if (HasUseNnapi) {
        output.WriteRawTag(24);
        output.WriteBool(UseNnapi);
      }
      if (HasCpuNumThread) {
        output.WriteRawTag(32);
        output.WriteInt32(CpuNumThread);
      }
      if (delegate_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Delegate);
      }
      if (HasTryMmapModel) {
        output.WriteRawTag(56);
        output.WriteBool(TryMmapModel);
      }
      if (inputOutputConfig_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(InputOutputConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasModelPath) {
        output.WriteRawTag(10);
        output.WriteString(ModelPath);
      }
      if (HasUseGpu) {
        output.WriteRawTag(16);
        output.WriteBool(UseGpu);
      }
      if (HasUseNnapi) {
        output.WriteRawTag(24);
        output.WriteBool(UseNnapi);
      }
      if (HasCpuNumThread) {
        output.WriteRawTag(32);
        output.WriteInt32(CpuNumThread);
      }
      if (delegate_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Delegate);
      }
      if (HasTryMmapModel) {
        output.WriteRawTag(56);
        output.WriteBool(TryMmapModel);
      }
      if (inputOutputConfig_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(InputOutputConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasModelPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelPath);
      }
      if (HasTryMmapModel) {
        size += 1 + 1;
      }
      if (HasUseGpu) {
        size += 1 + 1;
      }
      if (HasUseNnapi) {
        size += 1 + 1;
      }
      if (HasCpuNumThread) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CpuNumThread);
      }
      if (delegate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Delegate);
      }
      if (inputOutputConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputOutputConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InferenceCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasModelPath) {
        ModelPath = other.ModelPath;
      }
      if (other.HasTryMmapModel) {
        TryMmapModel = other.TryMmapModel;
      }
      if (other.HasUseGpu) {
        UseGpu = other.UseGpu;
      }
      if (other.HasUseNnapi) {
        UseNnapi = other.UseNnapi;
      }
      if (other.HasCpuNumThread) {
        CpuNumThread = other.CpuNumThread;
      }
      if (other.delegate_ != null) {
        if (delegate_ == null) {
          Delegate = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate();
        }
        Delegate.MergeFrom(other.Delegate);
      }
      if (other.inputOutputConfig_ != null) {
        if (inputOutputConfig_ == null) {
          InputOutputConfig = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig();
        }
        InputOutputConfig.MergeFrom(other.InputOutputConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ModelPath = input.ReadString();
            break;
          }
          case 16: {
            UseGpu = input.ReadBool();
            break;
          }
          case 24: {
            UseNnapi = input.ReadBool();
            break;
          }
          case 32: {
            CpuNumThread = input.ReadInt32();
            break;
          }
          case 42: {
            if (delegate_ == null) {
              Delegate = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate();
            }
            input.ReadMessage(Delegate);
            break;
          }
          case 56: {
            TryMmapModel = input.ReadBool();
            break;
          }
          case 66: {
            if (inputOutputConfig_ == null) {
              InputOutputConfig = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig();
            }
            input.ReadMessage(InputOutputConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ModelPath = input.ReadString();
            break;
          }
          case 16: {
            UseGpu = input.ReadBool();
            break;
          }
          case 24: {
            UseNnapi = input.ReadBool();
            break;
          }
          case 32: {
            CpuNumThread = input.ReadInt32();
            break;
          }
          case 42: {
            if (delegate_ == null) {
              Delegate = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate();
            }
            input.ReadMessage(Delegate);
            break;
          }
          case 56: {
            TryMmapModel = input.ReadBool();
            break;
          }
          case 66: {
            if (inputOutputConfig_ == null) {
              InputOutputConfig = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig();
            }
            input.ReadMessage(InputOutputConfig);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the InferenceCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Delegate : pb::IMessage<Delegate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Delegate> _parser = new pb::MessageParser<Delegate>(() => new Delegate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Delegate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.InferenceCalculatorOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Delegate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Delegate(Delegate other) : this() {
          switch (other.DelegateCase) {
            case DelegateOneofCase.Tflite:
              Tflite = other.Tflite.Clone();
              break;
            case DelegateOneofCase.Gpu:
              Gpu = other.Gpu.Clone();
              break;
            case DelegateOneofCase.Nnapi:
              Nnapi = other.Nnapi.Clone();
              break;
            case DelegateOneofCase.Xnnpack:
              Xnnpack = other.Xnnpack.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Delegate Clone() {
          return new Delegate(this);
        }

        /// <summary>Field number for the "tflite" field.</summary>
        public const int TfliteFieldNumber = 1;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite Tflite {
          get { return delegateCase_ == DelegateOneofCase.Tflite ? (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite) delegate_ : null; }
          set {
            delegate_ = value;
            delegateCase_ = value == null ? DelegateOneofCase.None : DelegateOneofCase.Tflite;
          }
        }

        /// <summary>Field number for the "gpu" field.</summary>
        public const int GpuFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu Gpu {
          get { return delegateCase_ == DelegateOneofCase.Gpu ? (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu) delegate_ : null; }
          set {
            delegate_ = value;
            delegateCase_ = value == null ? DelegateOneofCase.None : DelegateOneofCase.Gpu;
          }
        }

        /// <summary>Field number for the "nnapi" field.</summary>
        public const int NnapiFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi Nnapi {
          get { return delegateCase_ == DelegateOneofCase.Nnapi ? (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi) delegate_ : null; }
          set {
            delegate_ = value;
            delegateCase_ = value == null ? DelegateOneofCase.None : DelegateOneofCase.Nnapi;
          }
        }

        /// <summary>Field number for the "xnnpack" field.</summary>
        public const int XnnpackFieldNumber = 4;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack Xnnpack {
          get { return delegateCase_ == DelegateOneofCase.Xnnpack ? (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack) delegate_ : null; }
          set {
            delegate_ = value;
            delegateCase_ = value == null ? DelegateOneofCase.None : DelegateOneofCase.Xnnpack;
          }
        }

        private object delegate_;
        /// <summary>Enum of possible cases for the "delegate" oneof.</summary>
        public enum DelegateOneofCase {
          None = 0,
          Tflite = 1,
          Gpu = 2,
          Nnapi = 3,
          Xnnpack = 4,
        }
        private DelegateOneofCase delegateCase_ = DelegateOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DelegateOneofCase DelegateCase {
          get { return delegateCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDelegate() {
          delegateCase_ = DelegateOneofCase.None;
          delegate_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Delegate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Delegate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Tflite, other.Tflite)) return false;
          if (!object.Equals(Gpu, other.Gpu)) return false;
          if (!object.Equals(Nnapi, other.Nnapi)) return false;
          if (!object.Equals(Xnnpack, other.Xnnpack)) return false;
          if (DelegateCase != other.DelegateCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (delegateCase_ == DelegateOneofCase.Tflite) hash ^= Tflite.GetHashCode();
          if (delegateCase_ == DelegateOneofCase.Gpu) hash ^= Gpu.GetHashCode();
          if (delegateCase_ == DelegateOneofCase.Nnapi) hash ^= Nnapi.GetHashCode();
          if (delegateCase_ == DelegateOneofCase.Xnnpack) hash ^= Xnnpack.GetHashCode();
          hash ^= (int) delegateCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (delegateCase_ == DelegateOneofCase.Tflite) {
            output.WriteRawTag(10);
            output.WriteMessage(Tflite);
          }
          if (delegateCase_ == DelegateOneofCase.Gpu) {
            output.WriteRawTag(18);
            output.WriteMessage(Gpu);
          }
          if (delegateCase_ == DelegateOneofCase.Nnapi) {
            output.WriteRawTag(26);
            output.WriteMessage(Nnapi);
          }
          if (delegateCase_ == DelegateOneofCase.Xnnpack) {
            output.WriteRawTag(34);
            output.WriteMessage(Xnnpack);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (delegateCase_ == DelegateOneofCase.Tflite) {
            output.WriteRawTag(10);
            output.WriteMessage(Tflite);
          }
          if (delegateCase_ == DelegateOneofCase.Gpu) {
            output.WriteRawTag(18);
            output.WriteMessage(Gpu);
          }
          if (delegateCase_ == DelegateOneofCase.Nnapi) {
            output.WriteRawTag(26);
            output.WriteMessage(Nnapi);
          }
          if (delegateCase_ == DelegateOneofCase.Xnnpack) {
            output.WriteRawTag(34);
            output.WriteMessage(Xnnpack);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (delegateCase_ == DelegateOneofCase.Tflite) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tflite);
          }
          if (delegateCase_ == DelegateOneofCase.Gpu) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gpu);
          }
          if (delegateCase_ == DelegateOneofCase.Nnapi) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Nnapi);
          }
          if (delegateCase_ == DelegateOneofCase.Xnnpack) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Xnnpack);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Delegate other) {
          if (other == null) {
            return;
          }
          switch (other.DelegateCase) {
            case DelegateOneofCase.Tflite:
              if (Tflite == null) {
                Tflite = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite();
              }
              Tflite.MergeFrom(other.Tflite);
              break;
            case DelegateOneofCase.Gpu:
              if (Gpu == null) {
                Gpu = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu();
              }
              Gpu.MergeFrom(other.Gpu);
              break;
            case DelegateOneofCase.Nnapi:
              if (Nnapi == null) {
                Nnapi = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi();
              }
              Nnapi.MergeFrom(other.Nnapi);
              break;
            case DelegateOneofCase.Xnnpack:
              if (Xnnpack == null) {
                Xnnpack = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack();
              }
              Xnnpack.MergeFrom(other.Xnnpack);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite();
                if (delegateCase_ == DelegateOneofCase.Tflite) {
                  subBuilder.MergeFrom(Tflite);
                }
                input.ReadMessage(subBuilder);
                Tflite = subBuilder;
                break;
              }
              case 18: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu();
                if (delegateCase_ == DelegateOneofCase.Gpu) {
                  subBuilder.MergeFrom(Gpu);
                }
                input.ReadMessage(subBuilder);
                Gpu = subBuilder;
                break;
              }
              case 26: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi();
                if (delegateCase_ == DelegateOneofCase.Nnapi) {
                  subBuilder.MergeFrom(Nnapi);
                }
                input.ReadMessage(subBuilder);
                Nnapi = subBuilder;
                break;
              }
              case 34: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack();
                if (delegateCase_ == DelegateOneofCase.Xnnpack) {
                  subBuilder.MergeFrom(Xnnpack);
                }
                input.ReadMessage(subBuilder);
                Xnnpack = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.TfLite();
                if (delegateCase_ == DelegateOneofCase.Tflite) {
                  subBuilder.MergeFrom(Tflite);
                }
                input.ReadMessage(subBuilder);
                Tflite = subBuilder;
                break;
              }
              case 18: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu();
                if (delegateCase_ == DelegateOneofCase.Gpu) {
                  subBuilder.MergeFrom(Gpu);
                }
                input.ReadMessage(subBuilder);
                Gpu = subBuilder;
                break;
              }
              case 26: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Nnapi();
                if (delegateCase_ == DelegateOneofCase.Nnapi) {
                  subBuilder.MergeFrom(Nnapi);
                }
                input.ReadMessage(subBuilder);
                Nnapi = subBuilder;
                break;
              }
              case 34: {
                global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Xnnpack();
                if (delegateCase_ == DelegateOneofCase.Xnnpack) {
                  subBuilder.MergeFrom(Xnnpack);
                }
                input.ReadMessage(subBuilder);
                Xnnpack = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Delegate message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Default inference provided by tflite.
          /// </summary>
          public sealed partial class TfLite : pb::IMessage<TfLite>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<TfLite> _parser = new pb::MessageParser<TfLite>(() => new TfLite());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<TfLite> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TfLite() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TfLite(TfLite other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TfLite Clone() {
              return new TfLite(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as TfLite);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(TfLite other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(TfLite other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Delegate to run GPU inference depending on the device.
          /// (Can use OpenGl, OpenCl, Metal depending on the device.)
          /// </summary>
          public sealed partial class Gpu : pb::IMessage<Gpu>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Gpu> _parser = new pb::MessageParser<Gpu>(() => new Gpu());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Gpu> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Gpu() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Gpu(Gpu other) : this() {
              _hasBits0 = other._hasBits0;
              useAdvancedGpuApi_ = other.useAdvancedGpuApi_;
              api_ = other.api_;
              allowPrecisionLoss_ = other.allowPrecisionLoss_;
              cachedKernelPath_ = other.cachedKernelPath_;
              serializedModelDir_ = other.serializedModelDir_;
              cacheWritingBehavior_ = other.cacheWritingBehavior_;
              modelToken_ = other.modelToken_;
              usage_ = other.usage_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Gpu Clone() {
              return new Gpu(this);
            }

            /// <summary>Field number for the "use_advanced_gpu_api" field.</summary>
            public const int UseAdvancedGpuApiFieldNumber = 1;
            private readonly static bool UseAdvancedGpuApiDefaultValue = false;

            private bool useAdvancedGpuApi_;
            /// <summary>
            /// Experimental, Android/Linux only. Use TFLite GPU delegate API2 for
            /// the NN inference.
            /// example:
            ///   delegate: { gpu { use_advanced_gpu_api: true } }
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool UseAdvancedGpuApi {
              get { if ((_hasBits0 & 1) != 0) { return useAdvancedGpuApi_; } else { return UseAdvancedGpuApiDefaultValue; } }
              set {
                _hasBits0 |= 1;
                useAdvancedGpuApi_ = value;
              }
            }
            /// <summary>Gets whether the "use_advanced_gpu_api" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasUseAdvancedGpuApi {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "use_advanced_gpu_api" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearUseAdvancedGpuApi() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "api" field.</summary>
            public const int ApiFieldNumber = 4;
            private readonly static global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api ApiDefaultValue = global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api.Any;

            private global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api api_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api Api {
              get { if ((_hasBits0 & 4) != 0) { return api_; } else { return ApiDefaultValue; } }
              set {
                _hasBits0 |= 4;
                api_ = value;
              }
            }
            /// <summary>Gets whether the "api" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasApi {
              get { return (_hasBits0 & 4) != 0; }
            }
            /// <summary>Clears the value of the "api" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearApi() {
              _hasBits0 &= ~4;
            }

            /// <summary>Field number for the "allow_precision_loss" field.</summary>
            public const int AllowPrecisionLossFieldNumber = 3;
            private readonly static bool AllowPrecisionLossDefaultValue = true;

            private bool allowPrecisionLoss_;
            /// <summary>
            /// This option is valid for TFLite GPU delegate API2 only,
            /// Set to true to use 16-bit float precision. If max precision is needed,
            /// set to false for 32-bit float calculations only.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowPrecisionLoss {
              get { if ((_hasBits0 & 2) != 0) { return allowPrecisionLoss_; } else { return AllowPrecisionLossDefaultValue; } }
              set {
                _hasBits0 |= 2;
                allowPrecisionLoss_ = value;
              }
            }
            /// <summary>Gets whether the "allow_precision_loss" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAllowPrecisionLoss {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "allow_precision_loss" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAllowPrecisionLoss() {
              _hasBits0 &= ~2;
            }

            /// <summary>Field number for the "cached_kernel_path" field.</summary>
            public const int CachedKernelPathFieldNumber = 2;
            private readonly static string CachedKernelPathDefaultValue = "";

            private string cachedKernelPath_;
            /// <summary>
            /// Load pre-compiled serialized binary cache to accelerate init process.
            ///
            /// Kernel caching will only be enabled if this path is set.
            ///
            /// NOTE: available for OpenCL delegate on Android only when
            /// "use_advanced_gpu_api" is set  to true and either "model_path" or
            /// "model_token" is specified saving to:
            /// $cached_kernel_path/basename($model_path).ker
            /// or
            /// $cached_kernel_path/$model_token.ker if model_path is not specified.
            /// TODO b/330806422 - update to prefer model_token
            ///
            /// NOTE: binary cache usage may be skipped if valid serialized model,
            /// specified by "serialized_model_dir", exists.
            ///
            /// TODO b/202767296 - update to cached_kernel_dir
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string CachedKernelPath {
              get { return cachedKernelPath_ ?? CachedKernelPathDefaultValue; }
              set {
                cachedKernelPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "cached_kernel_path" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasCachedKernelPath {
              get { return cachedKernelPath_ != null; }
            }
            /// <summary>Clears the value of the "cached_kernel_path" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearCachedKernelPath() {
              cachedKernelPath_ = null;
            }

            /// <summary>Field number for the "serialized_model_dir" field.</summary>
            public const int SerializedModelDirFieldNumber = 7;
            private readonly static string SerializedModelDirDefaultValue = "";

            private string serializedModelDir_;
            /// <summary>
            /// A dir to load from and save to a pre-compiled serialized model used to
            /// accelerate init process.
            ///
            /// NOTE: available for OpenCL delegate on Android only when
            /// "use_advanced_gpu_api" is set to true and "model_token" is set
            /// properly.
            ///
            /// NOTE: serialized model takes precedence over binary cache
            /// specified by "cached_kernel_path", which still can be used if
            /// serialized model is invalid or missing.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string SerializedModelDir {
              get { return serializedModelDir_ ?? SerializedModelDirDefaultValue; }
              set {
                serializedModelDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "serialized_model_dir" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasSerializedModelDir {
              get { return serializedModelDir_ != null; }
            }
            /// <summary>Clears the value of the "serialized_model_dir" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearSerializedModelDir() {
              serializedModelDir_ = null;
            }

            /// <summary>Field number for the "cache_writing_behavior" field.</summary>
            public const int CacheWritingBehaviorFieldNumber = 10;
            private readonly static global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior CacheWritingBehaviorDefaultValue = global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior.WriteOrError;

            private global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior cacheWritingBehavior_;
            /// <summary>
            /// Specifies how GPU caches are written to disk.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior CacheWritingBehavior {
              get { if ((_hasBits0 & 16) != 0) { return cacheWritingBehavior_; } else { return CacheWritingBehaviorDefaultValue; } }
              set {
                _hasBits0 |= 16;
                cacheWritingBehavior_ = value;
              }
            }
            /// <summary>Gets whether the "cache_writing_behavior" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasCacheWritingBehavior {
              get { return (_hasBits0 & 16) != 0; }
            }
            /// <summary>Clears the value of the "cache_writing_behavior" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearCacheWritingBehavior() {
              _hasBits0 &= ~16;
            }

            /// <summary>Field number for the "model_token" field.</summary>
            public const int ModelTokenFieldNumber = 8;
            private readonly static string ModelTokenDefaultValue = "";

            private string modelToken_;
            /// <summary>
            /// Unique token identifying the model. Used in conjunction with
            /// "serialized_model_dir". It is the caller's responsibility to ensure
            /// there is no clash of the tokens.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string ModelToken {
              get { return modelToken_ ?? ModelTokenDefaultValue; }
              set {
                modelToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "model_token" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasModelToken {
              get { return modelToken_ != null; }
            }
            /// <summary>Clears the value of the "model_token" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearModelToken() {
              modelToken_ = null;
            }

            /// <summary>Field number for the "usage" field.</summary>
            public const int UsageFieldNumber = 5;
            private readonly static global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage UsageDefaultValue = global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage.SustainedSpeed;

            private global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage usage_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage Usage {
              get { if ((_hasBits0 & 8) != 0) { return usage_; } else { return UsageDefaultValue; } }
              set {
                _hasBits0 |= 8;
                usage_ = value;
              }
            }
            /// <summary>Gets whether the "usage" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasUsage {
              get { return (_hasBits0 & 8) != 0; }
            }
            /// <summary>Clears the value of the "usage" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearUsage() {
              _hasBits0 &= ~8;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Gpu);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Gpu other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (UseAdvancedGpuApi != other.UseAdvancedGpuApi) return false;
              if (Api != other.Api) return false;
              if (AllowPrecisionLoss != other.AllowPrecisionLoss) return false;
              if (CachedKernelPath != other.CachedKernelPath) return false;
              if (SerializedModelDir != other.SerializedModelDir) return false;
              if (CacheWritingBehavior != other.CacheWritingBehavior) return false;
              if (ModelToken != other.ModelToken) return false;
              if (Usage != other.Usage) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasUseAdvancedGpuApi) hash ^= UseAdvancedGpuApi.GetHashCode();
              if (HasApi) hash ^= Api.GetHashCode();
              if (HasAllowPrecisionLoss) hash ^= AllowPrecisionLoss.GetHashCode();
              if (HasCachedKernelPath) hash ^= CachedKernelPath.GetHashCode();
              if (HasSerializedModelDir) hash ^= SerializedModelDir.GetHashCode();
              if (HasCacheWritingBehavior) hash ^= CacheWritingBehavior.GetHashCode();
              if (HasModelToken) hash ^= ModelToken.GetHashCode();
              if (HasUsage) hash ^= Usage.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasUseAdvancedGpuApi) {
                output.WriteRawTag(8);
                output.WriteBool(UseAdvancedGpuApi);
              }
              if (HasCachedKernelPath) {
                output.WriteRawTag(18);
                output.WriteString(CachedKernelPath);
              }
              if (HasAllowPrecisionLoss) {
                output.WriteRawTag(24);
                output.WriteBool(AllowPrecisionLoss);
              }
              if (HasApi) {
                output.WriteRawTag(32);
                output.WriteEnum((int) Api);
              }
              if (HasUsage) {
                output.WriteRawTag(40);
                output.WriteEnum((int) Usage);
              }
              if (HasSerializedModelDir) {
                output.WriteRawTag(58);
                output.WriteString(SerializedModelDir);
              }
              if (HasModelToken) {
                output.WriteRawTag(66);
                output.WriteString(ModelToken);
              }
              if (HasCacheWritingBehavior) {
                output.WriteRawTag(80);
                output.WriteEnum((int) CacheWritingBehavior);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasUseAdvancedGpuApi) {
                output.WriteRawTag(8);
                output.WriteBool(UseAdvancedGpuApi);
              }
              if (HasCachedKernelPath) {
                output.WriteRawTag(18);
                output.WriteString(CachedKernelPath);
              }
              if (HasAllowPrecisionLoss) {
                output.WriteRawTag(24);
                output.WriteBool(AllowPrecisionLoss);
              }
              if (HasApi) {
                output.WriteRawTag(32);
                output.WriteEnum((int) Api);
              }
              if (HasUsage) {
                output.WriteRawTag(40);
                output.WriteEnum((int) Usage);
              }
              if (HasSerializedModelDir) {
                output.WriteRawTag(58);
                output.WriteString(SerializedModelDir);
              }
              if (HasModelToken) {
                output.WriteRawTag(66);
                output.WriteString(ModelToken);
              }
              if (HasCacheWritingBehavior) {
                output.WriteRawTag(80);
                output.WriteEnum((int) CacheWritingBehavior);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasUseAdvancedGpuApi) {
                size += 1 + 1;
              }
              if (HasApi) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Api);
              }
              if (HasAllowPrecisionLoss) {
                size += 1 + 1;
              }
              if (HasCachedKernelPath) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(CachedKernelPath);
              }
              if (HasSerializedModelDir) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(SerializedModelDir);
              }
              if (HasCacheWritingBehavior) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CacheWritingBehavior);
              }
              if (HasModelToken) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelToken);
              }
              if (HasUsage) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Usage);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Gpu other) {
              if (other == null) {
                return;
              }
              if (other.HasUseAdvancedGpuApi) {
                UseAdvancedGpuApi = other.UseAdvancedGpuApi;
              }
              if (other.HasApi) {
                Api = other.Api;
              }
              if (other.HasAllowPrecisionLoss) {
                AllowPrecisionLoss = other.AllowPrecisionLoss;
              }
              if (other.HasCachedKernelPath) {
                CachedKernelPath = other.CachedKernelPath;
              }
              if (other.HasSerializedModelDir) {
                SerializedModelDir = other.SerializedModelDir;
              }
              if (other.HasCacheWritingBehavior) {
                CacheWritingBehavior = other.CacheWritingBehavior;
              }
              if (other.HasModelToken) {
                ModelToken = other.ModelToken;
              }
              if (other.HasUsage) {
                Usage = other.Usage;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    UseAdvancedGpuApi = input.ReadBool();
                    break;
                  }
                  case 18: {
                    CachedKernelPath = input.ReadString();
                    break;
                  }
                  case 24: {
                    AllowPrecisionLoss = input.ReadBool();
                    break;
                  }
                  case 32: {
                    Api = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api) input.ReadEnum();
                    break;
                  }
                  case 40: {
                    Usage = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage) input.ReadEnum();
                    break;
                  }
                  case 58: {
                    SerializedModelDir = input.ReadString();
                    break;
                  }
                  case 66: {
                    ModelToken = input.ReadString();
                    break;
                  }
                  case 80: {
                    CacheWritingBehavior = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior) input.ReadEnum();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    UseAdvancedGpuApi = input.ReadBool();
                    break;
                  }
                  case 18: {
                    CachedKernelPath = input.ReadString();
                    break;
                  }
                  case 24: {
                    AllowPrecisionLoss = input.ReadBool();
                    break;
                  }
                  case 32: {
                    Api = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.Api) input.ReadEnum();
                    break;
                  }
                  case 40: {
                    Usage = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.InferenceUsage) input.ReadEnum();
                    break;
                  }
                  case 58: {
                    SerializedModelDir = input.ReadString();
                    break;
                  }
                  case 66: {
                    ModelToken = input.ReadString();
                    break;
                  }
                  case 80: {
                    CacheWritingBehavior = (global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Types.Gpu.Types.CacheWritingBehavior) input.ReadEnum();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the Gpu message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// This option is valid for TFLite GPU delegate API2 only,
              /// Choose any of available APIs to force running inference using it.
              /// </summary>
              public enum Api {
                [pbr::OriginalName("ANY")] Any = 0,
                [pbr::OriginalName("OPENGL")] Opengl = 1,
                [pbr::OriginalName("OPENCL")] Opencl = 2,
              }

              public enum CacheWritingBehavior {
                /// <summary>
                /// Do not write any caches.
                /// </summary>
                [pbr::OriginalName("NO_WRITE")] NoWrite = 0,
                /// <summary>
                /// Try to write caches, log on failure.
                /// </summary>
                [pbr::OriginalName("TRY_WRITE")] TryWrite = 1,
                /// <summary>
                /// Write caches or return an error if write fails.
                /// </summary>
                [pbr::OriginalName("WRITE_OR_ERROR")] WriteOrError = 2,
              }

              /// <summary>
              /// Encapsulated compilation/runtime tradeoffs.
              /// </summary>
              public enum InferenceUsage {
                [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// InferenceRunner will be used only once. Therefore, it is important to
                /// minimize bootstrap time as well.
                /// </summary>
                [pbr::OriginalName("FAST_SINGLE_ANSWER")] FastSingleAnswer = 1,
                /// <summary>
                /// Prefer maximizing the throughput. Same inference runner will be used
                /// repeatedly on different inputs.
                /// </summary>
                [pbr::OriginalName("SUSTAINED_SPEED")] SustainedSpeed = 2,
              }

            }
            #endregion

          }

          /// <summary>
          /// Android only.
          /// </summary>
          public sealed partial class Nnapi : pb::IMessage<Nnapi>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Nnapi> _parser = new pb::MessageParser<Nnapi>(() => new Nnapi());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Nnapi> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Nnapi() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Nnapi(Nnapi other) : this() {
              cacheDir_ = other.cacheDir_;
              modelToken_ = other.modelToken_;
              acceleratorName_ = other.acceleratorName_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Nnapi Clone() {
              return new Nnapi(this);
            }

            /// <summary>Field number for the "cache_dir" field.</summary>
            public const int CacheDirFieldNumber = 1;
            private readonly static string CacheDirDefaultValue = "";

            private string cacheDir_;
            /// <summary>
            /// Directory to store compilation cache. If unspecified, NNAPI will not
            /// try caching the compilation.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string CacheDir {
              get { return cacheDir_ ?? CacheDirDefaultValue; }
              set {
                cacheDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "cache_dir" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasCacheDir {
              get { return cacheDir_ != null; }
            }
            /// <summary>Clears the value of the "cache_dir" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearCacheDir() {
              cacheDir_ = null;
            }

            /// <summary>Field number for the "model_token" field.</summary>
            public const int ModelTokenFieldNumber = 2;
            private readonly static string ModelTokenDefaultValue = "";

            private string modelToken_;
            /// <summary>
            /// Unique token identifying the model. It is the caller's responsibility
            /// to ensure there is no clash of the tokens. If unspecified, NNAPI will
            /// not try caching the compilation.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string ModelToken {
              get { return modelToken_ ?? ModelTokenDefaultValue; }
              set {
                modelToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "model_token" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasModelToken {
              get { return modelToken_ != null; }
            }
            /// <summary>Clears the value of the "model_token" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearModelToken() {
              modelToken_ = null;
            }

            /// <summary>Field number for the "accelerator_name" field.</summary>
            public const int AcceleratorNameFieldNumber = 3;
            private readonly static string AcceleratorNameDefaultValue = "";

            private string acceleratorName_;
            /// <summary>
            /// The name of an accelerator to be used for NNAPI delegate, e.g.
            /// "google-edgetpu". When not specified, it will be selected by NNAPI.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string AcceleratorName {
              get { return acceleratorName_ ?? AcceleratorNameDefaultValue; }
              set {
                acceleratorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "accelerator_name" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAcceleratorName {
              get { return acceleratorName_ != null; }
            }
            /// <summary>Clears the value of the "accelerator_name" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAcceleratorName() {
              acceleratorName_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Nnapi);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Nnapi other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (CacheDir != other.CacheDir) return false;
              if (ModelToken != other.ModelToken) return false;
              if (AcceleratorName != other.AcceleratorName) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasCacheDir) hash ^= CacheDir.GetHashCode();
              if (HasModelToken) hash ^= ModelToken.GetHashCode();
              if (HasAcceleratorName) hash ^= AcceleratorName.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasCacheDir) {
                output.WriteRawTag(10);
                output.WriteString(CacheDir);
              }
              if (HasModelToken) {
                output.WriteRawTag(18);
                output.WriteString(ModelToken);
              }
              if (HasAcceleratorName) {
                output.WriteRawTag(26);
                output.WriteString(AcceleratorName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasCacheDir) {
                output.WriteRawTag(10);
                output.WriteString(CacheDir);
              }
              if (HasModelToken) {
                output.WriteRawTag(18);
                output.WriteString(ModelToken);
              }
              if (HasAcceleratorName) {
                output.WriteRawTag(26);
                output.WriteString(AcceleratorName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasCacheDir) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(CacheDir);
              }
              if (HasModelToken) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelToken);
              }
              if (HasAcceleratorName) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(AcceleratorName);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Nnapi other) {
              if (other == null) {
                return;
              }
              if (other.HasCacheDir) {
                CacheDir = other.CacheDir;
              }
              if (other.HasModelToken) {
                ModelToken = other.ModelToken;
              }
              if (other.HasAcceleratorName) {
                AcceleratorName = other.AcceleratorName;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    CacheDir = input.ReadString();
                    break;
                  }
                  case 18: {
                    ModelToken = input.ReadString();
                    break;
                  }
                  case 26: {
                    AcceleratorName = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    CacheDir = input.ReadString();
                    break;
                  }
                  case 18: {
                    ModelToken = input.ReadString();
                    break;
                  }
                  case 26: {
                    AcceleratorName = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          public sealed partial class Xnnpack : pb::IMessage<Xnnpack>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Xnnpack> _parser = new pb::MessageParser<Xnnpack>(() => new Xnnpack());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Xnnpack> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.Delegate.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Xnnpack() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Xnnpack(Xnnpack other) : this() {
              _hasBits0 = other._hasBits0;
              numThreads_ = other.numThreads_;
              enableZeroCopyTensorIo_ = other.enableZeroCopyTensorIo_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Xnnpack Clone() {
              return new Xnnpack(this);
            }

            /// <summary>Field number for the "num_threads" field.</summary>
            public const int NumThreadsFieldNumber = 1;
            private readonly static int NumThreadsDefaultValue = -1;

            private int numThreads_;
            /// <summary>
            /// Number of threads for XNNPACK delegate. (By default, calculator tries
            /// to choose optimal number of threads depending on the device.)
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int NumThreads {
              get { if ((_hasBits0 & 1) != 0) { return numThreads_; } else { return NumThreadsDefaultValue; } }
              set {
                _hasBits0 |= 1;
                numThreads_ = value;
              }
            }
            /// <summary>Gets whether the "num_threads" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasNumThreads {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "num_threads" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearNumThreads() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "enable_zero_copy_tensor_io" field.</summary>
            public const int EnableZeroCopyTensorIoFieldNumber = 7;
            private readonly static bool EnableZeroCopyTensorIoDefaultValue = false;

            private bool enableZeroCopyTensorIo_;
            /// <summary>
            /// Enables an experimental TfLite feature to directly access the MP input
            /// tensors (and this way avoids copying the data). Note that this requires
            /// *all* input tensors to be aligned to tflite::kDefaultTensorAlignment
            /// bytes and that the model has no duplicate output tensors (tensors with
            /// identical TfLite tensor indices) and no passthrough input->output
            /// tensors (input and output tensors with identical TfLite tensor
            /// indices).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool EnableZeroCopyTensorIo {
              get { if ((_hasBits0 & 2) != 0) { return enableZeroCopyTensorIo_; } else { return EnableZeroCopyTensorIoDefaultValue; } }
              set {
                _hasBits0 |= 2;
                enableZeroCopyTensorIo_ = value;
              }
            }
            /// <summary>Gets whether the "enable_zero_copy_tensor_io" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasEnableZeroCopyTensorIo {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "enable_zero_copy_tensor_io" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearEnableZeroCopyTensorIo() {
              _hasBits0 &= ~2;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Xnnpack);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Xnnpack other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (NumThreads != other.NumThreads) return false;
              if (EnableZeroCopyTensorIo != other.EnableZeroCopyTensorIo) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasNumThreads) hash ^= NumThreads.GetHashCode();
              if (HasEnableZeroCopyTensorIo) hash ^= EnableZeroCopyTensorIo.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasNumThreads) {
                output.WriteRawTag(8);
                output.WriteInt32(NumThreads);
              }
              if (HasEnableZeroCopyTensorIo) {
                output.WriteRawTag(56);
                output.WriteBool(EnableZeroCopyTensorIo);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasNumThreads) {
                output.WriteRawTag(8);
                output.WriteInt32(NumThreads);
              }
              if (HasEnableZeroCopyTensorIo) {
                output.WriteRawTag(56);
                output.WriteBool(EnableZeroCopyTensorIo);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasNumThreads) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumThreads);
              }
              if (HasEnableZeroCopyTensorIo) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Xnnpack other) {
              if (other == null) {
                return;
              }
              if (other.HasNumThreads) {
                NumThreads = other.NumThreads;
              }
              if (other.HasEnableZeroCopyTensorIo) {
                EnableZeroCopyTensorIo = other.EnableZeroCopyTensorIo;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    NumThreads = input.ReadInt32();
                    break;
                  }
                  case 56: {
                    EnableZeroCopyTensorIo = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    NumThreads = input.ReadInt32();
                    break;
                  }
                  case 56: {
                    EnableZeroCopyTensorIo = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// InputOutputConfig enables us to reorder the tensors in the input and output
      /// of the InferenceCalculator. This is useful when the order of the tensors in
      /// the input and output of the InferenceCalculator does not match the order of
      /// the tensors in the input and output of the underlying TFLite model. In this
      /// example, Tensor_1 and Tensor_2 are swapped.
      ///
      ///                 Inference Calculator Inputs
      ///    ┌─────▼─────────▼─────────▼────────▼──────────▼──────────┐
      ///    │  Tensor_0, Tensor_1, Tensor_2, Tensor_3, Tensor_4      │
      ///    └────────────────────────────────────────────────────────┘
      ///                      [input_tensor_map]
      ///    ┌────────────────────────────────────────────────────────┐
      ///    │  Tensor_0, Tensor_2, Tensor_1, Tensor_3, Tensor_4      │
      ///    └─────┬─────────┬─────────┬────────┬──────────┬──────────┘
      ///          │         │         │        │          │
      ///    ┌─────▼─────────▼─────────▼────────▼──────────▼──────────┐
      ///    │                       Inference                        │
      ///    └─────┬─────────┬─────────┬────────┬──────────┬──────────┘
      ///          │         │         │        │          │
      ///    ┌─────▼─────────▼─────────▼────────▼──────────▼──────────┐
      ///    │  Tensor_0, Tensor_2, Tensor_1, Tensor_3, Tensor_4      │
      ///    └────────────────────────────────────────────────────────┘
      ///                     [output_tensor_map]
      ///    ┌────────────────────────────────────────────────────────┐
      ///    │  Tensor_0, Tensor_1, Tensor_2, Tensor_3, Tensor_4      │
      ///    └──────┬─────────┬─────────┬────────┬──────────┬─────────┘
      ///           ▼         ▼         ▼        ▼          ▼
      ///                 Inference Calculator Outputs
      /// </summary>
      public sealed partial class InputOutputConfig : pb::IMessage<InputOutputConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InputOutputConfig> _parser = new pb::MessageParser<InputOutputConfig>(() => new InputOutputConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InputOutputConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.InferenceCalculatorOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputOutputConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputOutputConfig(InputOutputConfig other) : this() {
          feedbackTensorLinks_ = other.feedbackTensorLinks_.Clone();
          switch (other.InputTensorMapCase) {
            case InputTensorMapOneofCase.InputTensorIndicesMap:
              InputTensorIndicesMap = other.InputTensorIndicesMap.Clone();
              break;
            case InputTensorMapOneofCase.InputTensorNamesMap:
              InputTensorNamesMap = other.InputTensorNamesMap.Clone();
              break;
          }

          switch (other.OutputTensorMapCase) {
            case OutputTensorMapOneofCase.OutputTensorIndicesMap:
              OutputTensorIndicesMap = other.OutputTensorIndicesMap.Clone();
              break;
            case OutputTensorMapOneofCase.OutputTensorNamesMap:
              OutputTensorNamesMap = other.OutputTensorNamesMap.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputOutputConfig Clone() {
          return new InputOutputConfig(this);
        }

        /// <summary>Field number for the "input_tensor_indices_map" field.</summary>
        public const int InputTensorIndicesMapFieldNumber = 1;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap InputTensorIndicesMap {
          get { return inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap ? (global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap) inputTensorMap_ : null; }
          set {
            inputTensorMap_ = value;
            inputTensorMapCase_ = value == null ? InputTensorMapOneofCase.None : InputTensorMapOneofCase.InputTensorIndicesMap;
          }
        }

        /// <summary>Field number for the "input_tensor_names_map" field.</summary>
        public const int InputTensorNamesMapFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap InputTensorNamesMap {
          get { return inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap ? (global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap) inputTensorMap_ : null; }
          set {
            inputTensorMap_ = value;
            inputTensorMapCase_ = value == null ? InputTensorMapOneofCase.None : InputTensorMapOneofCase.InputTensorNamesMap;
          }
        }

        /// <summary>Field number for the "output_tensor_indices_map" field.</summary>
        public const int OutputTensorIndicesMapFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap OutputTensorIndicesMap {
          get { return outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap ? (global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap) outputTensorMap_ : null; }
          set {
            outputTensorMap_ = value;
            outputTensorMapCase_ = value == null ? OutputTensorMapOneofCase.None : OutputTensorMapOneofCase.OutputTensorIndicesMap;
          }
        }

        /// <summary>Field number for the "output_tensor_names_map" field.</summary>
        public const int OutputTensorNamesMapFieldNumber = 4;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap OutputTensorNamesMap {
          get { return outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap ? (global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap) outputTensorMap_ : null; }
          set {
            outputTensorMap_ = value;
            outputTensorMapCase_ = value == null ? OutputTensorMapOneofCase.None : OutputTensorMapOneofCase.OutputTensorNamesMap;
          }
        }

        /// <summary>Field number for the "feedback_tensor_links" field.</summary>
        public const int FeedbackTensorLinksFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink> _repeated_feedbackTensorLinks_codec
            = pb::FieldCodec.ForMessage(42, global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink.Parser);
        private readonly pbc::RepeatedField<global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink> feedbackTensorLinks_ = new pbc::RepeatedField<global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink>();
        /// <summary>
        /// Defines a mapping between output tensors that should be
        /// used as input tensors during the next inference invocation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.FeedbackTensorLink> FeedbackTensorLinks {
          get { return feedbackTensorLinks_; }
        }

        private object inputTensorMap_;
        /// <summary>Enum of possible cases for the "InputTensorMap" oneof.</summary>
        public enum InputTensorMapOneofCase {
          None = 0,
          InputTensorIndicesMap = 1,
          InputTensorNamesMap = 3,
        }
        private InputTensorMapOneofCase inputTensorMapCase_ = InputTensorMapOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputTensorMapOneofCase InputTensorMapCase {
          get { return inputTensorMapCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInputTensorMap() {
          inputTensorMapCase_ = InputTensorMapOneofCase.None;
          inputTensorMap_ = null;
        }

        private object outputTensorMap_;
        /// <summary>Enum of possible cases for the "OutputTensorMap" oneof.</summary>
        public enum OutputTensorMapOneofCase {
          None = 0,
          OutputTensorIndicesMap = 2,
          OutputTensorNamesMap = 4,
        }
        private OutputTensorMapOneofCase outputTensorMapCase_ = OutputTensorMapOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputTensorMapOneofCase OutputTensorMapCase {
          get { return outputTensorMapCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOutputTensorMap() {
          outputTensorMapCase_ = OutputTensorMapOneofCase.None;
          outputTensorMap_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InputOutputConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InputOutputConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(InputTensorIndicesMap, other.InputTensorIndicesMap)) return false;
          if (!object.Equals(InputTensorNamesMap, other.InputTensorNamesMap)) return false;
          if (!object.Equals(OutputTensorIndicesMap, other.OutputTensorIndicesMap)) return false;
          if (!object.Equals(OutputTensorNamesMap, other.OutputTensorNamesMap)) return false;
          if(!feedbackTensorLinks_.Equals(other.feedbackTensorLinks_)) return false;
          if (InputTensorMapCase != other.InputTensorMapCase) return false;
          if (OutputTensorMapCase != other.OutputTensorMapCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) hash ^= InputTensorIndicesMap.GetHashCode();
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) hash ^= InputTensorNamesMap.GetHashCode();
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) hash ^= OutputTensorIndicesMap.GetHashCode();
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) hash ^= OutputTensorNamesMap.GetHashCode();
          hash ^= feedbackTensorLinks_.GetHashCode();
          hash ^= (int) inputTensorMapCase_;
          hash ^= (int) outputTensorMapCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) {
            output.WriteRawTag(10);
            output.WriteMessage(InputTensorIndicesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) {
            output.WriteRawTag(18);
            output.WriteMessage(OutputTensorIndicesMap);
          }
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) {
            output.WriteRawTag(26);
            output.WriteMessage(InputTensorNamesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) {
            output.WriteRawTag(34);
            output.WriteMessage(OutputTensorNamesMap);
          }
          feedbackTensorLinks_.WriteTo(output, _repeated_feedbackTensorLinks_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) {
            output.WriteRawTag(10);
            output.WriteMessage(InputTensorIndicesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) {
            output.WriteRawTag(18);
            output.WriteMessage(OutputTensorIndicesMap);
          }
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) {
            output.WriteRawTag(26);
            output.WriteMessage(InputTensorNamesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) {
            output.WriteRawTag(34);
            output.WriteMessage(OutputTensorNamesMap);
          }
          feedbackTensorLinks_.WriteTo(ref output, _repeated_feedbackTensorLinks_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputTensorIndicesMap);
          }
          if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputTensorNamesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputTensorIndicesMap);
          }
          if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputTensorNamesMap);
          }
          size += feedbackTensorLinks_.CalculateSize(_repeated_feedbackTensorLinks_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InputOutputConfig other) {
          if (other == null) {
            return;
          }
          feedbackTensorLinks_.Add(other.feedbackTensorLinks_);
          switch (other.InputTensorMapCase) {
            case InputTensorMapOneofCase.InputTensorIndicesMap:
              if (InputTensorIndicesMap == null) {
                InputTensorIndicesMap = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
              }
              InputTensorIndicesMap.MergeFrom(other.InputTensorIndicesMap);
              break;
            case InputTensorMapOneofCase.InputTensorNamesMap:
              if (InputTensorNamesMap == null) {
                InputTensorNamesMap = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
              }
              InputTensorNamesMap.MergeFrom(other.InputTensorNamesMap);
              break;
          }

          switch (other.OutputTensorMapCase) {
            case OutputTensorMapOneofCase.OutputTensorIndicesMap:
              if (OutputTensorIndicesMap == null) {
                OutputTensorIndicesMap = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
              }
              OutputTensorIndicesMap.MergeFrom(other.OutputTensorIndicesMap);
              break;
            case OutputTensorMapOneofCase.OutputTensorNamesMap:
              if (OutputTensorNamesMap == null) {
                OutputTensorNamesMap = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
              }
              OutputTensorNamesMap.MergeFrom(other.OutputTensorNamesMap);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
                if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) {
                  subBuilder.MergeFrom(InputTensorIndicesMap);
                }
                input.ReadMessage(subBuilder);
                InputTensorIndicesMap = subBuilder;
                break;
              }
              case 18: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
                if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) {
                  subBuilder.MergeFrom(OutputTensorIndicesMap);
                }
                input.ReadMessage(subBuilder);
                OutputTensorIndicesMap = subBuilder;
                break;
              }
              case 26: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
                if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) {
                  subBuilder.MergeFrom(InputTensorNamesMap);
                }
                input.ReadMessage(subBuilder);
                InputTensorNamesMap = subBuilder;
                break;
              }
              case 34: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
                if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) {
                  subBuilder.MergeFrom(OutputTensorNamesMap);
                }
                input.ReadMessage(subBuilder);
                OutputTensorNamesMap = subBuilder;
                break;
              }
              case 42: {
                feedbackTensorLinks_.AddEntriesFrom(input, _repeated_feedbackTensorLinks_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
                if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorIndicesMap) {
                  subBuilder.MergeFrom(InputTensorIndicesMap);
                }
                input.ReadMessage(subBuilder);
                InputTensorIndicesMap = subBuilder;
                break;
              }
              case 18: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorIndicesMap();
                if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorIndicesMap) {
                  subBuilder.MergeFrom(OutputTensorIndicesMap);
                }
                input.ReadMessage(subBuilder);
                OutputTensorIndicesMap = subBuilder;
                break;
              }
              case 26: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
                if (inputTensorMapCase_ == InputTensorMapOneofCase.InputTensorNamesMap) {
                  subBuilder.MergeFrom(InputTensorNamesMap);
                }
                input.ReadMessage(subBuilder);
                InputTensorNamesMap = subBuilder;
                break;
              }
              case 34: {
                global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap subBuilder = new global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Types.TensorNamesMap();
                if (outputTensorMapCase_ == OutputTensorMapOneofCase.OutputTensorNamesMap) {
                  subBuilder.MergeFrom(OutputTensorNamesMap);
                }
                input.ReadMessage(subBuilder);
                OutputTensorNamesMap = subBuilder;
                break;
              }
              case 42: {
                feedbackTensorLinks_.AddEntriesFrom(ref input, _repeated_feedbackTensorLinks_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the InputOutputConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Defines tensor order described by the indices.
          /// </summary>
          public sealed partial class TensorIndicesMap : pb::IMessage<TensorIndicesMap>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<TensorIndicesMap> _parser = new pb::MessageParser<TensorIndicesMap>(() => new TensorIndicesMap());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<TensorIndicesMap> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorIndicesMap() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorIndicesMap(TensorIndicesMap other) : this() {
              modelTensorIndices_ = other.modelTensorIndices_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorIndicesMap Clone() {
              return new TensorIndicesMap(this);
            }

            /// <summary>Field number for the "model_tensor_indices" field.</summary>
            public const int ModelTensorIndicesFieldNumber = 1;
            private static readonly pb::FieldCodec<int> _repeated_modelTensorIndices_codec
                = pb::FieldCodec.ForInt32(10);
            private readonly pbc::RepeatedField<int> modelTensorIndices_ = new pbc::RepeatedField<int>();
            /// <summary>
            /// Ordered list of tensor indices describing a bijective mapping between
            /// the InferenceCalculator tensor index and the TFLite model I/O index.
            /// The nth entry in the list maps the nth InferenceCalculator tensor to
            /// *[nth] model I/O index. The size of the list must match the number of
            /// tensors in the input or output of the InferenceCalculator.
            ///
            /// Example configurations:
            /// Input (Input&lt;std::vector&lt;Tensor>> or Input&lt;Tensor>::Multiple) config:
            /// - Desired inference calculator input order: tensor0, tensor1, tensor2
            /// - Given model tensor input order: [Tensor2, Tensor1, Tensor0]
            /// - model_tensor_indices: [2, 1, 0]
            /// Output (Output&lt;std::vector&lt;Tensor>> or Output&lt;Tensor>::Multiple)
            /// config:
            /// - Given model tensor output order: [Tensor2, Tensor1, Tensor0]
            /// - Desired InferenceCalculator output order: tensor0, tensor1, tensor2
            /// - model_tensor_indices: [2, 1, 0]
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<int> ModelTensorIndices {
              get { return modelTensorIndices_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as TensorIndicesMap);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(TensorIndicesMap other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!modelTensorIndices_.Equals(other.modelTensorIndices_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= modelTensorIndices_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              modelTensorIndices_.WriteTo(output, _repeated_modelTensorIndices_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              modelTensorIndices_.WriteTo(ref output, _repeated_modelTensorIndices_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += modelTensorIndices_.CalculateSize(_repeated_modelTensorIndices_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(TensorIndicesMap other) {
              if (other == null) {
                return;
              }
              modelTensorIndices_.Add(other.modelTensorIndices_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10:
                  case 8: {
                    modelTensorIndices_.AddEntriesFrom(input, _repeated_modelTensorIndices_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10:
                  case 8: {
                    modelTensorIndices_.AddEntriesFrom(ref input, _repeated_modelTensorIndices_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Defines tensor order described by the TfLite signature names.
          /// </summary>
          public sealed partial class TensorNamesMap : pb::IMessage<TensorNamesMap>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<TensorNamesMap> _parser = new pb::MessageParser<TensorNamesMap>(() => new TensorNamesMap());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<TensorNamesMap> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorNamesMap() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorNamesMap(TensorNamesMap other) : this() {
              tensorNames_ = other.tensorNames_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TensorNamesMap Clone() {
              return new TensorNamesMap(this);
            }

            /// <summary>Field number for the "tensor_names" field.</summary>
            public const int TensorNamesFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_tensorNames_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> tensorNames_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Ordered list of tensor names describing a bijective mapping between
            /// the InferenceCalculator tensor I/O index and the TFLite model I/O
            /// tensor names (only models with a single signature are supported). The
            /// nth entry in the list maps the nth InferenceCalculator I/O tensor. The
            /// size of the list must match the number of tensors in the input or
            /// output of the InferenceCalculator.
            ///
            /// Example configurations:
            /// Input (Input&lt;std::vector&lt;Tensor>> or Input&lt;Tensor>::Multiple) config:
            /// - Desired inference calculator input order: tensor0, tensor1, tensor2
            /// - Given model tensor input order: [Tensor2, Tensor1, Tensor0]
            /// - tensor_names_map: ["Tensor0", "Tensor1", "Tensor2"]
            /// Output (Output&lt;std::vector&lt;Tensor>> or Output&lt;Tensor>::Multiple)
            /// config:
            /// - Given model tensor output order: [Tensor2, Tensor1, Tensor0]
            /// - Desired InferenceCalculator output order: tensor0, tensor1, tensor2
            /// - tensor_names_map: ["Tensor0", "Tensor1", "Tensor2"]
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> TensorNames {
              get { return tensorNames_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as TensorNamesMap);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(TensorNamesMap other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!tensorNames_.Equals(other.tensorNames_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= tensorNames_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              tensorNames_.WriteTo(output, _repeated_tensorNames_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              tensorNames_.WriteTo(ref output, _repeated_tensorNames_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += tensorNames_.CalculateSize(_repeated_tensorNames_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(TensorNamesMap other) {
              if (other == null) {
                return;
              }
              tensorNames_.Add(other.tensorNames_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    tensorNames_.AddEntriesFrom(input, _repeated_tensorNames_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    tensorNames_.AddEntriesFrom(ref input, _repeated_tensorNames_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Feedback tensor links are pairs of model input / output tensors where
          /// the output should be set as inputs in the next model invocation. This
          /// allows to manage a notion of temporal state by continuously feeding from
          /// the model's output to the model's input during each inference step.  Note
          /// that these feedback tensors must be excluded from the input/output
          /// tensor maps above as they are not used as regular inputs/outputs of the
          /// inference calculator.
          /// </summary>
          public sealed partial class FeedbackTensorLink : pb::IMessage<FeedbackTensorLink>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<FeedbackTensorLink> _parser = new pb::MessageParser<FeedbackTensorLink>(() => new FeedbackTensorLink());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<FeedbackTensorLink> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Mediapipe.InferenceCalculatorOptions.Types.InputOutputConfig.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeedbackTensorLink() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeedbackTensorLink(FeedbackTensorLink other) : this() {
              fromOutputTensorName_ = other.fromOutputTensorName_;
              toInputTensorName_ = other.toInputTensorName_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeedbackTensorLink Clone() {
              return new FeedbackTensorLink(this);
            }

            /// <summary>Field number for the "from_output_tensor_name" field.</summary>
            public const int FromOutputTensorNameFieldNumber = 1;
            private readonly static string FromOutputTensorNameDefaultValue = "";

            private string fromOutputTensorName_;
            /// <summary>
            /// TfLite output tensor name from default TfLite signature to use as
            /// source.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string FromOutputTensorName {
              get { return fromOutputTensorName_ ?? FromOutputTensorNameDefaultValue; }
              set {
                fromOutputTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "from_output_tensor_name" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasFromOutputTensorName {
              get { return fromOutputTensorName_ != null; }
            }
            /// <summary>Clears the value of the "from_output_tensor_name" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearFromOutputTensorName() {
              fromOutputTensorName_ = null;
            }

            /// <summary>Field number for the "to_input_tensor_name" field.</summary>
            public const int ToInputTensorNameFieldNumber = 2;
            private readonly static string ToInputTensorNameDefaultValue = "";

            private string toInputTensorName_;
            /// <summary>
            /// TfLite tensor name from default TfLitesignature to pass input
            /// tensor to.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string ToInputTensorName {
              get { return toInputTensorName_ ?? ToInputTensorNameDefaultValue; }
              set {
                toInputTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "to_input_tensor_name" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasToInputTensorName {
              get { return toInputTensorName_ != null; }
            }
            /// <summary>Clears the value of the "to_input_tensor_name" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearToInputTensorName() {
              toInputTensorName_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as FeedbackTensorLink);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(FeedbackTensorLink other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (FromOutputTensorName != other.FromOutputTensorName) return false;
              if (ToInputTensorName != other.ToInputTensorName) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasFromOutputTensorName) hash ^= FromOutputTensorName.GetHashCode();
              if (HasToInputTensorName) hash ^= ToInputTensorName.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasFromOutputTensorName) {
                output.WriteRawTag(10);
                output.WriteString(FromOutputTensorName);
              }
              if (HasToInputTensorName) {
                output.WriteRawTag(18);
                output.WriteString(ToInputTensorName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasFromOutputTensorName) {
                output.WriteRawTag(10);
                output.WriteString(FromOutputTensorName);
              }
              if (HasToInputTensorName) {
                output.WriteRawTag(18);
                output.WriteString(ToInputTensorName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasFromOutputTensorName) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(FromOutputTensorName);
              }
              if (HasToInputTensorName) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ToInputTensorName);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(FeedbackTensorLink other) {
              if (other == null) {
                return;
              }
              if (other.HasFromOutputTensorName) {
                FromOutputTensorName = other.FromOutputTensorName;
              }
              if (other.HasToInputTensorName) {
                ToInputTensorName = other.ToInputTensorName;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    FromOutputTensorName = input.ReadString();
                    break;
                  }
                  case 18: {
                    ToInputTensorName = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    FromOutputTensorName = input.ReadString();
                    break;
                  }
                  case 18: {
                    ToInputTensorName = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the InferenceCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.InferenceCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.InferenceCalculatorOptions>(336783863, pb::FieldCodec.ForMessage(2694270906, global::Mediapipe.InferenceCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

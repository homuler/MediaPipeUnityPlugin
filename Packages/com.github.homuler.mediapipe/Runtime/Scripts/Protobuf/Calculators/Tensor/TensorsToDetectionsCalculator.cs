// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/tensor/tensors_to_detections_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/tensor/tensors_to_detections_calculator.proto</summary>
  public static partial class TensorsToDetectionsCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/tensor/tensors_to_detections_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TensorsToDetectionsCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkNtZWRpYXBpcGUvY2FsY3VsYXRvcnMvdGVuc29yL3RlbnNvcnNfdG9fZGV0",
            "ZWN0aW9uc19jYWxjdWxhdG9yLnByb3RvEgltZWRpYXBpcGUaJG1lZGlhcGlw",
            "ZS9mcmFtZXdvcmsvY2FsY3VsYXRvci5wcm90byK7CgokVGVuc29yc1RvRGV0",
            "ZWN0aW9uc0NhbGN1bGF0b3JPcHRpb25zEhMKC251bV9jbGFzc2VzGAEgASgF",
            "EhEKCW51bV9ib3hlcxgCIAEoBRISCgpudW1fY29vcmRzGAMgASgFEh0KFWtl",
            "eXBvaW50X2Nvb3JkX29mZnNldBgJIAEoBRIYCg1udW1fa2V5cG9pbnRzGAog",
            "ASgFOgEwEiIKF251bV92YWx1ZXNfcGVyX2tleXBvaW50GAsgASgFOgEyEhsK",
            "EGJveF9jb29yZF9vZmZzZXQYDCABKAU6ATASEgoHeF9zY2FsZRgEIAEoAjoB",
            "MBISCgd5X3NjYWxlGAUgASgCOgEwEhIKB3dfc2NhbGUYBiABKAI6ATASEgoH",
            "aF9zY2FsZRgHIAEoAjoBMBIsCh1hcHBseV9leHBvbmVudGlhbF9vbl9ib3hf",
            "c2l6ZRgNIAEoCDoFZmFsc2USIwoUcmV2ZXJzZV9vdXRwdXRfb3JkZXIYDiAB",
            "KAg6BWZhbHNlEhYKDmlnbm9yZV9jbGFzc2VzGAggAygFEhkKDWFsbG93X2Ns",
            "YXNzZXMYFSADKAVCAhABEhwKDXNpZ21vaWRfc2NvcmUYDyABKAg6BWZhbHNl",
            "Eh0KFXNjb3JlX2NsaXBwaW5nX3RocmVzaBgQIAEoAhIeCg9mbGlwX3ZlcnRp",
            "Y2FsbHkYEiABKAg6BWZhbHNlEhgKEG1pbl9zY29yZV90aHJlc2gYEyABKAIS",
            "FwoLbWF4X3Jlc3VsdHMYFCABKAU6Ai0xEiQKGW1heF9jbGFzc2VzX3Blcl9k",
            "ZXRlY3Rpb24YGSABKAU6ATESVQoOdGVuc29yX21hcHBpbmcYFiABKAsyPS5t",
            "ZWRpYXBpcGUuVGVuc29yc1RvRGV0ZWN0aW9uc0NhbGN1bGF0b3JPcHRpb25z",
            "LlRlbnNvck1hcHBpbmcSZgoWYm94X2JvdW5kYXJpZXNfaW5kaWNlcxgXIAEo",
            "CzJELm1lZGlhcGlwZS5UZW5zb3JzVG9EZXRlY3Rpb25zQ2FsY3VsYXRvck9w",
            "dGlvbnMuQm94Qm91bmRhcmllc0luZGljZXNIABJaCgpib3hfZm9ybWF0GBgg",
            "ASgOMjkubWVkaWFwaXBlLlRlbnNvcnNUb0RldGVjdGlvbnNDYWxjdWxhdG9y",
            "T3B0aW9ucy5Cb3hGb3JtYXQ6C1VOU1BFQ0lGSUVEGq4BCg1UZW5zb3JNYXBw",
            "aW5nEh8KF2RldGVjdGlvbnNfdGVuc29yX2luZGV4GAEgASgFEhwKFGNsYXNz",
            "ZXNfdGVuc29yX2luZGV4GAIgASgFEhsKE3Njb3Jlc190ZW5zb3JfaW5kZXgY",
            "AyABKAUSIwobbnVtX2RldGVjdGlvbnNfdGVuc29yX2luZGV4GAQgASgFEhwK",
            "FGFuY2hvcnNfdGVuc29yX2luZGV4GAUgASgFGloKFEJveEJvdW5kYXJpZXNJ",
            "bmRpY2VzEg8KBHltaW4YASABKAU6ATASDwoEeG1pbhgCIAEoBToBMRIPCgR5",
            "bWF4GAMgASgFOgEyEg8KBHhtYXgYBCABKAU6ATMiOgoJQm94Rm9ybWF0Eg8K",
            "C1VOU1BFQ0lGSUVEEAASCAoEWVhIVxABEggKBFhZV0gQAhIICgRYWVhZEAMy",
            "XgoDZXh0EhwubWVkaWFwaXBlLkNhbGN1bGF0b3JPcHRpb25zGK+NjKABIAEo",
            "CzIvLm1lZGlhcGlwZS5UZW5zb3JzVG9EZXRlY3Rpb25zQ2FsY3VsYXRvck9w",
            "dGlvbnNCDQoLYm94X2luZGljZXM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TensorsToDetectionsCalculatorOptions), global::Mediapipe.TensorsToDetectionsCalculatorOptions.Parser, new[]{ "NumClasses", "NumBoxes", "NumCoords", "KeypointCoordOffset", "NumKeypoints", "NumValuesPerKeypoint", "BoxCoordOffset", "XScale", "YScale", "WScale", "HScale", "ApplyExponentialOnBoxSize", "ReverseOutputOrder", "IgnoreClasses", "AllowClasses", "SigmoidScore", "ScoreClippingThresh", "FlipVertically", "MinScoreThresh", "MaxResults", "MaxClassesPerDetection", "TensorMapping", "BoxBoundariesIndices", "BoxFormat" }, new[]{ "BoxIndices" }, new[]{ typeof(global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat) }, new pb::Extension[] { global::Mediapipe.TensorsToDetectionsCalculatorOptions.Extensions.Ext }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping), global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping.Parser, new[]{ "DetectionsTensorIndex", "ClassesTensorIndex", "ScoresTensorIndex", "NumDetectionsTensorIndex", "AnchorsTensorIndex" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices), global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices.Parser, new[]{ "Ymin", "Xmin", "Ymax", "Xmax" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class TensorsToDetectionsCalculatorOptions : pb::IMessage<TensorsToDetectionsCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TensorsToDetectionsCalculatorOptions> _parser = new pb::MessageParser<TensorsToDetectionsCalculatorOptions>(() => new TensorsToDetectionsCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TensorsToDetectionsCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.TensorsToDetectionsCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TensorsToDetectionsCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TensorsToDetectionsCalculatorOptions(TensorsToDetectionsCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      numClasses_ = other.numClasses_;
      numBoxes_ = other.numBoxes_;
      numCoords_ = other.numCoords_;
      keypointCoordOffset_ = other.keypointCoordOffset_;
      numKeypoints_ = other.numKeypoints_;
      numValuesPerKeypoint_ = other.numValuesPerKeypoint_;
      boxCoordOffset_ = other.boxCoordOffset_;
      xScale_ = other.xScale_;
      yScale_ = other.yScale_;
      wScale_ = other.wScale_;
      hScale_ = other.hScale_;
      applyExponentialOnBoxSize_ = other.applyExponentialOnBoxSize_;
      reverseOutputOrder_ = other.reverseOutputOrder_;
      ignoreClasses_ = other.ignoreClasses_.Clone();
      allowClasses_ = other.allowClasses_.Clone();
      sigmoidScore_ = other.sigmoidScore_;
      scoreClippingThresh_ = other.scoreClippingThresh_;
      flipVertically_ = other.flipVertically_;
      minScoreThresh_ = other.minScoreThresh_;
      maxResults_ = other.maxResults_;
      maxClassesPerDetection_ = other.maxClassesPerDetection_;
      tensorMapping_ = other.tensorMapping_ != null ? other.tensorMapping_.Clone() : null;
      boxFormat_ = other.boxFormat_;
      switch (other.BoxIndicesCase) {
        case BoxIndicesOneofCase.BoxBoundariesIndices:
          BoxBoundariesIndices = other.BoxBoundariesIndices.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TensorsToDetectionsCalculatorOptions Clone() {
      return new TensorsToDetectionsCalculatorOptions(this);
    }

    /// <summary>Field number for the "num_classes" field.</summary>
    public const int NumClassesFieldNumber = 1;
    private readonly static int NumClassesDefaultValue = 0;

    private int numClasses_;
    /// <summary>
    /// [Required] The number of output classes predicted by the detection model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumClasses {
      get { if ((_hasBits0 & 1) != 0) { return numClasses_; } else { return NumClassesDefaultValue; } }
      set {
        _hasBits0 |= 1;
        numClasses_ = value;
      }
    }
    /// <summary>Gets whether the "num_classes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumClasses {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "num_classes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumClasses() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "num_boxes" field.</summary>
    public const int NumBoxesFieldNumber = 2;
    private readonly static int NumBoxesDefaultValue = 0;

    private int numBoxes_;
    /// <summary>
    /// [Required] The number of output boxes predicted by the detection model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumBoxes {
      get { if ((_hasBits0 & 2) != 0) { return numBoxes_; } else { return NumBoxesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        numBoxes_ = value;
      }
    }
    /// <summary>Gets whether the "num_boxes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumBoxes {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "num_boxes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumBoxes() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "num_coords" field.</summary>
    public const int NumCoordsFieldNumber = 3;
    private readonly static int NumCoordsDefaultValue = 0;

    private int numCoords_;
    /// <summary>
    /// [Required] The number of output values per boxes predicted by the detection
    /// model. The values contain bounding boxes, keypoints, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumCoords {
      get { if ((_hasBits0 & 4) != 0) { return numCoords_; } else { return NumCoordsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        numCoords_ = value;
      }
    }
    /// <summary>Gets whether the "num_coords" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumCoords {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "num_coords" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumCoords() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "keypoint_coord_offset" field.</summary>
    public const int KeypointCoordOffsetFieldNumber = 9;
    private readonly static int KeypointCoordOffsetDefaultValue = 0;

    private int keypointCoordOffset_;
    /// <summary>
    /// The offset of keypoint coordinates in the location tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int KeypointCoordOffset {
      get { if ((_hasBits0 & 128) != 0) { return keypointCoordOffset_; } else { return KeypointCoordOffsetDefaultValue; } }
      set {
        _hasBits0 |= 128;
        keypointCoordOffset_ = value;
      }
    }
    /// <summary>Gets whether the "keypoint_coord_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeypointCoordOffset {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "keypoint_coord_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeypointCoordOffset() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "num_keypoints" field.</summary>
    public const int NumKeypointsFieldNumber = 10;
    private readonly static int NumKeypointsDefaultValue = 0;

    private int numKeypoints_;
    /// <summary>
    /// The number of predicted keypoints.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumKeypoints {
      get { if ((_hasBits0 & 256) != 0) { return numKeypoints_; } else { return NumKeypointsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        numKeypoints_ = value;
      }
    }
    /// <summary>Gets whether the "num_keypoints" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumKeypoints {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "num_keypoints" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumKeypoints() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "num_values_per_keypoint" field.</summary>
    public const int NumValuesPerKeypointFieldNumber = 11;
    private readonly static int NumValuesPerKeypointDefaultValue = 2;

    private int numValuesPerKeypoint_;
    /// <summary>
    /// The dimension of each keypoint, e.g. number of values predicted for each
    /// keypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumValuesPerKeypoint {
      get { if ((_hasBits0 & 512) != 0) { return numValuesPerKeypoint_; } else { return NumValuesPerKeypointDefaultValue; } }
      set {
        _hasBits0 |= 512;
        numValuesPerKeypoint_ = value;
      }
    }
    /// <summary>Gets whether the "num_values_per_keypoint" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumValuesPerKeypoint {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "num_values_per_keypoint" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumValuesPerKeypoint() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "box_coord_offset" field.</summary>
    public const int BoxCoordOffsetFieldNumber = 12;
    private readonly static int BoxCoordOffsetDefaultValue = 0;

    private int boxCoordOffset_;
    /// <summary>
    /// The offset of box coordinates in the location tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int BoxCoordOffset {
      get { if ((_hasBits0 & 1024) != 0) { return boxCoordOffset_; } else { return BoxCoordOffsetDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        boxCoordOffset_ = value;
      }
    }
    /// <summary>Gets whether the "box_coord_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoxCoordOffset {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "box_coord_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoxCoordOffset() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "x_scale" field.</summary>
    public const int XScaleFieldNumber = 4;
    private readonly static float XScaleDefaultValue = 0F;

    private float xScale_;
    /// <summary>
    /// Parameters for decoding SSD detection model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float XScale {
      get { if ((_hasBits0 & 8) != 0) { return xScale_; } else { return XScaleDefaultValue; } }
      set {
        _hasBits0 |= 8;
        xScale_ = value;
      }
    }
    /// <summary>Gets whether the "x_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasXScale {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "x_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearXScale() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "y_scale" field.</summary>
    public const int YScaleFieldNumber = 5;
    private readonly static float YScaleDefaultValue = 0F;

    private float yScale_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float YScale {
      get { if ((_hasBits0 & 16) != 0) { return yScale_; } else { return YScaleDefaultValue; } }
      set {
        _hasBits0 |= 16;
        yScale_ = value;
      }
    }
    /// <summary>Gets whether the "y_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasYScale {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "y_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearYScale() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "w_scale" field.</summary>
    public const int WScaleFieldNumber = 6;
    private readonly static float WScaleDefaultValue = 0F;

    private float wScale_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float WScale {
      get { if ((_hasBits0 & 32) != 0) { return wScale_; } else { return WScaleDefaultValue; } }
      set {
        _hasBits0 |= 32;
        wScale_ = value;
      }
    }
    /// <summary>Gets whether the "w_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWScale {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "w_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWScale() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "h_scale" field.</summary>
    public const int HScaleFieldNumber = 7;
    private readonly static float HScaleDefaultValue = 0F;

    private float hScale_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float HScale {
      get { if ((_hasBits0 & 64) != 0) { return hScale_; } else { return HScaleDefaultValue; } }
      set {
        _hasBits0 |= 64;
        hScale_ = value;
      }
    }
    /// <summary>Gets whether the "h_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHScale {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "h_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHScale() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "apply_exponential_on_box_size" field.</summary>
    public const int ApplyExponentialOnBoxSizeFieldNumber = 13;
    private readonly static bool ApplyExponentialOnBoxSizeDefaultValue = false;

    private bool applyExponentialOnBoxSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ApplyExponentialOnBoxSize {
      get { if ((_hasBits0 & 2048) != 0) { return applyExponentialOnBoxSize_; } else { return ApplyExponentialOnBoxSizeDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        applyExponentialOnBoxSize_ = value;
      }
    }
    /// <summary>Gets whether the "apply_exponential_on_box_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasApplyExponentialOnBoxSize {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "apply_exponential_on_box_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearApplyExponentialOnBoxSize() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "reverse_output_order" field.</summary>
    public const int ReverseOutputOrderFieldNumber = 14;
    private readonly static bool ReverseOutputOrderDefaultValue = false;

    private bool reverseOutputOrder_;
    /// <summary>
    /// Whether to reverse the order of predicted x, y from output.
    /// If false, the order is [y_center, x_center, h, w], if true the order is
    /// [x_center, y_center, w, h].
    /// DEPRECATED. Use `box_format` instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReverseOutputOrder {
      get { if ((_hasBits0 & 4096) != 0) { return reverseOutputOrder_; } else { return ReverseOutputOrderDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        reverseOutputOrder_ = value;
      }
    }
    /// <summary>Gets whether the "reverse_output_order" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReverseOutputOrder {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "reverse_output_order" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReverseOutputOrder() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "ignore_classes" field.</summary>
    public const int IgnoreClassesFieldNumber = 8;
    private static readonly pb::FieldCodec<int> _repeated_ignoreClasses_codec
        = pb::FieldCodec.ForInt32(64);
    private readonly pbc::RepeatedField<int> ignoreClasses_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// The ids of classes that should be ignored during decoding the score for
    /// each predicted box. Can be overridden with IGNORE_CLASSES side packet.
    /// `ignore_classes` and `allow_classes` are mutually exclusive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> IgnoreClasses {
      get { return ignoreClasses_; }
    }

    /// <summary>Field number for the "allow_classes" field.</summary>
    public const int AllowClassesFieldNumber = 21;
    private static readonly pb::FieldCodec<int> _repeated_allowClasses_codec
        = pb::FieldCodec.ForInt32(170);
    private readonly pbc::RepeatedField<int> allowClasses_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// The ids of classes that should be allowed during decoding the score for
    /// each predicted box. `ignore_classes` and `allow_classes` are mutually
    /// exclusive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> AllowClasses {
      get { return allowClasses_; }
    }

    /// <summary>Field number for the "sigmoid_score" field.</summary>
    public const int SigmoidScoreFieldNumber = 15;
    private readonly static bool SigmoidScoreDefaultValue = false;

    private bool sigmoidScore_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SigmoidScore {
      get { if ((_hasBits0 & 8192) != 0) { return sigmoidScore_; } else { return SigmoidScoreDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        sigmoidScore_ = value;
      }
    }
    /// <summary>Gets whether the "sigmoid_score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSigmoidScore {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "sigmoid_score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSigmoidScore() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "score_clipping_thresh" field.</summary>
    public const int ScoreClippingThreshFieldNumber = 16;
    private readonly static float ScoreClippingThreshDefaultValue = 0F;

    private float scoreClippingThresh_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ScoreClippingThresh {
      get { if ((_hasBits0 & 16384) != 0) { return scoreClippingThresh_; } else { return ScoreClippingThreshDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        scoreClippingThresh_ = value;
      }
    }
    /// <summary>Gets whether the "score_clipping_thresh" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScoreClippingThresh {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "score_clipping_thresh" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScoreClippingThresh() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "flip_vertically" field.</summary>
    public const int FlipVerticallyFieldNumber = 18;
    private readonly static bool FlipVerticallyDefaultValue = false;

    private bool flipVertically_;
    /// <summary>
    /// Whether the detection coordinates from the input tensors should be flipped
    /// vertically (along the y-direction). This is useful, for example, when the
    /// input tensors represent detections defined with a coordinate system where
    /// the origin is at the top-left corner, whereas the desired detection
    /// representation has a bottom-left origin (e.g., in OpenGL).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FlipVertically {
      get { if ((_hasBits0 & 32768) != 0) { return flipVertically_; } else { return FlipVerticallyDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        flipVertically_ = value;
      }
    }
    /// <summary>Gets whether the "flip_vertically" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFlipVertically {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "flip_vertically" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFlipVertically() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "min_score_thresh" field.</summary>
    public const int MinScoreThreshFieldNumber = 19;
    private readonly static float MinScoreThreshDefaultValue = 0F;

    private float minScoreThresh_;
    /// <summary>
    /// Score threshold for preserving decoded detections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinScoreThresh {
      get { if ((_hasBits0 & 65536) != 0) { return minScoreThresh_; } else { return MinScoreThreshDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        minScoreThresh_ = value;
      }
    }
    /// <summary>Gets whether the "min_score_thresh" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinScoreThresh {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "min_score_thresh" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinScoreThresh() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "max_results" field.</summary>
    public const int MaxResultsFieldNumber = 20;
    private readonly static int MaxResultsDefaultValue = -1;

    private int maxResults_;
    /// <summary>
    /// The maximum number of the detection results to return. If &lt; 0, all
    /// available results will be returned.
    /// For the detection models that have built-in non max suppression op, the
    /// output detections are the top-scored results. Otherwise, the output
    /// detections are the first N results that have higher scores than
    /// `min_score_thresh`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxResults {
      get { if ((_hasBits0 & 131072) != 0) { return maxResults_; } else { return MaxResultsDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        maxResults_ = value;
      }
    }
    /// <summary>Gets whether the "max_results" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxResults {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "max_results" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxResults() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "max_classes_per_detection" field.</summary>
    public const int MaxClassesPerDetectionFieldNumber = 25;
    private readonly static int MaxClassesPerDetectionDefaultValue = 1;

    private int maxClassesPerDetection_;
    /// <summary>
    /// The maximum number of classes per detection.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxClassesPerDetection {
      get { if ((_hasBits0 & 524288) != 0) { return maxClassesPerDetection_; } else { return MaxClassesPerDetectionDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        maxClassesPerDetection_ = value;
      }
    }
    /// <summary>Gets whether the "max_classes_per_detection" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxClassesPerDetection {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "max_classes_per_detection" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxClassesPerDetection() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "tensor_mapping" field.</summary>
    public const int TensorMappingFieldNumber = 22;
    private global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping tensorMapping_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping TensorMapping {
      get { return tensorMapping_; }
      set {
        tensorMapping_ = value;
      }
    }

    /// <summary>Field number for the "box_boundaries_indices" field.</summary>
    public const int BoxBoundariesIndicesFieldNumber = 23;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices BoxBoundariesIndices {
      get { return boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices ? (global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices) boxIndices_ : null; }
      set {
        boxIndices_ = value;
        boxIndicesCase_ = value == null ? BoxIndicesOneofCase.None : BoxIndicesOneofCase.BoxBoundariesIndices;
      }
    }

    /// <summary>Field number for the "box_format" field.</summary>
    public const int BoxFormatFieldNumber = 24;
    private readonly static global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat BoxFormatDefaultValue = global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat.Unspecified;

    private global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat boxFormat_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat BoxFormat {
      get { if ((_hasBits0 & 262144) != 0) { return boxFormat_; } else { return BoxFormatDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        boxFormat_ = value;
      }
    }
    /// <summary>Gets whether the "box_format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoxFormat {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "box_format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoxFormat() {
      _hasBits0 &= ~262144;
    }

    private object boxIndices_;
    /// <summary>Enum of possible cases for the "box_indices" oneof.</summary>
    public enum BoxIndicesOneofCase {
      None = 0,
      BoxBoundariesIndices = 23,
    }
    private BoxIndicesOneofCase boxIndicesCase_ = BoxIndicesOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BoxIndicesOneofCase BoxIndicesCase {
      get { return boxIndicesCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoxIndices() {
      boxIndicesCase_ = BoxIndicesOneofCase.None;
      boxIndices_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TensorsToDetectionsCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TensorsToDetectionsCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NumClasses != other.NumClasses) return false;
      if (NumBoxes != other.NumBoxes) return false;
      if (NumCoords != other.NumCoords) return false;
      if (KeypointCoordOffset != other.KeypointCoordOffset) return false;
      if (NumKeypoints != other.NumKeypoints) return false;
      if (NumValuesPerKeypoint != other.NumValuesPerKeypoint) return false;
      if (BoxCoordOffset != other.BoxCoordOffset) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(XScale, other.XScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(YScale, other.YScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(WScale, other.WScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HScale, other.HScale)) return false;
      if (ApplyExponentialOnBoxSize != other.ApplyExponentialOnBoxSize) return false;
      if (ReverseOutputOrder != other.ReverseOutputOrder) return false;
      if(!ignoreClasses_.Equals(other.ignoreClasses_)) return false;
      if(!allowClasses_.Equals(other.allowClasses_)) return false;
      if (SigmoidScore != other.SigmoidScore) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ScoreClippingThresh, other.ScoreClippingThresh)) return false;
      if (FlipVertically != other.FlipVertically) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinScoreThresh, other.MinScoreThresh)) return false;
      if (MaxResults != other.MaxResults) return false;
      if (MaxClassesPerDetection != other.MaxClassesPerDetection) return false;
      if (!object.Equals(TensorMapping, other.TensorMapping)) return false;
      if (!object.Equals(BoxBoundariesIndices, other.BoxBoundariesIndices)) return false;
      if (BoxFormat != other.BoxFormat) return false;
      if (BoxIndicesCase != other.BoxIndicesCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNumClasses) hash ^= NumClasses.GetHashCode();
      if (HasNumBoxes) hash ^= NumBoxes.GetHashCode();
      if (HasNumCoords) hash ^= NumCoords.GetHashCode();
      if (HasKeypointCoordOffset) hash ^= KeypointCoordOffset.GetHashCode();
      if (HasNumKeypoints) hash ^= NumKeypoints.GetHashCode();
      if (HasNumValuesPerKeypoint) hash ^= NumValuesPerKeypoint.GetHashCode();
      if (HasBoxCoordOffset) hash ^= BoxCoordOffset.GetHashCode();
      if (HasXScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(XScale);
      if (HasYScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(YScale);
      if (HasWScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(WScale);
      if (HasHScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HScale);
      if (HasApplyExponentialOnBoxSize) hash ^= ApplyExponentialOnBoxSize.GetHashCode();
      if (HasReverseOutputOrder) hash ^= ReverseOutputOrder.GetHashCode();
      hash ^= ignoreClasses_.GetHashCode();
      hash ^= allowClasses_.GetHashCode();
      if (HasSigmoidScore) hash ^= SigmoidScore.GetHashCode();
      if (HasScoreClippingThresh) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ScoreClippingThresh);
      if (HasFlipVertically) hash ^= FlipVertically.GetHashCode();
      if (HasMinScoreThresh) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinScoreThresh);
      if (HasMaxResults) hash ^= MaxResults.GetHashCode();
      if (HasMaxClassesPerDetection) hash ^= MaxClassesPerDetection.GetHashCode();
      if (tensorMapping_ != null) hash ^= TensorMapping.GetHashCode();
      if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) hash ^= BoxBoundariesIndices.GetHashCode();
      if (HasBoxFormat) hash ^= BoxFormat.GetHashCode();
      hash ^= (int) boxIndicesCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNumClasses) {
        output.WriteRawTag(8);
        output.WriteInt32(NumClasses);
      }
      if (HasNumBoxes) {
        output.WriteRawTag(16);
        output.WriteInt32(NumBoxes);
      }
      if (HasNumCoords) {
        output.WriteRawTag(24);
        output.WriteInt32(NumCoords);
      }
      if (HasXScale) {
        output.WriteRawTag(37);
        output.WriteFloat(XScale);
      }
      if (HasYScale) {
        output.WriteRawTag(45);
        output.WriteFloat(YScale);
      }
      if (HasWScale) {
        output.WriteRawTag(53);
        output.WriteFloat(WScale);
      }
      if (HasHScale) {
        output.WriteRawTag(61);
        output.WriteFloat(HScale);
      }
      ignoreClasses_.WriteTo(output, _repeated_ignoreClasses_codec);
      if (HasKeypointCoordOffset) {
        output.WriteRawTag(72);
        output.WriteInt32(KeypointCoordOffset);
      }
      if (HasNumKeypoints) {
        output.WriteRawTag(80);
        output.WriteInt32(NumKeypoints);
      }
      if (HasNumValuesPerKeypoint) {
        output.WriteRawTag(88);
        output.WriteInt32(NumValuesPerKeypoint);
      }
      if (HasBoxCoordOffset) {
        output.WriteRawTag(96);
        output.WriteInt32(BoxCoordOffset);
      }
      if (HasApplyExponentialOnBoxSize) {
        output.WriteRawTag(104);
        output.WriteBool(ApplyExponentialOnBoxSize);
      }
      if (HasReverseOutputOrder) {
        output.WriteRawTag(112);
        output.WriteBool(ReverseOutputOrder);
      }
      if (HasSigmoidScore) {
        output.WriteRawTag(120);
        output.WriteBool(SigmoidScore);
      }
      if (HasScoreClippingThresh) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ScoreClippingThresh);
      }
      if (HasFlipVertically) {
        output.WriteRawTag(144, 1);
        output.WriteBool(FlipVertically);
      }
      if (HasMinScoreThresh) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(MinScoreThresh);
      }
      if (HasMaxResults) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(MaxResults);
      }
      allowClasses_.WriteTo(output, _repeated_allowClasses_codec);
      if (tensorMapping_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(TensorMapping);
      }
      if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(BoxBoundariesIndices);
      }
      if (HasBoxFormat) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) BoxFormat);
      }
      if (HasMaxClassesPerDetection) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(MaxClassesPerDetection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNumClasses) {
        output.WriteRawTag(8);
        output.WriteInt32(NumClasses);
      }
      if (HasNumBoxes) {
        output.WriteRawTag(16);
        output.WriteInt32(NumBoxes);
      }
      if (HasNumCoords) {
        output.WriteRawTag(24);
        output.WriteInt32(NumCoords);
      }
      if (HasXScale) {
        output.WriteRawTag(37);
        output.WriteFloat(XScale);
      }
      if (HasYScale) {
        output.WriteRawTag(45);
        output.WriteFloat(YScale);
      }
      if (HasWScale) {
        output.WriteRawTag(53);
        output.WriteFloat(WScale);
      }
      if (HasHScale) {
        output.WriteRawTag(61);
        output.WriteFloat(HScale);
      }
      ignoreClasses_.WriteTo(ref output, _repeated_ignoreClasses_codec);
      if (HasKeypointCoordOffset) {
        output.WriteRawTag(72);
        output.WriteInt32(KeypointCoordOffset);
      }
      if (HasNumKeypoints) {
        output.WriteRawTag(80);
        output.WriteInt32(NumKeypoints);
      }
      if (HasNumValuesPerKeypoint) {
        output.WriteRawTag(88);
        output.WriteInt32(NumValuesPerKeypoint);
      }
      if (HasBoxCoordOffset) {
        output.WriteRawTag(96);
        output.WriteInt32(BoxCoordOffset);
      }
      if (HasApplyExponentialOnBoxSize) {
        output.WriteRawTag(104);
        output.WriteBool(ApplyExponentialOnBoxSize);
      }
      if (HasReverseOutputOrder) {
        output.WriteRawTag(112);
        output.WriteBool(ReverseOutputOrder);
      }
      if (HasSigmoidScore) {
        output.WriteRawTag(120);
        output.WriteBool(SigmoidScore);
      }
      if (HasScoreClippingThresh) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(ScoreClippingThresh);
      }
      if (HasFlipVertically) {
        output.WriteRawTag(144, 1);
        output.WriteBool(FlipVertically);
      }
      if (HasMinScoreThresh) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(MinScoreThresh);
      }
      if (HasMaxResults) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(MaxResults);
      }
      allowClasses_.WriteTo(ref output, _repeated_allowClasses_codec);
      if (tensorMapping_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(TensorMapping);
      }
      if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(BoxBoundariesIndices);
      }
      if (HasBoxFormat) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) BoxFormat);
      }
      if (HasMaxClassesPerDetection) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(MaxClassesPerDetection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNumClasses) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumClasses);
      }
      if (HasNumBoxes) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumBoxes);
      }
      if (HasNumCoords) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumCoords);
      }
      if (HasKeypointCoordOffset) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(KeypointCoordOffset);
      }
      if (HasNumKeypoints) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumKeypoints);
      }
      if (HasNumValuesPerKeypoint) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumValuesPerKeypoint);
      }
      if (HasBoxCoordOffset) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxCoordOffset);
      }
      if (HasXScale) {
        size += 1 + 4;
      }
      if (HasYScale) {
        size += 1 + 4;
      }
      if (HasWScale) {
        size += 1 + 4;
      }
      if (HasHScale) {
        size += 1 + 4;
      }
      if (HasApplyExponentialOnBoxSize) {
        size += 1 + 1;
      }
      if (HasReverseOutputOrder) {
        size += 1 + 1;
      }
      size += ignoreClasses_.CalculateSize(_repeated_ignoreClasses_codec);
      size += allowClasses_.CalculateSize(_repeated_allowClasses_codec);
      if (HasSigmoidScore) {
        size += 1 + 1;
      }
      if (HasScoreClippingThresh) {
        size += 2 + 4;
      }
      if (HasFlipVertically) {
        size += 2 + 1;
      }
      if (HasMinScoreThresh) {
        size += 2 + 4;
      }
      if (HasMaxResults) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxResults);
      }
      if (HasMaxClassesPerDetection) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxClassesPerDetection);
      }
      if (tensorMapping_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TensorMapping);
      }
      if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BoxBoundariesIndices);
      }
      if (HasBoxFormat) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) BoxFormat);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TensorsToDetectionsCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasNumClasses) {
        NumClasses = other.NumClasses;
      }
      if (other.HasNumBoxes) {
        NumBoxes = other.NumBoxes;
      }
      if (other.HasNumCoords) {
        NumCoords = other.NumCoords;
      }
      if (other.HasKeypointCoordOffset) {
        KeypointCoordOffset = other.KeypointCoordOffset;
      }
      if (other.HasNumKeypoints) {
        NumKeypoints = other.NumKeypoints;
      }
      if (other.HasNumValuesPerKeypoint) {
        NumValuesPerKeypoint = other.NumValuesPerKeypoint;
      }
      if (other.HasBoxCoordOffset) {
        BoxCoordOffset = other.BoxCoordOffset;
      }
      if (other.HasXScale) {
        XScale = other.XScale;
      }
      if (other.HasYScale) {
        YScale = other.YScale;
      }
      if (other.HasWScale) {
        WScale = other.WScale;
      }
      if (other.HasHScale) {
        HScale = other.HScale;
      }
      if (other.HasApplyExponentialOnBoxSize) {
        ApplyExponentialOnBoxSize = other.ApplyExponentialOnBoxSize;
      }
      if (other.HasReverseOutputOrder) {
        ReverseOutputOrder = other.ReverseOutputOrder;
      }
      ignoreClasses_.Add(other.ignoreClasses_);
      allowClasses_.Add(other.allowClasses_);
      if (other.HasSigmoidScore) {
        SigmoidScore = other.SigmoidScore;
      }
      if (other.HasScoreClippingThresh) {
        ScoreClippingThresh = other.ScoreClippingThresh;
      }
      if (other.HasFlipVertically) {
        FlipVertically = other.FlipVertically;
      }
      if (other.HasMinScoreThresh) {
        MinScoreThresh = other.MinScoreThresh;
      }
      if (other.HasMaxResults) {
        MaxResults = other.MaxResults;
      }
      if (other.HasMaxClassesPerDetection) {
        MaxClassesPerDetection = other.MaxClassesPerDetection;
      }
      if (other.tensorMapping_ != null) {
        if (tensorMapping_ == null) {
          TensorMapping = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping();
        }
        TensorMapping.MergeFrom(other.TensorMapping);
      }
      if (other.HasBoxFormat) {
        BoxFormat = other.BoxFormat;
      }
      switch (other.BoxIndicesCase) {
        case BoxIndicesOneofCase.BoxBoundariesIndices:
          if (BoxBoundariesIndices == null) {
            BoxBoundariesIndices = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices();
          }
          BoxBoundariesIndices.MergeFrom(other.BoxBoundariesIndices);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumClasses = input.ReadInt32();
            break;
          }
          case 16: {
            NumBoxes = input.ReadInt32();
            break;
          }
          case 24: {
            NumCoords = input.ReadInt32();
            break;
          }
          case 37: {
            XScale = input.ReadFloat();
            break;
          }
          case 45: {
            YScale = input.ReadFloat();
            break;
          }
          case 53: {
            WScale = input.ReadFloat();
            break;
          }
          case 61: {
            HScale = input.ReadFloat();
            break;
          }
          case 66:
          case 64: {
            ignoreClasses_.AddEntriesFrom(input, _repeated_ignoreClasses_codec);
            break;
          }
          case 72: {
            KeypointCoordOffset = input.ReadInt32();
            break;
          }
          case 80: {
            NumKeypoints = input.ReadInt32();
            break;
          }
          case 88: {
            NumValuesPerKeypoint = input.ReadInt32();
            break;
          }
          case 96: {
            BoxCoordOffset = input.ReadInt32();
            break;
          }
          case 104: {
            ApplyExponentialOnBoxSize = input.ReadBool();
            break;
          }
          case 112: {
            ReverseOutputOrder = input.ReadBool();
            break;
          }
          case 120: {
            SigmoidScore = input.ReadBool();
            break;
          }
          case 133: {
            ScoreClippingThresh = input.ReadFloat();
            break;
          }
          case 144: {
            FlipVertically = input.ReadBool();
            break;
          }
          case 157: {
            MinScoreThresh = input.ReadFloat();
            break;
          }
          case 160: {
            MaxResults = input.ReadInt32();
            break;
          }
          case 170:
          case 168: {
            allowClasses_.AddEntriesFrom(input, _repeated_allowClasses_codec);
            break;
          }
          case 178: {
            if (tensorMapping_ == null) {
              TensorMapping = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping();
            }
            input.ReadMessage(TensorMapping);
            break;
          }
          case 186: {
            global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices subBuilder = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices();
            if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) {
              subBuilder.MergeFrom(BoxBoundariesIndices);
            }
            input.ReadMessage(subBuilder);
            BoxBoundariesIndices = subBuilder;
            break;
          }
          case 192: {
            BoxFormat = (global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat) input.ReadEnum();
            break;
          }
          case 200: {
            MaxClassesPerDetection = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NumClasses = input.ReadInt32();
            break;
          }
          case 16: {
            NumBoxes = input.ReadInt32();
            break;
          }
          case 24: {
            NumCoords = input.ReadInt32();
            break;
          }
          case 37: {
            XScale = input.ReadFloat();
            break;
          }
          case 45: {
            YScale = input.ReadFloat();
            break;
          }
          case 53: {
            WScale = input.ReadFloat();
            break;
          }
          case 61: {
            HScale = input.ReadFloat();
            break;
          }
          case 66:
          case 64: {
            ignoreClasses_.AddEntriesFrom(ref input, _repeated_ignoreClasses_codec);
            break;
          }
          case 72: {
            KeypointCoordOffset = input.ReadInt32();
            break;
          }
          case 80: {
            NumKeypoints = input.ReadInt32();
            break;
          }
          case 88: {
            NumValuesPerKeypoint = input.ReadInt32();
            break;
          }
          case 96: {
            BoxCoordOffset = input.ReadInt32();
            break;
          }
          case 104: {
            ApplyExponentialOnBoxSize = input.ReadBool();
            break;
          }
          case 112: {
            ReverseOutputOrder = input.ReadBool();
            break;
          }
          case 120: {
            SigmoidScore = input.ReadBool();
            break;
          }
          case 133: {
            ScoreClippingThresh = input.ReadFloat();
            break;
          }
          case 144: {
            FlipVertically = input.ReadBool();
            break;
          }
          case 157: {
            MinScoreThresh = input.ReadFloat();
            break;
          }
          case 160: {
            MaxResults = input.ReadInt32();
            break;
          }
          case 170:
          case 168: {
            allowClasses_.AddEntriesFrom(ref input, _repeated_allowClasses_codec);
            break;
          }
          case 178: {
            if (tensorMapping_ == null) {
              TensorMapping = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.TensorMapping();
            }
            input.ReadMessage(TensorMapping);
            break;
          }
          case 186: {
            global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices subBuilder = new global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxBoundariesIndices();
            if (boxIndicesCase_ == BoxIndicesOneofCase.BoxBoundariesIndices) {
              subBuilder.MergeFrom(BoxBoundariesIndices);
            }
            input.ReadMessage(subBuilder);
            BoxBoundariesIndices = subBuilder;
            break;
          }
          case 192: {
            BoxFormat = (global::Mediapipe.TensorsToDetectionsCalculatorOptions.Types.BoxFormat) input.ReadEnum();
            break;
          }
          case 200: {
            MaxClassesPerDetection = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TensorsToDetectionsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Tells the calculator how to convert the detector output to bounding boxes.
      /// Replaces `reverse_output_order` to support more bbox output formats.
      /// As with `reverse_output_order`, this also informs calculator the order
      /// of keypoint predictions.
      /// </summary>
      public enum BoxFormat {
        /// <summary>
        /// if UNSPECIFIED, the calculator assumes YXHW
        /// </summary>
        [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// bbox [y_center, x_center, height, width], keypoint [y, x]
        /// </summary>
        [pbr::OriginalName("YXHW")] Yxhw = 1,
        /// <summary>
        /// bbox [x_center, y_center, width, height], keypoint [x, y]
        /// </summary>
        [pbr::OriginalName("XYWH")] Xywh = 2,
        /// <summary>
        /// bbox [xmin, ymin, xmax, ymax], keypoint [x, y]
        /// </summary>
        [pbr::OriginalName("XYXY")] Xyxy = 3,
      }

      /// <summary>
      /// The custom model output tensor mapping.
      /// The indices of the "detections" tensor and the "scores" tensor are always
      /// required. If the model outputs an "anchors" tensor, `anchors_tensor_index`
      /// must be specified. If the model outputs both "classes" tensor and "number
      /// of detections" tensors, `classes_tensor_index` and
      /// `num_detections_tensor_index` must be set.
      /// </summary>
      public sealed partial class TensorMapping : pb::IMessage<TensorMapping>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TensorMapping> _parser = new pb::MessageParser<TensorMapping>(() => new TensorMapping());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TensorMapping> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.TensorsToDetectionsCalculatorOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TensorMapping() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TensorMapping(TensorMapping other) : this() {
          _hasBits0 = other._hasBits0;
          detectionsTensorIndex_ = other.detectionsTensorIndex_;
          classesTensorIndex_ = other.classesTensorIndex_;
          scoresTensorIndex_ = other.scoresTensorIndex_;
          numDetectionsTensorIndex_ = other.numDetectionsTensorIndex_;
          anchorsTensorIndex_ = other.anchorsTensorIndex_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TensorMapping Clone() {
          return new TensorMapping(this);
        }

        /// <summary>Field number for the "detections_tensor_index" field.</summary>
        public const int DetectionsTensorIndexFieldNumber = 1;
        private readonly static int DetectionsTensorIndexDefaultValue = 0;

        private int detectionsTensorIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int DetectionsTensorIndex {
          get { if ((_hasBits0 & 1) != 0) { return detectionsTensorIndex_; } else { return DetectionsTensorIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            detectionsTensorIndex_ = value;
          }
        }
        /// <summary>Gets whether the "detections_tensor_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDetectionsTensorIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "detections_tensor_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDetectionsTensorIndex() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "classes_tensor_index" field.</summary>
        public const int ClassesTensorIndexFieldNumber = 2;
        private readonly static int ClassesTensorIndexDefaultValue = 0;

        private int classesTensorIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int ClassesTensorIndex {
          get { if ((_hasBits0 & 2) != 0) { return classesTensorIndex_; } else { return ClassesTensorIndexDefaultValue; } }
          set {
            _hasBits0 |= 2;
            classesTensorIndex_ = value;
          }
        }
        /// <summary>Gets whether the "classes_tensor_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasClassesTensorIndex {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "classes_tensor_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearClassesTensorIndex() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "scores_tensor_index" field.</summary>
        public const int ScoresTensorIndexFieldNumber = 3;
        private readonly static int ScoresTensorIndexDefaultValue = 0;

        private int scoresTensorIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int ScoresTensorIndex {
          get { if ((_hasBits0 & 4) != 0) { return scoresTensorIndex_; } else { return ScoresTensorIndexDefaultValue; } }
          set {
            _hasBits0 |= 4;
            scoresTensorIndex_ = value;
          }
        }
        /// <summary>Gets whether the "scores_tensor_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasScoresTensorIndex {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "scores_tensor_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearScoresTensorIndex() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "num_detections_tensor_index" field.</summary>
        public const int NumDetectionsTensorIndexFieldNumber = 4;
        private readonly static int NumDetectionsTensorIndexDefaultValue = 0;

        private int numDetectionsTensorIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int NumDetectionsTensorIndex {
          get { if ((_hasBits0 & 8) != 0) { return numDetectionsTensorIndex_; } else { return NumDetectionsTensorIndexDefaultValue; } }
          set {
            _hasBits0 |= 8;
            numDetectionsTensorIndex_ = value;
          }
        }
        /// <summary>Gets whether the "num_detections_tensor_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasNumDetectionsTensorIndex {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "num_detections_tensor_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearNumDetectionsTensorIndex() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "anchors_tensor_index" field.</summary>
        public const int AnchorsTensorIndexFieldNumber = 5;
        private readonly static int AnchorsTensorIndexDefaultValue = 0;

        private int anchorsTensorIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int AnchorsTensorIndex {
          get { if ((_hasBits0 & 16) != 0) { return anchorsTensorIndex_; } else { return AnchorsTensorIndexDefaultValue; } }
          set {
            _hasBits0 |= 16;
            anchorsTensorIndex_ = value;
          }
        }
        /// <summary>Gets whether the "anchors_tensor_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAnchorsTensorIndex {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "anchors_tensor_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAnchorsTensorIndex() {
          _hasBits0 &= ~16;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TensorMapping);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TensorMapping other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DetectionsTensorIndex != other.DetectionsTensorIndex) return false;
          if (ClassesTensorIndex != other.ClassesTensorIndex) return false;
          if (ScoresTensorIndex != other.ScoresTensorIndex) return false;
          if (NumDetectionsTensorIndex != other.NumDetectionsTensorIndex) return false;
          if (AnchorsTensorIndex != other.AnchorsTensorIndex) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasDetectionsTensorIndex) hash ^= DetectionsTensorIndex.GetHashCode();
          if (HasClassesTensorIndex) hash ^= ClassesTensorIndex.GetHashCode();
          if (HasScoresTensorIndex) hash ^= ScoresTensorIndex.GetHashCode();
          if (HasNumDetectionsTensorIndex) hash ^= NumDetectionsTensorIndex.GetHashCode();
          if (HasAnchorsTensorIndex) hash ^= AnchorsTensorIndex.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasDetectionsTensorIndex) {
            output.WriteRawTag(8);
            output.WriteInt32(DetectionsTensorIndex);
          }
          if (HasClassesTensorIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(ClassesTensorIndex);
          }
          if (HasScoresTensorIndex) {
            output.WriteRawTag(24);
            output.WriteInt32(ScoresTensorIndex);
          }
          if (HasNumDetectionsTensorIndex) {
            output.WriteRawTag(32);
            output.WriteInt32(NumDetectionsTensorIndex);
          }
          if (HasAnchorsTensorIndex) {
            output.WriteRawTag(40);
            output.WriteInt32(AnchorsTensorIndex);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasDetectionsTensorIndex) {
            output.WriteRawTag(8);
            output.WriteInt32(DetectionsTensorIndex);
          }
          if (HasClassesTensorIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(ClassesTensorIndex);
          }
          if (HasScoresTensorIndex) {
            output.WriteRawTag(24);
            output.WriteInt32(ScoresTensorIndex);
          }
          if (HasNumDetectionsTensorIndex) {
            output.WriteRawTag(32);
            output.WriteInt32(NumDetectionsTensorIndex);
          }
          if (HasAnchorsTensorIndex) {
            output.WriteRawTag(40);
            output.WriteInt32(AnchorsTensorIndex);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasDetectionsTensorIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(DetectionsTensorIndex);
          }
          if (HasClassesTensorIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(ClassesTensorIndex);
          }
          if (HasScoresTensorIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(ScoresTensorIndex);
          }
          if (HasNumDetectionsTensorIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumDetectionsTensorIndex);
          }
          if (HasAnchorsTensorIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(AnchorsTensorIndex);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TensorMapping other) {
          if (other == null) {
            return;
          }
          if (other.HasDetectionsTensorIndex) {
            DetectionsTensorIndex = other.DetectionsTensorIndex;
          }
          if (other.HasClassesTensorIndex) {
            ClassesTensorIndex = other.ClassesTensorIndex;
          }
          if (other.HasScoresTensorIndex) {
            ScoresTensorIndex = other.ScoresTensorIndex;
          }
          if (other.HasNumDetectionsTensorIndex) {
            NumDetectionsTensorIndex = other.NumDetectionsTensorIndex;
          }
          if (other.HasAnchorsTensorIndex) {
            AnchorsTensorIndex = other.AnchorsTensorIndex;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DetectionsTensorIndex = input.ReadInt32();
                break;
              }
              case 16: {
                ClassesTensorIndex = input.ReadInt32();
                break;
              }
              case 24: {
                ScoresTensorIndex = input.ReadInt32();
                break;
              }
              case 32: {
                NumDetectionsTensorIndex = input.ReadInt32();
                break;
              }
              case 40: {
                AnchorsTensorIndex = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                DetectionsTensorIndex = input.ReadInt32();
                break;
              }
              case 16: {
                ClassesTensorIndex = input.ReadInt32();
                break;
              }
              case 24: {
                ScoresTensorIndex = input.ReadInt32();
                break;
              }
              case 32: {
                NumDetectionsTensorIndex = input.ReadInt32();
                break;
              }
              case 40: {
                AnchorsTensorIndex = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Represents the bounding box by using the combination of boundaries,
      /// {ymin, xmin, ymax, xmax}.
      /// The default order is {ymin, xmin, ymax, xmax}.
      /// </summary>
      public sealed partial class BoxBoundariesIndices : pb::IMessage<BoxBoundariesIndices>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BoxBoundariesIndices> _parser = new pb::MessageParser<BoxBoundariesIndices>(() => new BoxBoundariesIndices());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<BoxBoundariesIndices> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.TensorsToDetectionsCalculatorOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BoxBoundariesIndices() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BoxBoundariesIndices(BoxBoundariesIndices other) : this() {
          _hasBits0 = other._hasBits0;
          ymin_ = other.ymin_;
          xmin_ = other.xmin_;
          ymax_ = other.ymax_;
          xmax_ = other.xmax_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BoxBoundariesIndices Clone() {
          return new BoxBoundariesIndices(this);
        }

        /// <summary>Field number for the "ymin" field.</summary>
        public const int YminFieldNumber = 1;
        private readonly static int YminDefaultValue = 0;

        private int ymin_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Ymin {
          get { if ((_hasBits0 & 1) != 0) { return ymin_; } else { return YminDefaultValue; } }
          set {
            _hasBits0 |= 1;
            ymin_ = value;
          }
        }
        /// <summary>Gets whether the "ymin" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasYmin {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "ymin" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearYmin() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "xmin" field.</summary>
        public const int XminFieldNumber = 2;
        private readonly static int XminDefaultValue = 1;

        private int xmin_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Xmin {
          get { if ((_hasBits0 & 2) != 0) { return xmin_; } else { return XminDefaultValue; } }
          set {
            _hasBits0 |= 2;
            xmin_ = value;
          }
        }
        /// <summary>Gets whether the "xmin" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasXmin {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "xmin" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearXmin() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "ymax" field.</summary>
        public const int YmaxFieldNumber = 3;
        private readonly static int YmaxDefaultValue = 2;

        private int ymax_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Ymax {
          get { if ((_hasBits0 & 4) != 0) { return ymax_; } else { return YmaxDefaultValue; } }
          set {
            _hasBits0 |= 4;
            ymax_ = value;
          }
        }
        /// <summary>Gets whether the "ymax" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasYmax {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "ymax" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearYmax() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "xmax" field.</summary>
        public const int XmaxFieldNumber = 4;
        private readonly static int XmaxDefaultValue = 3;

        private int xmax_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Xmax {
          get { if ((_hasBits0 & 8) != 0) { return xmax_; } else { return XmaxDefaultValue; } }
          set {
            _hasBits0 |= 8;
            xmax_ = value;
          }
        }
        /// <summary>Gets whether the "xmax" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasXmax {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "xmax" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearXmax() {
          _hasBits0 &= ~8;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as BoxBoundariesIndices);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(BoxBoundariesIndices other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Ymin != other.Ymin) return false;
          if (Xmin != other.Xmin) return false;
          if (Ymax != other.Ymax) return false;
          if (Xmax != other.Xmax) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasYmin) hash ^= Ymin.GetHashCode();
          if (HasXmin) hash ^= Xmin.GetHashCode();
          if (HasYmax) hash ^= Ymax.GetHashCode();
          if (HasXmax) hash ^= Xmax.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasYmin) {
            output.WriteRawTag(8);
            output.WriteInt32(Ymin);
          }
          if (HasXmin) {
            output.WriteRawTag(16);
            output.WriteInt32(Xmin);
          }
          if (HasYmax) {
            output.WriteRawTag(24);
            output.WriteInt32(Ymax);
          }
          if (HasXmax) {
            output.WriteRawTag(32);
            output.WriteInt32(Xmax);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasYmin) {
            output.WriteRawTag(8);
            output.WriteInt32(Ymin);
          }
          if (HasXmin) {
            output.WriteRawTag(16);
            output.WriteInt32(Xmin);
          }
          if (HasYmax) {
            output.WriteRawTag(24);
            output.WriteInt32(Ymax);
          }
          if (HasXmax) {
            output.WriteRawTag(32);
            output.WriteInt32(Xmax);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasYmin) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Ymin);
          }
          if (HasXmin) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Xmin);
          }
          if (HasYmax) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Ymax);
          }
          if (HasXmax) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Xmax);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(BoxBoundariesIndices other) {
          if (other == null) {
            return;
          }
          if (other.HasYmin) {
            Ymin = other.Ymin;
          }
          if (other.HasXmin) {
            Xmin = other.Xmin;
          }
          if (other.HasYmax) {
            Ymax = other.Ymax;
          }
          if (other.HasXmax) {
            Xmax = other.Xmax;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Ymin = input.ReadInt32();
                break;
              }
              case 16: {
                Xmin = input.ReadInt32();
                break;
              }
              case 24: {
                Ymax = input.ReadInt32();
                break;
              }
              case 32: {
                Xmax = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Ymin = input.ReadInt32();
                break;
              }
              case 16: {
                Xmin = input.ReadInt32();
                break;
              }
              case 24: {
                Ymax = input.ReadInt32();
                break;
              }
              case 32: {
                Xmax = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the TensorsToDetectionsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.TensorsToDetectionsCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.TensorsToDetectionsCalculatorOptions>(335742639, pb::FieldCodec.ForMessage(2685941114, global::Mediapipe.TensorsToDetectionsCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

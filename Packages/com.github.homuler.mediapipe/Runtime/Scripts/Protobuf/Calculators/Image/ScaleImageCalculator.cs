// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/image/scale_image_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/image/scale_image_calculator.proto</summary>
  public static partial class ScaleImageCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/image/scale_image_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScaleImageCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjhtZWRpYXBpcGUvY2FsY3VsYXRvcnMvaW1hZ2Uvc2NhbGVfaW1hZ2VfY2Fs",
            "Y3VsYXRvci5wcm90bxIJbWVkaWFwaXBlGiRtZWRpYXBpcGUvZnJhbWV3b3Jr",
            "L2NhbGN1bGF0b3IucHJvdG8aLm1lZGlhcGlwZS9mcmFtZXdvcmsvZm9ybWF0",
            "cy9pbWFnZV9mb3JtYXQucHJvdG8iogYKG1NjYWxlSW1hZ2VDYWxjdWxhdG9y",
            "T3B0aW9ucxIUCgx0YXJnZXRfd2lkdGgYASABKAUSFQoNdGFyZ2V0X2hlaWdo",
            "dBgCIAEoBRIXCg90YXJnZXRfbWF4X2FyZWEYDyABKAUSIwoVcHJlc2VydmVf",
            "YXNwZWN0X3JhdGlvGAMgASgIOgR0cnVlEh4KEG1pbl9hc3BlY3RfcmF0aW8Y",
            "BCABKAk6BDkvMTYSHgoQbWF4X2FzcGVjdF9yYXRpbxgFIAEoCToEMTYvORI0",
            "Cg1vdXRwdXRfZm9ybWF0GAYgASgOMh0ubWVkaWFwaXBlLkltYWdlRm9ybWF0",
            "LkZvcm1hdBJRCglhbGdvcml0aG0YByABKA4yNS5tZWRpYXBpcGUuU2NhbGVJ",
            "bWFnZUNhbGN1bGF0b3JPcHRpb25zLlNjYWxlQWxnb3JpdGhtOgdERUZBVUxU",
            "Eh4KEmFsaWdubWVudF9ib3VuZGFyeRgIIAEoBToCMTYSIwoVc2V0X2FsaWdu",
            "bWVudF9wYWRkaW5nGAkgASgIOgR0cnVlEjIKI09CU09MRVRFX3NraXBfbGlu",
            "ZWFyX3JnYl9jb252ZXJzaW9uGAogASgIOgVmYWxzZRImChtwb3N0X3NoYXJw",
            "ZW5pbmdfY29lZmZpY2llbnQYCyABKAI6ATASMwoMaW5wdXRfZm9ybWF0GAwg",
            "ASgOMh0ubWVkaWFwaXBlLkltYWdlRm9ybWF0LkZvcm1hdBIfChRzY2FsZV90",
            "b19tdWx0aXBsZV9vZhgNIAEoBToBMhIYCgl1c2VfYnQ3MDkYDiABKAg6BWZh",
            "bHNlImgKDlNjYWxlQWxnb3JpdGhtEgsKB0RFRkFVTFQQABIKCgZMSU5FQVIQ",
            "ARIJCgVDVUJJQxACEggKBEFSRUEQAxILCgdMQU5DWk9TEAQSGwoXREVGQVVM",
            "VF9XSVRIT1VUX1VQU0NBTEUQBTJUCgNleHQSHC5tZWRpYXBpcGUuQ2FsY3Vs",
            "YXRvck9wdGlvbnMYu+XKHyABKAsyJi5tZWRpYXBpcGUuU2NhbGVJbWFnZUNh",
            "bGN1bGF0b3JPcHRpb25z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, global::Mediapipe.ImageFormatReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ScaleImageCalculatorOptions), global::Mediapipe.ScaleImageCalculatorOptions.Parser, new[]{ "TargetWidth", "TargetHeight", "TargetMaxArea", "PreserveAspectRatio", "MinAspectRatio", "MaxAspectRatio", "OutputFormat", "Algorithm", "AlignmentBoundary", "SetAlignmentPadding", "OBSOLETESkipLinearRgbConversion", "PostSharpeningCoefficient", "InputFormat", "ScaleToMultipleOf", "UseBt709" }, null, new[]{ typeof(global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm) }, new pb::Extension[] { global::Mediapipe.ScaleImageCalculatorOptions.Extensions.Ext }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Order of operations.
  /// 1) Crop the image to fit within min_aspect_ratio and max_aspect_ratio.
  /// 2) Scale and convert the image to fit inside target_width x target_height
  ///    using the specified scaling algorithm.  (maintaining the aspect
  ///    ratio if preserve_aspect_ratio is true).
  /// The output width and height will be divisible by 2, by default. It is
  /// possible to output width and height that are odd numbers when the output
  /// format is SRGB and the aspect ratio is left unpreserved. See
  /// scale_to_multiple_of for details.
  /// </summary>
  public sealed partial class ScaleImageCalculatorOptions : pb::IMessage<ScaleImageCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScaleImageCalculatorOptions> _parser = new pb::MessageParser<ScaleImageCalculatorOptions>(() => new ScaleImageCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScaleImageCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.ScaleImageCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleImageCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleImageCalculatorOptions(ScaleImageCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      targetWidth_ = other.targetWidth_;
      targetHeight_ = other.targetHeight_;
      targetMaxArea_ = other.targetMaxArea_;
      preserveAspectRatio_ = other.preserveAspectRatio_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      outputFormat_ = other.outputFormat_;
      algorithm_ = other.algorithm_;
      alignmentBoundary_ = other.alignmentBoundary_;
      setAlignmentPadding_ = other.setAlignmentPadding_;
      oBSOLETESkipLinearRgbConversion_ = other.oBSOLETESkipLinearRgbConversion_;
      postSharpeningCoefficient_ = other.postSharpeningCoefficient_;
      inputFormat_ = other.inputFormat_;
      scaleToMultipleOf_ = other.scaleToMultipleOf_;
      useBt709_ = other.useBt709_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleImageCalculatorOptions Clone() {
      return new ScaleImageCalculatorOptions(this);
    }

    /// <summary>Field number for the "target_width" field.</summary>
    public const int TargetWidthFieldNumber = 1;
    private readonly static int TargetWidthDefaultValue = 0;

    private int targetWidth_;
    /// <summary>
    /// Target output width and height.  The final output's size may vary
    /// depending on the other options below.  If unset, use the same width
    /// or height as the input.  If only one is set then determine the other
    /// from the aspect ratio (after cropping).  The output width and height
    /// will be divisible by 2, by default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TargetWidth {
      get { if ((_hasBits0 & 1) != 0) { return targetWidth_; } else { return TargetWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        targetWidth_ = value;
      }
    }
    /// <summary>Gets whether the "target_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "target_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "target_height" field.</summary>
    public const int TargetHeightFieldNumber = 2;
    private readonly static int TargetHeightDefaultValue = 0;

    private int targetHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TargetHeight {
      get { if ((_hasBits0 & 2) != 0) { return targetHeight_; } else { return TargetHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        targetHeight_ = value;
      }
    }
    /// <summary>Gets whether the "target_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "target_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "target_max_area" field.</summary>
    public const int TargetMaxAreaFieldNumber = 15;
    private readonly static int TargetMaxAreaDefaultValue = 0;

    private int targetMaxArea_;
    /// <summary>
    /// If set, then automatically calculates a target_width and target_height that
    /// has an area below the target max area. Aspect ratio preservation cannot be
    /// disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TargetMaxArea {
      get { if ((_hasBits0 & 4096) != 0) { return targetMaxArea_; } else { return TargetMaxAreaDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        targetMaxArea_ = value;
      }
    }
    /// <summary>Gets whether the "target_max_area" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetMaxArea {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "target_max_area" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetMaxArea() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "preserve_aspect_ratio" field.</summary>
    public const int PreserveAspectRatioFieldNumber = 3;
    private readonly static bool PreserveAspectRatioDefaultValue = true;

    private bool preserveAspectRatio_;
    /// <summary>
    /// If true, the image is scaled up or down proportionally so that it
    /// fits inside the box represented by target_width and target_height.
    /// Otherwise it is scaled to fit target_width and target_height
    /// completely.  In any case, the aspect ratio that is preserved is
    /// that after cropping to the minimum/maximum aspect ratio. Additionally, if
    /// true, the output width and height will be divisible by 2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PreserveAspectRatio {
      get { if ((_hasBits0 & 4) != 0) { return preserveAspectRatio_; } else { return PreserveAspectRatioDefaultValue; } }
      set {
        _hasBits0 |= 4;
        preserveAspectRatio_ = value;
      }
    }
    /// <summary>Gets whether the "preserve_aspect_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPreserveAspectRatio {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "preserve_aspect_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPreserveAspectRatio() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 4;
    private readonly static string MinAspectRatioDefaultValue = global::System.Text.Encoding.UTF8.GetString(global::System.Convert.FromBase64String("OS8xNg=="), 0, 4);

    private string minAspectRatio_;
    /// <summary>
    /// If ratio is positive, crop the image to this minimum and maximum
    /// aspect ratio (preserving the center of the frame).  This is done
    /// before scaling.  The string must contain "/", so to disable cropping,
    /// set both to "0/1".
    ///   For example, for a min_aspect_ratio of "9/16" and max of "16/9" the
    ///   following cropping will occur:
    ///       1920x1080 (which is 16:9) is not cropped
    ///       640x1024  (which is 10:16) is not cropped
    ///       640x320   (which is 2:1) cropped to 568x320 (just under 16/9)
    ///       96x480    (which is 1:5), cropped to 96x170 (just over 9/16)
    ///   The resultant frame will always be between (or at) the
    ///   min_aspect_ratio and max_aspect_ratio.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MinAspectRatio {
      get { return minAspectRatio_ ?? MinAspectRatioDefaultValue; }
      set {
        minAspectRatio_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "min_aspect_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinAspectRatio {
      get { return minAspectRatio_ != null; }
    }
    /// <summary>Clears the value of the "min_aspect_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinAspectRatio() {
      minAspectRatio_ = null;
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 5;
    private readonly static string MaxAspectRatioDefaultValue = global::System.Text.Encoding.UTF8.GetString(global::System.Convert.FromBase64String("MTYvOQ=="), 0, 4);

    private string maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MaxAspectRatio {
      get { return maxAspectRatio_ ?? MaxAspectRatioDefaultValue; }
      set {
        maxAspectRatio_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "max_aspect_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxAspectRatio {
      get { return maxAspectRatio_ != null; }
    }
    /// <summary>Clears the value of the "max_aspect_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxAspectRatio() {
      maxAspectRatio_ = null;
    }

    /// <summary>Field number for the "output_format" field.</summary>
    public const int OutputFormatFieldNumber = 6;
    private readonly static global::Mediapipe.ImageFormat.Types.Format OutputFormatDefaultValue = global::Mediapipe.ImageFormat.Types.Format.Unknown;

    private global::Mediapipe.ImageFormat.Types.Format outputFormat_;
    /// <summary>
    /// If unset, use the same format as the input.
    /// NOTE: in the current implementation, the output format (either specified
    /// in the output_format option or inherited from the input format) must be
    /// SRGB. It can be YCBCR420P if the input_format is also the same.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ImageFormat.Types.Format OutputFormat {
      get { if ((_hasBits0 & 8) != 0) { return outputFormat_; } else { return OutputFormatDefaultValue; } }
      set {
        _hasBits0 |= 8;
        outputFormat_ = value;
      }
    }
    /// <summary>Gets whether the "output_format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutputFormat {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "output_format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutputFormat() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "algorithm" field.</summary>
    public const int AlgorithmFieldNumber = 7;
    private readonly static global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm AlgorithmDefaultValue = global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm.Default;

    private global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm algorithm_;
    /// <summary>
    /// The upscaling algorithm to use.  The default is to use CUBIC.  Note that
    /// downscaling unconditionally uses DDA; see image_processing::
    /// AffineGammaResizer for documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm Algorithm {
      get { if ((_hasBits0 & 16) != 0) { return algorithm_; } else { return AlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 16;
        algorithm_ = value;
      }
    }
    /// <summary>Gets whether the "algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlgorithm {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlgorithm() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "alignment_boundary" field.</summary>
    public const int AlignmentBoundaryFieldNumber = 8;
    private readonly static int AlignmentBoundaryDefaultValue = 16;

    private int alignmentBoundary_;
    /// <summary>
    /// The output image will have this alignment.  If set to zero, then
    /// any alignment could be used.  If set to one, the output image will
    /// be stored contiguously.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AlignmentBoundary {
      get { if ((_hasBits0 & 32) != 0) { return alignmentBoundary_; } else { return AlignmentBoundaryDefaultValue; } }
      set {
        _hasBits0 |= 32;
        alignmentBoundary_ = value;
      }
    }
    /// <summary>Gets whether the "alignment_boundary" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAlignmentBoundary {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "alignment_boundary" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAlignmentBoundary() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "set_alignment_padding" field.</summary>
    public const int SetAlignmentPaddingFieldNumber = 9;
    private readonly static bool SetAlignmentPaddingDefaultValue = true;

    private bool setAlignmentPadding_;
    /// <summary>
    /// Set the alignment padding area to deterministic values (as opposed
    /// to possibly leaving it as uninitialized memory).  The padding is
    /// the space between the pixel values in a row and the end of the row
    /// (which may be different due to alignment requirements on the length
    /// of a row).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetAlignmentPadding {
      get { if ((_hasBits0 & 64) != 0) { return setAlignmentPadding_; } else { return SetAlignmentPaddingDefaultValue; } }
      set {
        _hasBits0 |= 64;
        setAlignmentPadding_ = value;
      }
    }
    /// <summary>Gets whether the "set_alignment_padding" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSetAlignmentPadding {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "set_alignment_padding" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSetAlignmentPadding() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "OBSOLETE_skip_linear_rgb_conversion" field.</summary>
    public const int OBSOLETESkipLinearRgbConversionFieldNumber = 10;
    private readonly static bool OBSOLETESkipLinearRgbConversionDefaultValue = false;

    private bool oBSOLETESkipLinearRgbConversion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OBSOLETESkipLinearRgbConversion {
      get { if ((_hasBits0 & 128) != 0) { return oBSOLETESkipLinearRgbConversion_; } else { return OBSOLETESkipLinearRgbConversionDefaultValue; } }
      set {
        _hasBits0 |= 128;
        oBSOLETESkipLinearRgbConversion_ = value;
      }
    }
    /// <summary>Gets whether the "OBSOLETE_skip_linear_rgb_conversion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOBSOLETESkipLinearRgbConversion {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "OBSOLETE_skip_linear_rgb_conversion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOBSOLETESkipLinearRgbConversion() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "post_sharpening_coefficient" field.</summary>
    public const int PostSharpeningCoefficientFieldNumber = 11;
    private readonly static float PostSharpeningCoefficientDefaultValue = 0F;

    private float postSharpeningCoefficient_;
    /// <summary>
    /// Applies sharpening for downscaled images as post-processing.  See
    /// image_processing::AffineGammaResizer for documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PostSharpeningCoefficient {
      get { if ((_hasBits0 & 256) != 0) { return postSharpeningCoefficient_; } else { return PostSharpeningCoefficientDefaultValue; } }
      set {
        _hasBits0 |= 256;
        postSharpeningCoefficient_ = value;
      }
    }
    /// <summary>Gets whether the "post_sharpening_coefficient" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPostSharpeningCoefficient {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "post_sharpening_coefficient" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPostSharpeningCoefficient() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "input_format" field.</summary>
    public const int InputFormatFieldNumber = 12;
    private readonly static global::Mediapipe.ImageFormat.Types.Format InputFormatDefaultValue = global::Mediapipe.ImageFormat.Types.Format.Unknown;

    private global::Mediapipe.ImageFormat.Types.Format inputFormat_;
    /// <summary>
    /// If input_format is YCBCR420P, input packets contain a YUVImage. If
    /// input_format is a format other than YCBCR420P or is unset, input packets
    /// contain an ImageFrame.
    /// NOTE: in the current implementation, the input format (either specified
    /// in the input_format option or inferred from the input packets) must be
    /// SRGB or YCBCR420P.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ImageFormat.Types.Format InputFormat {
      get { if ((_hasBits0 & 512) != 0) { return inputFormat_; } else { return InputFormatDefaultValue; } }
      set {
        _hasBits0 |= 512;
        inputFormat_ = value;
      }
    }
    /// <summary>Gets whether the "input_format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputFormat {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "input_format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputFormat() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "scale_to_multiple_of" field.</summary>
    public const int ScaleToMultipleOfFieldNumber = 13;
    private readonly static int ScaleToMultipleOfDefaultValue = 2;

    private int scaleToMultipleOf_;
    /// <summary>
    /// If set to 2, the target width and height will be rounded-down
    /// to the nearest even number. If set to any positive value other than 2,
    /// preserve_aspect_ratio must be false and the target width and height will be
    /// rounded-down to multiples of the given value. If set to any value less than
    /// 1, it will be treated like 1.
    /// NOTE: If set to an odd number, the output format must be SRGB.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ScaleToMultipleOf {
      get { if ((_hasBits0 & 1024) != 0) { return scaleToMultipleOf_; } else { return ScaleToMultipleOfDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        scaleToMultipleOf_ = value;
      }
    }
    /// <summary>Gets whether the "scale_to_multiple_of" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScaleToMultipleOf {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "scale_to_multiple_of" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScaleToMultipleOf() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "use_bt709" field.</summary>
    public const int UseBt709FieldNumber = 14;
    private readonly static bool UseBt709DefaultValue = false;

    private bool useBt709_;
    /// <summary>
    /// If true, assume the input YUV is BT.709 (this is the HDTV standard, so most
    /// content is likely using it). If false use the previous assumption of BT.601
    /// (mid-80s standard). Ideally this information should be contained in the
    /// input YUV Frame, but as of 02/06/2019, it's not. Once this info is baked
    /// in, this flag becomes useless.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseBt709 {
      get { if ((_hasBits0 & 2048) != 0) { return useBt709_; } else { return UseBt709DefaultValue; } }
      set {
        _hasBits0 |= 2048;
        useBt709_ = value;
      }
    }
    /// <summary>Gets whether the "use_bt709" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseBt709 {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "use_bt709" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseBt709() {
      _hasBits0 &= ~2048;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScaleImageCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScaleImageCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TargetWidth != other.TargetWidth) return false;
      if (TargetHeight != other.TargetHeight) return false;
      if (TargetMaxArea != other.TargetMaxArea) return false;
      if (PreserveAspectRatio != other.PreserveAspectRatio) return false;
      if (MinAspectRatio != other.MinAspectRatio) return false;
      if (MaxAspectRatio != other.MaxAspectRatio) return false;
      if (OutputFormat != other.OutputFormat) return false;
      if (Algorithm != other.Algorithm) return false;
      if (AlignmentBoundary != other.AlignmentBoundary) return false;
      if (SetAlignmentPadding != other.SetAlignmentPadding) return false;
      if (OBSOLETESkipLinearRgbConversion != other.OBSOLETESkipLinearRgbConversion) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PostSharpeningCoefficient, other.PostSharpeningCoefficient)) return false;
      if (InputFormat != other.InputFormat) return false;
      if (ScaleToMultipleOf != other.ScaleToMultipleOf) return false;
      if (UseBt709 != other.UseBt709) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTargetWidth) hash ^= TargetWidth.GetHashCode();
      if (HasTargetHeight) hash ^= TargetHeight.GetHashCode();
      if (HasTargetMaxArea) hash ^= TargetMaxArea.GetHashCode();
      if (HasPreserveAspectRatio) hash ^= PreserveAspectRatio.GetHashCode();
      if (HasMinAspectRatio) hash ^= MinAspectRatio.GetHashCode();
      if (HasMaxAspectRatio) hash ^= MaxAspectRatio.GetHashCode();
      if (HasOutputFormat) hash ^= OutputFormat.GetHashCode();
      if (HasAlgorithm) hash ^= Algorithm.GetHashCode();
      if (HasAlignmentBoundary) hash ^= AlignmentBoundary.GetHashCode();
      if (HasSetAlignmentPadding) hash ^= SetAlignmentPadding.GetHashCode();
      if (HasOBSOLETESkipLinearRgbConversion) hash ^= OBSOLETESkipLinearRgbConversion.GetHashCode();
      if (HasPostSharpeningCoefficient) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PostSharpeningCoefficient);
      if (HasInputFormat) hash ^= InputFormat.GetHashCode();
      if (HasScaleToMultipleOf) hash ^= ScaleToMultipleOf.GetHashCode();
      if (HasUseBt709) hash ^= UseBt709.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTargetWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(TargetWidth);
      }
      if (HasTargetHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(TargetHeight);
      }
      if (HasPreserveAspectRatio) {
        output.WriteRawTag(24);
        output.WriteBool(PreserveAspectRatio);
      }
      if (HasMinAspectRatio) {
        output.WriteRawTag(34);
        output.WriteString(MinAspectRatio);
      }
      if (HasMaxAspectRatio) {
        output.WriteRawTag(42);
        output.WriteString(MaxAspectRatio);
      }
      if (HasOutputFormat) {
        output.WriteRawTag(48);
        output.WriteEnum((int) OutputFormat);
      }
      if (HasAlgorithm) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Algorithm);
      }
      if (HasAlignmentBoundary) {
        output.WriteRawTag(64);
        output.WriteInt32(AlignmentBoundary);
      }
      if (HasSetAlignmentPadding) {
        output.WriteRawTag(72);
        output.WriteBool(SetAlignmentPadding);
      }
      if (HasOBSOLETESkipLinearRgbConversion) {
        output.WriteRawTag(80);
        output.WriteBool(OBSOLETESkipLinearRgbConversion);
      }
      if (HasPostSharpeningCoefficient) {
        output.WriteRawTag(93);
        output.WriteFloat(PostSharpeningCoefficient);
      }
      if (HasInputFormat) {
        output.WriteRawTag(96);
        output.WriteEnum((int) InputFormat);
      }
      if (HasScaleToMultipleOf) {
        output.WriteRawTag(104);
        output.WriteInt32(ScaleToMultipleOf);
      }
      if (HasUseBt709) {
        output.WriteRawTag(112);
        output.WriteBool(UseBt709);
      }
      if (HasTargetMaxArea) {
        output.WriteRawTag(120);
        output.WriteInt32(TargetMaxArea);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTargetWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(TargetWidth);
      }
      if (HasTargetHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(TargetHeight);
      }
      if (HasPreserveAspectRatio) {
        output.WriteRawTag(24);
        output.WriteBool(PreserveAspectRatio);
      }
      if (HasMinAspectRatio) {
        output.WriteRawTag(34);
        output.WriteString(MinAspectRatio);
      }
      if (HasMaxAspectRatio) {
        output.WriteRawTag(42);
        output.WriteString(MaxAspectRatio);
      }
      if (HasOutputFormat) {
        output.WriteRawTag(48);
        output.WriteEnum((int) OutputFormat);
      }
      if (HasAlgorithm) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Algorithm);
      }
      if (HasAlignmentBoundary) {
        output.WriteRawTag(64);
        output.WriteInt32(AlignmentBoundary);
      }
      if (HasSetAlignmentPadding) {
        output.WriteRawTag(72);
        output.WriteBool(SetAlignmentPadding);
      }
      if (HasOBSOLETESkipLinearRgbConversion) {
        output.WriteRawTag(80);
        output.WriteBool(OBSOLETESkipLinearRgbConversion);
      }
      if (HasPostSharpeningCoefficient) {
        output.WriteRawTag(93);
        output.WriteFloat(PostSharpeningCoefficient);
      }
      if (HasInputFormat) {
        output.WriteRawTag(96);
        output.WriteEnum((int) InputFormat);
      }
      if (HasScaleToMultipleOf) {
        output.WriteRawTag(104);
        output.WriteInt32(ScaleToMultipleOf);
      }
      if (HasUseBt709) {
        output.WriteRawTag(112);
        output.WriteBool(UseBt709);
      }
      if (HasTargetMaxArea) {
        output.WriteRawTag(120);
        output.WriteInt32(TargetMaxArea);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTargetWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TargetWidth);
      }
      if (HasTargetHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TargetHeight);
      }
      if (HasTargetMaxArea) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TargetMaxArea);
      }
      if (HasPreserveAspectRatio) {
        size += 1 + 1;
      }
      if (HasMinAspectRatio) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MinAspectRatio);
      }
      if (HasMaxAspectRatio) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MaxAspectRatio);
      }
      if (HasOutputFormat) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OutputFormat);
      }
      if (HasAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
      }
      if (HasAlignmentBoundary) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AlignmentBoundary);
      }
      if (HasSetAlignmentPadding) {
        size += 1 + 1;
      }
      if (HasOBSOLETESkipLinearRgbConversion) {
        size += 1 + 1;
      }
      if (HasPostSharpeningCoefficient) {
        size += 1 + 4;
      }
      if (HasInputFormat) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InputFormat);
      }
      if (HasScaleToMultipleOf) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ScaleToMultipleOf);
      }
      if (HasUseBt709) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScaleImageCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasTargetWidth) {
        TargetWidth = other.TargetWidth;
      }
      if (other.HasTargetHeight) {
        TargetHeight = other.TargetHeight;
      }
      if (other.HasTargetMaxArea) {
        TargetMaxArea = other.TargetMaxArea;
      }
      if (other.HasPreserveAspectRatio) {
        PreserveAspectRatio = other.PreserveAspectRatio;
      }
      if (other.HasMinAspectRatio) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.HasMaxAspectRatio) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.HasOutputFormat) {
        OutputFormat = other.OutputFormat;
      }
      if (other.HasAlgorithm) {
        Algorithm = other.Algorithm;
      }
      if (other.HasAlignmentBoundary) {
        AlignmentBoundary = other.AlignmentBoundary;
      }
      if (other.HasSetAlignmentPadding) {
        SetAlignmentPadding = other.SetAlignmentPadding;
      }
      if (other.HasOBSOLETESkipLinearRgbConversion) {
        OBSOLETESkipLinearRgbConversion = other.OBSOLETESkipLinearRgbConversion;
      }
      if (other.HasPostSharpeningCoefficient) {
        PostSharpeningCoefficient = other.PostSharpeningCoefficient;
      }
      if (other.HasInputFormat) {
        InputFormat = other.InputFormat;
      }
      if (other.HasScaleToMultipleOf) {
        ScaleToMultipleOf = other.ScaleToMultipleOf;
      }
      if (other.HasUseBt709) {
        UseBt709 = other.UseBt709;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TargetWidth = input.ReadInt32();
            break;
          }
          case 16: {
            TargetHeight = input.ReadInt32();
            break;
          }
          case 24: {
            PreserveAspectRatio = input.ReadBool();
            break;
          }
          case 34: {
            MinAspectRatio = input.ReadString();
            break;
          }
          case 42: {
            MaxAspectRatio = input.ReadString();
            break;
          }
          case 48: {
            OutputFormat = (global::Mediapipe.ImageFormat.Types.Format) input.ReadEnum();
            break;
          }
          case 56: {
            Algorithm = (global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm) input.ReadEnum();
            break;
          }
          case 64: {
            AlignmentBoundary = input.ReadInt32();
            break;
          }
          case 72: {
            SetAlignmentPadding = input.ReadBool();
            break;
          }
          case 80: {
            OBSOLETESkipLinearRgbConversion = input.ReadBool();
            break;
          }
          case 93: {
            PostSharpeningCoefficient = input.ReadFloat();
            break;
          }
          case 96: {
            InputFormat = (global::Mediapipe.ImageFormat.Types.Format) input.ReadEnum();
            break;
          }
          case 104: {
            ScaleToMultipleOf = input.ReadInt32();
            break;
          }
          case 112: {
            UseBt709 = input.ReadBool();
            break;
          }
          case 120: {
            TargetMaxArea = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TargetWidth = input.ReadInt32();
            break;
          }
          case 16: {
            TargetHeight = input.ReadInt32();
            break;
          }
          case 24: {
            PreserveAspectRatio = input.ReadBool();
            break;
          }
          case 34: {
            MinAspectRatio = input.ReadString();
            break;
          }
          case 42: {
            MaxAspectRatio = input.ReadString();
            break;
          }
          case 48: {
            OutputFormat = (global::Mediapipe.ImageFormat.Types.Format) input.ReadEnum();
            break;
          }
          case 56: {
            Algorithm = (global::Mediapipe.ScaleImageCalculatorOptions.Types.ScaleAlgorithm) input.ReadEnum();
            break;
          }
          case 64: {
            AlignmentBoundary = input.ReadInt32();
            break;
          }
          case 72: {
            SetAlignmentPadding = input.ReadBool();
            break;
          }
          case 80: {
            OBSOLETESkipLinearRgbConversion = input.ReadBool();
            break;
          }
          case 93: {
            PostSharpeningCoefficient = input.ReadFloat();
            break;
          }
          case 96: {
            InputFormat = (global::Mediapipe.ImageFormat.Types.Format) input.ReadEnum();
            break;
          }
          case 104: {
            ScaleToMultipleOf = input.ReadInt32();
            break;
          }
          case 112: {
            UseBt709 = input.ReadBool();
            break;
          }
          case 120: {
            TargetMaxArea = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ScaleImageCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ScaleAlgorithm {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("LINEAR")] Linear = 1,
        [pbr::OriginalName("CUBIC")] Cubic = 2,
        [pbr::OriginalName("AREA")] Area = 3,
        [pbr::OriginalName("LANCZOS")] Lanczos = 4,
        /// <summary>
        /// Option to disallow upscaling.
        /// </summary>
        [pbr::OriginalName("DEFAULT_WITHOUT_UPSCALE")] DefaultWithoutUpscale = 5,
      }

    }
    #endregion

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the ScaleImageCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.ScaleImageCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.ScaleImageCalculatorOptions>(66237115, pb::FieldCodec.ForMessage(529896922, global::Mediapipe.ScaleImageCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/video/motion_analysis_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/video/motion_analysis_calculator.proto</summary>
  public static partial class MotionAnalysisCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/video/motion_analysis_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MotionAnalysisCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjxtZWRpYXBpcGUvY2FsY3VsYXRvcnMvdmlkZW8vbW90aW9uX2FuYWx5c2lz",
            "X2NhbGN1bGF0b3IucHJvdG8SCW1lZGlhcGlwZRokbWVkaWFwaXBlL2ZyYW1l",
            "d29yay9jYWxjdWxhdG9yLnByb3RvGi1tZWRpYXBpcGUvdXRpbC90cmFja2lu",
            "Zy9tb3Rpb25fYW5hbHlzaXMucHJvdG8i5QUKH01vdGlvbkFuYWx5c2lzQ2Fs",
            "Y3VsYXRvck9wdGlvbnMSOgoQYW5hbHlzaXNfb3B0aW9ucxgBIAEoCzIgLm1l",
            "ZGlhcGlwZS5Nb3Rpb25BbmFseXNpc09wdGlvbnMSbAoSc2VsZWN0aW9uX2Fu",
            "YWx5c2lzGAQgASgOMjwubWVkaWFwaXBlLk1vdGlvbkFuYWx5c2lzQ2FsY3Vs",
            "YXRvck9wdGlvbnMuU2VsZWN0aW9uQW5hbHlzaXM6EkFOQUxZU0lTX1dJVEhf",
            "U0VFRBImChdoeWJyaWRfc2VsZWN0aW9uX2NhbWVyYRgFIAEoCDoFZmFsc2US",
            "ZgoNbWV0YV9hbmFseXNpcxgIIAEoDjI3Lm1lZGlhcGlwZS5Nb3Rpb25BbmFs",
            "eXNpc0NhbGN1bGF0b3JPcHRpb25zLk1ldGFBbmFseXNpczoWTUVUQV9BTkFM",
            "WVNJU19VU0VfTUVUQRIgChVtZXRhX21vZGVsc19wZXJfZnJhbWUYBiABKAU6",
            "ATESKQoZbWV0YV9vdXRsaWVyX2RvbWFpbl9yYXRpbxgJIAEoAjoGMC4wMDE1",
            "EhoKC2J5cGFzc19tb2RlGAcgASgIOgVmYWxzZSJ+ChFTZWxlY3Rpb25BbmFs",
            "eXNpcxIWChJBTkFMWVNJU19SRUNPTVBVVEUQARIdChlOT19BTkFMWVNJU19V",
            "U0VfU0VMRUNUSU9OEAISGgoWQU5BTFlTSVNfRlJPTV9GRUFUVVJFUxADEhYK",
            "EkFOQUxZU0lTX1dJVEhfU0VFRBAEIkQKDE1ldGFBbmFseXNpcxIaChZNRVRB",
            "X0FOQUxZU0lTX1VTRV9NRVRBEAESGAoUTUVUQV9BTkFMWVNJU19IWUJSSUQQ",
            "AjJZCgNleHQSHC5tZWRpYXBpcGUuQ2FsY3VsYXRvck9wdGlvbnMYj46KgQEg",
            "ASgLMioubWVkaWFwaXBlLk1vdGlvbkFuYWx5c2lzQ2FsY3VsYXRvck9wdGlv",
            "bnMigQEKDkhvbW9ncmFwaHlEYXRhEiIKFm1vdGlvbl9ob21vZ3JhcGh5X2Rh",
            "dGEYASADKAJCAhABEiAKFGhpc3RvZ3JhbV9jb3VudF9kYXRhGAIgAygNQgIQ",
            "ARITCgtmcmFtZV93aWR0aBgDIAEoBRIUCgxmcmFtZV9oZWlnaHQYBCABKAU="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, global::Mediapipe.MotionAnalysisReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionAnalysisCalculatorOptions), global::Mediapipe.MotionAnalysisCalculatorOptions.Parser, new[]{ "AnalysisOptions", "SelectionAnalysis", "HybridSelectionCamera", "MetaAnalysis", "MetaModelsPerFrame", "MetaOutlierDomainRatio", "BypassMode" }, null, new[]{ typeof(global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis), typeof(global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis) }, new pb::Extension[] { global::Mediapipe.MotionAnalysisCalculatorOptions.Extensions.Ext }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.HomographyData), global::Mediapipe.HomographyData.Parser, new[]{ "MotionHomographyData", "HistogramCountData", "FrameWidth", "FrameHeight" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Next tag: 10
  /// </summary>
  public sealed partial class MotionAnalysisCalculatorOptions : pb::IMessage<MotionAnalysisCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MotionAnalysisCalculatorOptions> _parser = new pb::MessageParser<MotionAnalysisCalculatorOptions>(() => new MotionAnalysisCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MotionAnalysisCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.MotionAnalysisCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisCalculatorOptions(MotionAnalysisCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      analysisOptions_ = other.analysisOptions_ != null ? other.analysisOptions_.Clone() : null;
      selectionAnalysis_ = other.selectionAnalysis_;
      hybridSelectionCamera_ = other.hybridSelectionCamera_;
      metaAnalysis_ = other.metaAnalysis_;
      metaModelsPerFrame_ = other.metaModelsPerFrame_;
      metaOutlierDomainRatio_ = other.metaOutlierDomainRatio_;
      bypassMode_ = other.bypassMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisCalculatorOptions Clone() {
      return new MotionAnalysisCalculatorOptions(this);
    }

    /// <summary>Field number for the "analysis_options" field.</summary>
    public const int AnalysisOptionsFieldNumber = 1;
    private global::Mediapipe.MotionAnalysisOptions analysisOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisOptions AnalysisOptions {
      get { return analysisOptions_; }
      set {
        analysisOptions_ = value;
      }
    }

    /// <summary>Field number for the "selection_analysis" field.</summary>
    public const int SelectionAnalysisFieldNumber = 4;
    private readonly static global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis SelectionAnalysisDefaultValue = global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis.AnalysisWithSeed;

    private global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis selectionAnalysis_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis SelectionAnalysis {
      get { if ((_hasBits0 & 1) != 0) { return selectionAnalysis_; } else { return SelectionAnalysisDefaultValue; } }
      set {
        _hasBits0 |= 1;
        selectionAnalysis_ = value;
      }
    }
    /// <summary>Gets whether the "selection_analysis" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSelectionAnalysis {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "selection_analysis" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelectionAnalysis() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "hybrid_selection_camera" field.</summary>
    public const int HybridSelectionCameraFieldNumber = 5;
    private readonly static bool HybridSelectionCameraDefaultValue = false;

    private bool hybridSelectionCamera_;
    /// <summary>
    /// If activated when SELECTION input is activated, will replace the computed
    /// camera motion (for any of the ANALYSIS_* case above) with the one supplied
    /// by the frame selection, in case the frame selection one is more stable.
    /// For example, if recomputed camera motion is unstable but the one from
    /// the selection result is stable, will use the stable result instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HybridSelectionCamera {
      get { if ((_hasBits0 & 2) != 0) { return hybridSelectionCamera_; } else { return HybridSelectionCameraDefaultValue; } }
      set {
        _hasBits0 |= 2;
        hybridSelectionCamera_ = value;
      }
    }
    /// <summary>Gets whether the "hybrid_selection_camera" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHybridSelectionCamera {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "hybrid_selection_camera" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHybridSelectionCamera() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "meta_analysis" field.</summary>
    public const int MetaAnalysisFieldNumber = 8;
    private readonly static global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis MetaAnalysisDefaultValue = global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis.UseMeta;

    private global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis metaAnalysis_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis MetaAnalysis {
      get { if ((_hasBits0 & 16) != 0) { return metaAnalysis_; } else { return MetaAnalysisDefaultValue; } }
      set {
        _hasBits0 |= 16;
        metaAnalysis_ = value;
      }
    }
    /// <summary>Gets whether the "meta_analysis" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMetaAnalysis {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "meta_analysis" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMetaAnalysis() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "meta_models_per_frame" field.</summary>
    public const int MetaModelsPerFrameFieldNumber = 6;
    private readonly static int MetaModelsPerFrameDefaultValue = 1;

    private int metaModelsPerFrame_;
    /// <summary>
    /// Determines number of homography models per frame stored in the CSV file
    /// or the homography metadata in META.
    /// For values > 1, MixtureHomographies are created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MetaModelsPerFrame {
      get { if ((_hasBits0 & 4) != 0) { return metaModelsPerFrame_; } else { return MetaModelsPerFrameDefaultValue; } }
      set {
        _hasBits0 |= 4;
        metaModelsPerFrame_ = value;
      }
    }
    /// <summary>Gets whether the "meta_models_per_frame" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMetaModelsPerFrame {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "meta_models_per_frame" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMetaModelsPerFrame() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "meta_outlier_domain_ratio" field.</summary>
    public const int MetaOutlierDomainRatioFieldNumber = 9;
    private readonly static float MetaOutlierDomainRatioDefaultValue = 0.0015F;

    private float metaOutlierDomainRatio_;
    /// <summary>
    /// Used for META_ANALYSIS_HYBRID. Rejects features which flow deviates
    /// domain_ratio * image diagonal size from the ground truth metadata motion.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MetaOutlierDomainRatio {
      get { if ((_hasBits0 & 32) != 0) { return metaOutlierDomainRatio_; } else { return MetaOutlierDomainRatioDefaultValue; } }
      set {
        _hasBits0 |= 32;
        metaOutlierDomainRatio_ = value;
      }
    }
    /// <summary>Gets whether the "meta_outlier_domain_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMetaOutlierDomainRatio {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "meta_outlier_domain_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMetaOutlierDomainRatio() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "bypass_mode" field.</summary>
    public const int BypassModeFieldNumber = 7;
    private readonly static bool BypassModeDefaultValue = false;

    private bool bypassMode_;
    /// <summary>
    /// If true, the MotionAnalysisCalculator will skip all processing and emit no
    /// packets on any output. This is useful for quickly creating different
    /// versions of a MediaPipe graph without changing its structure, assuming that
    /// downstream calculators can handle missing input packets.
    /// TODO: Remove this hack. See b/36485206 for more details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool BypassMode {
      get { if ((_hasBits0 & 8) != 0) { return bypassMode_; } else { return BypassModeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        bypassMode_ = value;
      }
    }
    /// <summary>Gets whether the "bypass_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBypassMode {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "bypass_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBypassMode() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MotionAnalysisCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MotionAnalysisCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AnalysisOptions, other.AnalysisOptions)) return false;
      if (SelectionAnalysis != other.SelectionAnalysis) return false;
      if (HybridSelectionCamera != other.HybridSelectionCamera) return false;
      if (MetaAnalysis != other.MetaAnalysis) return false;
      if (MetaModelsPerFrame != other.MetaModelsPerFrame) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MetaOutlierDomainRatio, other.MetaOutlierDomainRatio)) return false;
      if (BypassMode != other.BypassMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (analysisOptions_ != null) hash ^= AnalysisOptions.GetHashCode();
      if (HasSelectionAnalysis) hash ^= SelectionAnalysis.GetHashCode();
      if (HasHybridSelectionCamera) hash ^= HybridSelectionCamera.GetHashCode();
      if (HasMetaAnalysis) hash ^= MetaAnalysis.GetHashCode();
      if (HasMetaModelsPerFrame) hash ^= MetaModelsPerFrame.GetHashCode();
      if (HasMetaOutlierDomainRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MetaOutlierDomainRatio);
      if (HasBypassMode) hash ^= BypassMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (analysisOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AnalysisOptions);
      }
      if (HasSelectionAnalysis) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SelectionAnalysis);
      }
      if (HasHybridSelectionCamera) {
        output.WriteRawTag(40);
        output.WriteBool(HybridSelectionCamera);
      }
      if (HasMetaModelsPerFrame) {
        output.WriteRawTag(48);
        output.WriteInt32(MetaModelsPerFrame);
      }
      if (HasBypassMode) {
        output.WriteRawTag(56);
        output.WriteBool(BypassMode);
      }
      if (HasMetaAnalysis) {
        output.WriteRawTag(64);
        output.WriteEnum((int) MetaAnalysis);
      }
      if (HasMetaOutlierDomainRatio) {
        output.WriteRawTag(77);
        output.WriteFloat(MetaOutlierDomainRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (analysisOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AnalysisOptions);
      }
      if (HasSelectionAnalysis) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SelectionAnalysis);
      }
      if (HasHybridSelectionCamera) {
        output.WriteRawTag(40);
        output.WriteBool(HybridSelectionCamera);
      }
      if (HasMetaModelsPerFrame) {
        output.WriteRawTag(48);
        output.WriteInt32(MetaModelsPerFrame);
      }
      if (HasBypassMode) {
        output.WriteRawTag(56);
        output.WriteBool(BypassMode);
      }
      if (HasMetaAnalysis) {
        output.WriteRawTag(64);
        output.WriteEnum((int) MetaAnalysis);
      }
      if (HasMetaOutlierDomainRatio) {
        output.WriteRawTag(77);
        output.WriteFloat(MetaOutlierDomainRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (analysisOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AnalysisOptions);
      }
      if (HasSelectionAnalysis) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SelectionAnalysis);
      }
      if (HasHybridSelectionCamera) {
        size += 1 + 1;
      }
      if (HasMetaAnalysis) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MetaAnalysis);
      }
      if (HasMetaModelsPerFrame) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MetaModelsPerFrame);
      }
      if (HasMetaOutlierDomainRatio) {
        size += 1 + 4;
      }
      if (HasBypassMode) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MotionAnalysisCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.analysisOptions_ != null) {
        if (analysisOptions_ == null) {
          AnalysisOptions = new global::Mediapipe.MotionAnalysisOptions();
        }
        AnalysisOptions.MergeFrom(other.AnalysisOptions);
      }
      if (other.HasSelectionAnalysis) {
        SelectionAnalysis = other.SelectionAnalysis;
      }
      if (other.HasHybridSelectionCamera) {
        HybridSelectionCamera = other.HybridSelectionCamera;
      }
      if (other.HasMetaAnalysis) {
        MetaAnalysis = other.MetaAnalysis;
      }
      if (other.HasMetaModelsPerFrame) {
        MetaModelsPerFrame = other.MetaModelsPerFrame;
      }
      if (other.HasMetaOutlierDomainRatio) {
        MetaOutlierDomainRatio = other.MetaOutlierDomainRatio;
      }
      if (other.HasBypassMode) {
        BypassMode = other.BypassMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (analysisOptions_ == null) {
              AnalysisOptions = new global::Mediapipe.MotionAnalysisOptions();
            }
            input.ReadMessage(AnalysisOptions);
            break;
          }
          case 32: {
            SelectionAnalysis = (global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis) input.ReadEnum();
            break;
          }
          case 40: {
            HybridSelectionCamera = input.ReadBool();
            break;
          }
          case 48: {
            MetaModelsPerFrame = input.ReadInt32();
            break;
          }
          case 56: {
            BypassMode = input.ReadBool();
            break;
          }
          case 64: {
            MetaAnalysis = (global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis) input.ReadEnum();
            break;
          }
          case 77: {
            MetaOutlierDomainRatio = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (analysisOptions_ == null) {
              AnalysisOptions = new global::Mediapipe.MotionAnalysisOptions();
            }
            input.ReadMessage(AnalysisOptions);
            break;
          }
          case 32: {
            SelectionAnalysis = (global::Mediapipe.MotionAnalysisCalculatorOptions.Types.SelectionAnalysis) input.ReadEnum();
            break;
          }
          case 40: {
            HybridSelectionCamera = input.ReadBool();
            break;
          }
          case 48: {
            MetaModelsPerFrame = input.ReadInt32();
            break;
          }
          case 56: {
            BypassMode = input.ReadBool();
            break;
          }
          case 64: {
            MetaAnalysis = (global::Mediapipe.MotionAnalysisCalculatorOptions.Types.MetaAnalysis) input.ReadEnum();
            break;
          }
          case 77: {
            MetaOutlierDomainRatio = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the MotionAnalysisCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Determines how optional input SELECTION (if present) is used to compute
      /// the final camera motion.
      /// </summary>
      public enum SelectionAnalysis {
        /// <summary>
        /// Recompute camera motion for selected frame neighbors.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_RECOMPUTE")] AnalysisRecompute = 1,
        /// <summary>
        /// Use composited camera motion and region flow from SELECTION input. No
        /// tracking or re-computation is performed.
        /// Note that in this case only CAMERA, FLOW and VIDEO_OUT tags are
        /// supported as output.
        /// </summary>
        [pbr::OriginalName("NO_ANALYSIS_USE_SELECTION")] NoAnalysisUseSelection = 2,
        /// <summary>
        /// Recompute camera motion for selected frame neighbors using
        /// features supplied by SELECTION input. No feature tracking is performed.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_FROM_FEATURES")] AnalysisFromFeatures = 3,
        /// <summary>
        /// Recomputes camera motion for selected frame neighbors but seeds
        /// initial transform with camera motion from SELECTION input.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_WITH_SEED")] AnalysisWithSeed = 4,
      }

      /// <summary>
      /// Determines how optional input META is used to compute the final camera
      /// motion.
      /// </summary>
      public enum MetaAnalysis {
        /// <summary>
        /// Uses metadata supplied motions as is.
        /// </summary>
        [pbr::OriginalName("META_ANALYSIS_USE_META")] UseMeta = 1,
        /// <summary>
        /// Seeds visual tracking from metadata motions - estimates visual residual
        /// motion and combines with metadata.
        /// </summary>
        [pbr::OriginalName("META_ANALYSIS_HYBRID")] Hybrid = 2,
      }

    }
    #endregion

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the MotionAnalysisCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.MotionAnalysisCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.MotionAnalysisCalculatorOptions>(270698255, pb::FieldCodec.ForMessage(2165586042, global::Mediapipe.MotionAnalysisCalculatorOptions.Parser));
    }
    #endregion

  }

  /// <summary>
  /// Taken from
  /// java/com/google/android/libraries/microvideo/proto/microvideo.proto to
  /// satisfy leakr requirements
  /// TODO: Remove and use above proto.
  /// </summary>
  public sealed partial class HomographyData : pb::IMessage<HomographyData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HomographyData> _parser = new pb::MessageParser<HomographyData>(() => new HomographyData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HomographyData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.MotionAnalysisCalculatorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HomographyData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HomographyData(HomographyData other) : this() {
      _hasBits0 = other._hasBits0;
      motionHomographyData_ = other.motionHomographyData_.Clone();
      histogramCountData_ = other.histogramCountData_.Clone();
      frameWidth_ = other.frameWidth_;
      frameHeight_ = other.frameHeight_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HomographyData Clone() {
      return new HomographyData(this);
    }

    /// <summary>Field number for the "motion_homography_data" field.</summary>
    public const int MotionHomographyDataFieldNumber = 1;
    private static readonly pb::FieldCodec<float> _repeated_motionHomographyData_codec
        = pb::FieldCodec.ForFloat(10);
    private readonly pbc::RepeatedField<float> motionHomographyData_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// For each frame, there are 12 homography matrices stored. Each matrix is
    /// 3x3 (9 elements). This field will contain 12 x 3 x 3  float values. The
    /// first row of the first homography matrix will be followed by the second row
    /// of the first homography matrix, followed by third row of first homography
    /// matrix, followed by the first row of the second homography matrix, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> MotionHomographyData {
      get { return motionHomographyData_; }
    }

    /// <summary>Field number for the "histogram_count_data" field.</summary>
    public const int HistogramCountDataFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_histogramCountData_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> histogramCountData_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Vector containing histogram counts for individual patches in the frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> HistogramCountData {
      get { return histogramCountData_; }
    }

    /// <summary>Field number for the "frame_width" field.</summary>
    public const int FrameWidthFieldNumber = 3;
    private readonly static int FrameWidthDefaultValue = 0;

    private int frameWidth_;
    /// <summary>
    /// The width of the frame at the time metadata was sampled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FrameWidth {
      get { if ((_hasBits0 & 1) != 0) { return frameWidth_; } else { return FrameWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        frameWidth_ = value;
      }
    }
    /// <summary>Gets whether the "frame_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFrameWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "frame_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFrameWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "frame_height" field.</summary>
    public const int FrameHeightFieldNumber = 4;
    private readonly static int FrameHeightDefaultValue = 0;

    private int frameHeight_;
    /// <summary>
    /// The height of the frame at the time metadata was sampled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FrameHeight {
      get { if ((_hasBits0 & 2) != 0) { return frameHeight_; } else { return FrameHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        frameHeight_ = value;
      }
    }
    /// <summary>Gets whether the "frame_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFrameHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "frame_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFrameHeight() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HomographyData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HomographyData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!motionHomographyData_.Equals(other.motionHomographyData_)) return false;
      if(!histogramCountData_.Equals(other.histogramCountData_)) return false;
      if (FrameWidth != other.FrameWidth) return false;
      if (FrameHeight != other.FrameHeight) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= motionHomographyData_.GetHashCode();
      hash ^= histogramCountData_.GetHashCode();
      if (HasFrameWidth) hash ^= FrameWidth.GetHashCode();
      if (HasFrameHeight) hash ^= FrameHeight.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      motionHomographyData_.WriteTo(output, _repeated_motionHomographyData_codec);
      histogramCountData_.WriteTo(output, _repeated_histogramCountData_codec);
      if (HasFrameWidth) {
        output.WriteRawTag(24);
        output.WriteInt32(FrameWidth);
      }
      if (HasFrameHeight) {
        output.WriteRawTag(32);
        output.WriteInt32(FrameHeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      motionHomographyData_.WriteTo(ref output, _repeated_motionHomographyData_codec);
      histogramCountData_.WriteTo(ref output, _repeated_histogramCountData_codec);
      if (HasFrameWidth) {
        output.WriteRawTag(24);
        output.WriteInt32(FrameWidth);
      }
      if (HasFrameHeight) {
        output.WriteRawTag(32);
        output.WriteInt32(FrameHeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += motionHomographyData_.CalculateSize(_repeated_motionHomographyData_codec);
      size += histogramCountData_.CalculateSize(_repeated_histogramCountData_codec);
      if (HasFrameWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(FrameWidth);
      }
      if (HasFrameHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(FrameHeight);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HomographyData other) {
      if (other == null) {
        return;
      }
      motionHomographyData_.Add(other.motionHomographyData_);
      histogramCountData_.Add(other.histogramCountData_);
      if (other.HasFrameWidth) {
        FrameWidth = other.FrameWidth;
      }
      if (other.HasFrameHeight) {
        FrameHeight = other.FrameHeight;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 13: {
            motionHomographyData_.AddEntriesFrom(input, _repeated_motionHomographyData_codec);
            break;
          }
          case 18:
          case 16: {
            histogramCountData_.AddEntriesFrom(input, _repeated_histogramCountData_codec);
            break;
          }
          case 24: {
            FrameWidth = input.ReadInt32();
            break;
          }
          case 32: {
            FrameHeight = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 13: {
            motionHomographyData_.AddEntriesFrom(ref input, _repeated_motionHomographyData_codec);
            break;
          }
          case 18:
          case 16: {
            histogramCountData_.AddEntriesFrom(ref input, _repeated_histogramCountData_codec);
            break;
          }
          case 24: {
            FrameWidth = input.ReadInt32();
            break;
          }
          case 32: {
            FrameHeight = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code

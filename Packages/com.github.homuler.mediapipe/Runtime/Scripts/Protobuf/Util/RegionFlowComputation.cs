// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/util/tracking/region_flow_computation.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/util/tracking/region_flow_computation.proto</summary>
  public static partial class RegionFlowComputationReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/util/tracking/region_flow_computation.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RegionFlowComputationReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjVtZWRpYXBpcGUvdXRpbC90cmFja2luZy9yZWdpb25fZmxvd19jb21wdXRh",
            "dGlvbi5wcm90bxIJbWVkaWFwaXBlGi1tZWRpYXBpcGUvdXRpbC90cmFja2lu",
            "Zy90b25lX2VzdGltYXRpb24ucHJvdG8isBAKD1RyYWNraW5nT3B0aW9ucxJX",
            "ChtpbnRlcm5hbF90cmFja2luZ19kaXJlY3Rpb24YEyABKA4yKC5tZWRpYXBp",
            "cGUuVHJhY2tpbmdPcHRpb25zLkZsb3dEaXJlY3Rpb246CEJBQ0tXQVJEElEK",
            "FW91dHB1dF9mbG93X2RpcmVjdGlvbhgUIAEoDjIoLm1lZGlhcGlwZS5UcmFj",
            "a2luZ09wdGlvbnMuRmxvd0RpcmVjdGlvbjoIQkFDS1dBUkQSVwoPdHJhY2tp",
            "bmdfcG9saWN5GBkgASgOMikubWVkaWFwaXBlLlRyYWNraW5nT3B0aW9ucy5U",
            "cmFja2luZ1BvbGljeToTUE9MSUNZX1NJTkdMRV9GUkFNRRIgChVtdWx0aV9m",
            "cmFtZXNfdG9fdHJhY2sYASABKAU6ATESIwoWbG9uZ190cmFja3NfbWF4X2Zy",
            "YW1lcxgaIAEoBToDMzAwEhoKDG1heF9mZWF0dXJlcxgCIAEoBToEMjAwMBJr",
            "Chhjb3JuZXJfZXh0cmFjdGlvbl9tZXRob2QYGyABKA4yMS5tZWRpYXBpcGUu",
            "VHJhY2tpbmdPcHRpb25zLkNvcm5lckV4dHJhY3Rpb25NZXRob2Q6FkVYVFJB",
            "Q1RJT05fTUlOX0VJR19WQUwSVAoUbWluX2VpZ192YWxfc2V0dGluZ3MYHCAB",
            "KAsyNi5tZWRpYXBpcGUuVHJhY2tpbmdPcHRpb25zLk1pbkVpZ1ZhbEV4dHJh",
            "Y3Rpb25TZXR0aW5ncxJMCg9oYXJyaXNfc2V0dGluZ3MYHSABKAsyMy5tZWRp",
            "YXBpcGUuVHJhY2tpbmdPcHRpb25zLkhhcnJpc0V4dHJhY3Rpb25TZXR0aW5n",
            "cxJICg1mYXN0X3NldHRpbmdzGB8gASgLMjEubWVkaWFwaXBlLlRyYWNraW5n",
            "T3B0aW9ucy5GYXN0RXh0cmFjdGlvblNldHRpbmdzEiAKFHRyYWNraW5nX3dp",
            "bmRvd19zaXplGAQgASgFOgIxMBIfChN0cmFja2luZ19pdGVyYXRpb25zGAUg",
            "ASgFOgIxMBIqChxmcmFjdGlvbmFsX3RyYWNraW5nX2Rpc3RhbmNlGAYgASgC",
            "OgQwLjE1EikKGmFkYXB0aXZlX3RyYWNraW5nX2Rpc3RhbmNlGBggASgIOgVm",
            "YWxzZRIfChRtaW5fZmVhdHVyZV9kaXN0YW5jZRgHIAEoAjoBNxIlChdkaXN0",
            "YW5jZV9kb3duc2NhbGVfc3FydBgVIAEoCDoEdHJ1ZRItCh9hZGFwdGl2ZV9n",
            "b29kX2ZlYXR1cmVzX3RvX3RyYWNrGAggASgIOgR0cnVlEioKHGFkYXB0aXZl",
            "X2ZlYXR1cmVzX2Jsb2NrX3NpemUYCSABKAI6BDAuMjYSIwoYYWRhcHRpdmVf",
            "ZmVhdHVyZXNfbGV2ZWxzGAogASgFOgExEiUKGmFkYXB0aXZlX2V4dHJhY3Rp",
            "b25fbGV2ZWxzGBYgASgFOgExEjEKJmFkYXB0aXZlX2V4dHJhY3Rpb25fbGV2",
            "ZWxzX2xvd2VzdF9zaXplGBcgASgFOgEwEi0KH3N5bnRoZXRpY196ZXJvX21v",
            "dGlvbl9ncmlkX3N0ZXAYDSABKAI6BDAuMDQSJQoWd2lkZV9iYXNlbGluZV9t",
            "YXRjaGluZxgOIAEoCDoFZmFsc2USIQoUcmF0aW9fdGVzdF90aHJlc2hvbGQY",
            "DyABKAI6AzAuOBIrChxyZWZpbmVfd2lkZV9iYXNlbGluZV9tYXRjaGVzGBAg",
            "ASgIOgVmYWxzZRIsCiFyZXVzZV9mZWF0dXJlc19tYXhfZnJhbWVfZGlzdGFu",
            "Y2UYESABKAU6ATASLQogcmV1c2VfZmVhdHVyZXNfbWluX3N1cnZpdmVkX2Zy",
            "YWMYEiABKAI6AzAuNxJjChprbHRfdHJhY2tlcl9pbXBsZW1lbnRhdGlvbhgg",
            "IAEoDjIzLm1lZGlhcGlwZS5UcmFja2luZ09wdGlvbnMuS2x0VHJhY2tlcklt",
            "cGxlbWVudGF0aW9uOgpLTFRfT1BFTkNWGnAKG01pbkVpZ1ZhbEV4dHJhY3Rp",
            "b25TZXR0aW5ncxIjChVmZWF0dXJlX3F1YWxpdHlfbGV2ZWwYASABKAI6BDAu",
            "MDESLAodYWRhcHRpdmVfbG93ZXN0X3F1YWxpdHlfbGV2ZWwYAiABKAI6BThl",
            "LTA1GkIKGEhhcnJpc0V4dHJhY3Rpb25TZXR0aW5ncxImChVmZWF0dXJlX3F1",
            "YWxpdHlfbGV2ZWwYASABKAI6BzAuMDAwMjUaLwoWRmFzdEV4dHJhY3Rpb25T",
            "ZXR0aW5ncxIVCgl0aHJlc2hvbGQYASABKAU6AjEwIj0KDUZsb3dEaXJlY3Rp",
            "b24SCwoHRk9SV0FSRBABEgwKCEJBQ0tXQVJEEAISEQoNQ09OU0VDVVRJVkVM",
            "WRADIlkKDlRyYWNraW5nUG9saWN5EhcKE1BPTElDWV9TSU5HTEVfRlJBTUUQ",
            "ARIWChJQT0xJQ1lfTVVMVElfRlJBTUUQAhIWChJQT0xJQ1lfTE9OR19UUkFD",
            "S1MQAyJgChZDb3JuZXJFeHRyYWN0aW9uTWV0aG9kEhUKEUVYVFJBQ1RJT05f",
            "SEFSUklTEAESGgoWRVhUUkFDVElPTl9NSU5fRUlHX1ZBTBACEhMKD0VYVFJB",
            "Q1RJT05fRkFTVBADIjsKGEtsdFRyYWNrZXJJbXBsZW1lbnRhdGlvbhIPCgtV",
            "TlNQRUNJRklFRBAAEg4KCktMVF9PUEVOQ1YQASoECAMQBCoECAsQDCoECAwQ",
            "DSoECB4QHyLnHAocUmVnaW9uRmxvd0NvbXB1dGF0aW9uT3B0aW9ucxI0ChB0",
            "cmFja2luZ19vcHRpb25zGAEgASgLMhoubWVkaWFwaXBlLlRyYWNraW5nT3B0",
            "aW9ucxIeChNtaW5fZmVhdHVyZV9pbmxpZXJzGAIgASgFOgEzEikKHHJlbGF0",
            "aXZlX21pbl9mZWF0dXJlX2lubGllcnMYLiABKAI6AzAuMhIbCg5wcmVfYmx1",
            "cl9zaWdtYRghIAEoAjoDMC44EiQKGHJhbnNhY19yb3VuZHNfcGVyX3JlZ2lv",
            "bhgDIAEoBToCMTUSKgofYWJzb2x1dGVfaW5saWVyX2Vycm9yX3RocmVzaG9s",
            "ZBgEIAEoAjoBMhImChtmcmFjX2lubGllcl9lcnJvcl90aHJlc2hvbGQYNCAB",
            "KAI6ATASLAofcmVsYXRpdmVfaW5saWVyX2Vycm9yX3RocmVzaG9sZBgsIAEo",
            "AjoDMC4xEhoKD3RvcF9pbmxpZXJfc2V0cxgtIAEoBToBMhIhChJub19lc3Rp",
            "bWF0aW9uX21vZGUYKCABKAg6BWZhbHNlEigKGmZhc3RfZXN0aW1hdGlvbl9i",
            "bG9ja19zaXplGAYgASgCOgQwLjI1EisKHmZhc3RfZXN0aW1hdGlvbl9taW5f",
            "YmxvY2tfc2l6ZRgZIAEoBToDMTAwEigKHWZhc3RfZXN0aW1hdGlvbl9vdmVy",
            "bGFwX2dyaWRzGBYgASgFOgEzEioKHW1heF9tYWduaXR1ZGVfdGhyZXNob2xk",
            "X3JhdGlvGBcgASgCOgMwLjISIgoXbWVkaWFuX21hZ25pdHVkZV9ib3VuZHMY",
            "MyABKAI6ATASaQoTaXJsc19pbml0aWFsaXphdGlvbhgxIAEoDjI6Lm1lZGlh",
            "cGlwZS5SZWdpb25GbG93Q29tcHV0YXRpb25PcHRpb25zLklybHNJbml0aWFs",
            "aXphdGlvbjoQSU5JVF9DT05TSVNURU5DWRJgCg9kb3duc2FtcGxlX21vZGUY",
            "CyABKA4yNi5tZWRpYXBpcGUuUmVnaW9uRmxvd0NvbXB1dGF0aW9uT3B0aW9u",
            "cy5Eb3duc2FtcGxlTW9kZToPRE9XTlNBTVBMRV9OT05FEh4KEWRvd25zYW1w",
            "bGluZ19zaXplGAwgASgFOgMyNTYSHAoRZG93bnNhbXBsZV9mYWN0b3IYEiAB",
            "KAI6ATISJgoXcm91bmRfZG93bnNhbXBsZV9mYWN0b3IYPiABKAg6BWZhbHNl",
            "ElcKE2Rvd25zYW1wbGVfc2NoZWR1bGUYEyABKAsyOi5tZWRpYXBpcGUuUmVn",
            "aW9uRmxvd0NvbXB1dGF0aW9uT3B0aW9ucy5Eb3duU2FtcGxlU2NoZWR1bGUS",
            "IwoXbWluX2ZlYXR1cmVfcmVxdWlyZW1lbnQYDSABKAU6AjIwEh8KEW1pbl9m",
            "ZWF0dXJlX2NvdmVyGA4gASgCOgQwLjE1EiEKFm1pbl9mZWF0dXJlX2NvdmVy",
            "X2dyaWQYFCABKAU6ATgSIQoSY29tcHV0ZV9ibHVyX3Njb3JlGBEgASgIOgVm",
            "YWxzZRJUChJibHVyX3Njb3JlX29wdGlvbnMYHyABKAsyOC5tZWRpYXBpcGUu",
            "UmVnaW9uRmxvd0NvbXB1dGF0aW9uT3B0aW9ucy5CbHVyU2NvcmVPcHRpb25z",
            "EmQKGnZpc3VhbF9jb25zaXN0ZW5jeV9vcHRpb25zGDcgASgLMkAubWVkaWFw",
            "aXBlLlJlZ2lvbkZsb3dDb21wdXRhdGlvbk9wdGlvbnMuVmlzdWFsQ29uc2lz",
            "dGVuY3lPcHRpb25zEiIKF3BhdGNoX2Rlc2NyaXB0b3JfcmFkaXVzGBUgASgF",
            "OgEzEh8KFGRpc3RhbmNlX2Zyb21fYm9yZGVyGDIgASgFOgEzEiMKFWNvcm5l",
            "cl9yZXNwb25zZV9zY2FsZRgaIAEoAjoEMTUwMBIeCg92ZXJpZnlfZmVhdHVy",
            "ZXMYGyABKAg6BWZhbHNlEiIKFXZlcmlmaWNhdGlvbl9kaXN0YW5jZRgcIAEo",
            "AjoDMC41EiIKFHZlcmlmeV9sb25nX2ZlYXR1cmVzGDUgASgIOgR0cnVlEjEK",
            "I2xvbmdfZmVhdHVyZV92ZXJpZmljYXRpb25fdGhyZXNob2xkGDYgASgCOgQw",
            "LjA0EigKHW1heF9sb25nX2ZlYXR1cmVfYWNjZWxlcmF0aW9uGDggASgCOgE1",
            "Ei8KIHZlcmlmeV9sb25nX2ZlYXR1cmVfYWNjZWxlcmF0aW9uGD8gASgIOgVm",
            "YWxzZRIsCiF2ZXJpZnlfbG9uZ19mZWF0dXJlX3RyaWdnZXJfcmF0aW8YQCAB",
            "KAI6ATASJQoWaGlzdG9ncmFtX2VxdWFsaXphdGlvbhg5IAEoCDoFZmFsc2US",
            "OgordXNlX3N5bnRoZXRpY196ZXJvX21vdGlvbl90cmFja3NfYWxsX2ZyYW1l",
            "cxgiIAEoCDoFZmFsc2USOwosdXNlX3N5bnRoZXRpY196ZXJvX21vdGlvbl90",
            "cmFja3NfZmlyc3RfZnJhbWUYIyABKAg6BWZhbHNlEh4KD2dhaW5fY29ycmVj",
            "dGlvbhgkIAEoCDoFZmFsc2USIwoUZmFzdF9nYWluX2NvcnJlY3Rpb24YPSAB",
            "KAg6BWZhbHNlEjEKI2dhaW5fY29ycmVjdGlvbl9tdWx0aXBsZV9oeXBvdGhl",
            "c2VzGC8gASgIOgR0cnVlEjQKJ2dhaW5fY29ycmVjdGlvbl9pbmxpZXJfaW1w",
            "cm92ZW1lbnRfZnJhYxgwIAEoAjoDMC4xEi8KIGdhaW5fY29ycmVjdGlvbl9i",
            "cmlnaHRfcmVmZXJlbmNlGDsgASgIOgVmYWxzZRIrCiBnYWluX2NvcnJlY3Rp",
            "b25fdHJpZ2dlcmluZ19yYXRpbxg8IAEoAjoBMBIjChZmcmFjX2dhaW5fZmVh",
            "dHVyZV9zaXplGCUgASgCOgMwLjMSGwoOZnJhY19nYWluX3N0ZXAYJiABKAI6",
            "AzAuMRJtChFnYWluX2NvcnJlY3RfbW9kZRgpIAEoDjI3Lm1lZGlhcGlwZS5S",
            "ZWdpb25GbG93Q29tcHV0YXRpb25PcHRpb25zLkdhaW5Db3JyZWN0TW9kZToZ",
            "R0FJTl9DT1JSRUNUX0RFRkFVTFRfVVNFUhJJChBnYWluX2JpYXNfYm91bmRz",
            "GCcgASgLMi8ubWVkaWFwaXBlLlRvbmVFc3RpbWF0aW9uT3B0aW9ucy5HYWlu",
            "Qmlhc0JvdW5kcxJVCgxpbWFnZV9mb3JtYXQYOiABKA4yMy5tZWRpYXBpcGUu",
            "UmVnaW9uRmxvd0NvbXB1dGF0aW9uT3B0aW9ucy5JbWFnZUZvcm1hdDoKRk9S",
            "TUFUX1JHQhJnChlkZXNjcmlwdG9yX2V4dHJhY3Rvcl90eXBlGEEgASgOMj8u",
            "bWVkaWFwaXBlLlJlZ2lvbkZsb3dDb21wdXRhdGlvbk9wdGlvbnMuRGVzY3Jp",
            "cHRvckV4dHJhY3RvclR5cGU6A09SQhIrCh1jb21wdXRlX2Rlcml2YXRpdmVf",
            "aW5fcHlyYW1pZBhCIAEoCDoEdHJ1ZRqhAQoSRG93blNhbXBsZVNjaGVkdWxl",
            "EiEKFmRvd25zYW1wbGVfZmFjdG9yXzM2MHAYASABKAI6ATESIQoWZG93bnNh",
            "bXBsZV9mYWN0b3JfNDgwcBgCIAEoAjoBMRIhChZkb3duc2FtcGxlX2ZhY3Rv",
            "cl83MjBwGAMgASgCOgEyEiIKF2Rvd25zYW1wbGVfZmFjdG9yXzEwODBwGAQg",
            "ASgCOgEyGqsBChBCbHVyU2NvcmVPcHRpb25zEhoKD2JveF9maWx0ZXJfZGlh",
            "bRgBIAEoBToBMxIrCh1yZWxhdGl2ZV9jb3JuZXJuZXNzX3RocmVzaG9sZBgC",
            "IAEoAjoEMC4wMxItCh1hYnNvbHV0ZV9jb3JuZXJuZXNzX3RocmVzaG9sZBgD",
            "IAEoAjoGMC4wMDAxEh8KEW1lZGlhbl9wZXJjZW50aWxlGAUgASgCOgQwLjg1",
            "Gl8KGFZpc3VhbENvbnNpc3RlbmN5T3B0aW9ucxIhChNjb21wdXRlX2NvbnNp",
            "c3RlbmN5GAEgASgIOgR0cnVlEiAKFHRpbnlfaW1hZ2VfZGltZW5zaW9uGAIg",
            "ASgFOgIyMCI8ChJJcmxzSW5pdGlhbGl6YXRpb24SEAoMSU5JVF9VTklGT1JN",
            "EAESFAoQSU5JVF9DT05TSVNURU5DWRACIrEBCg5Eb3duc2FtcGxlTW9kZRIT",
            "Cg9ET1dOU0FNUExFX05PTkUQARIaChZET1dOU0FNUExFX1RPX01BWF9TSVpF",
            "EAISGAoURE9XTlNBTVBMRV9CWV9GQUNUT1IQAxIaChZET1dOU0FNUExFX0JZ",
            "X1NDSEVEVUxFEAQSGgoWRE9XTlNBTVBMRV9UT19NSU5fU0laRRAFEhwKGERP",
            "V05TQU1QTEVfVE9fSU5QVVRfU0laRRAGInwKD0dhaW5Db3JyZWN0TW9kZRId",
            "ChlHQUlOX0NPUlJFQ1RfREVGQVVMVF9VU0VSEAESFgoSR0FJTl9DT1JSRUNU",
            "X1ZJREVPEAISFAoQR0FJTl9DT1JSRUNUX0hEUhADEhwKGEdBSU5fQ09SUkVD",
            "VF9QSE9UT19CVVJTVBAEImUKC0ltYWdlRm9ybWF0EhQKEEZPUk1BVF9HUkFZ",
            "U0NBTEUQARIOCgpGT1JNQVRfUkdCEAISDwoLRk9STUFUX1JHQkEQAxIOCgpG",
            "T1JNQVRfQkdSEAQSDwoLRk9STUFUX0JHUkEQBSIiChdEZXNjcmlwdG9yRXh0",
            "cmFjdG9yVHlwZRIHCgNPUkIQACoECAUQBioECAcQCCoECAgQCSoECAkQCioE",
            "CAoQCyoECA8QECoECBAQESoECBgQGSoECB0QHioECB4QHyoECCAQISoECCoQ",
            "KyoECCsQLA=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.ToneEstimationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TrackingOptions), global::Mediapipe.TrackingOptions.Parser, new[]{ "InternalTrackingDirection", "OutputFlowDirection", "TrackingPolicy", "MultiFramesToTrack", "LongTracksMaxFrames", "MaxFeatures", "CornerExtractionMethod", "MinEigValSettings", "HarrisSettings", "FastSettings", "TrackingWindowSize", "TrackingIterations", "FractionalTrackingDistance", "AdaptiveTrackingDistance", "MinFeatureDistance", "DistanceDownscaleSqrt", "AdaptiveGoodFeaturesToTrack", "AdaptiveFeaturesBlockSize", "AdaptiveFeaturesLevels", "AdaptiveExtractionLevels", "AdaptiveExtractionLevelsLowestSize", "SyntheticZeroMotionGridStep", "WideBaselineMatching", "RatioTestThreshold", "RefineWideBaselineMatches", "ReuseFeaturesMaxFrameDistance", "ReuseFeaturesMinSurvivedFrac", "KltTrackerImplementation" }, null, new[]{ typeof(global::Mediapipe.TrackingOptions.Types.FlowDirection), typeof(global::Mediapipe.TrackingOptions.Types.TrackingPolicy), typeof(global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod), typeof(global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings), global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings.Parser, new[]{ "FeatureQualityLevel", "AdaptiveLowestQualityLevel" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings), global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings.Parser, new[]{ "FeatureQualityLevel" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.TrackingOptions.Types.FastExtractionSettings), global::Mediapipe.TrackingOptions.Types.FastExtractionSettings.Parser, new[]{ "Threshold" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.RegionFlowComputationOptions), global::Mediapipe.RegionFlowComputationOptions.Parser, new[]{ "TrackingOptions", "MinFeatureInliers", "RelativeMinFeatureInliers", "PreBlurSigma", "RansacRoundsPerRegion", "AbsoluteInlierErrorThreshold", "FracInlierErrorThreshold", "RelativeInlierErrorThreshold", "TopInlierSets", "NoEstimationMode", "FastEstimationBlockSize", "FastEstimationMinBlockSize", "FastEstimationOverlapGrids", "MaxMagnitudeThresholdRatio", "MedianMagnitudeBounds", "IrlsInitialization", "DownsampleMode", "DownsamplingSize", "DownsampleFactor", "RoundDownsampleFactor", "DownsampleSchedule", "MinFeatureRequirement", "MinFeatureCover", "MinFeatureCoverGrid", "ComputeBlurScore", "BlurScoreOptions", "VisualConsistencyOptions", "PatchDescriptorRadius", "DistanceFromBorder", "CornerResponseScale", "VerifyFeatures", "VerificationDistance", "VerifyLongFeatures", "LongFeatureVerificationThreshold", "MaxLongFeatureAcceleration", "VerifyLongFeatureAcceleration", "VerifyLongFeatureTriggerRatio", "HistogramEqualization", "UseSyntheticZeroMotionTracksAllFrames", "UseSyntheticZeroMotionTracksFirstFrame", "GainCorrection", "FastGainCorrection", "GainCorrectionMultipleHypotheses", "GainCorrectionInlierImprovementFrac", "GainCorrectionBrightReference", "GainCorrectionTriggeringRatio", "FracGainFeatureSize", "FracGainStep", "GainCorrectMode", "GainBiasBounds", "ImageFormat", "DescriptorExtractorType", "ComputeDerivativeInPyramid" }, null, new[]{ typeof(global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization), typeof(global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode), typeof(global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode), typeof(global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat), typeof(global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule), global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule.Parser, new[]{ "DownsampleFactor360P", "DownsampleFactor480P", "DownsampleFactor720P", "DownsampleFactor1080P" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions), global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions.Parser, new[]{ "BoxFilterDiam", "RelativeCornernessThreshold", "AbsoluteCornernessThreshold", "MedianPercentile" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions), global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions.Parser, new[]{ "ComputeConsistency", "TinyImageDimension" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Next tag: 33
  /// </summary>
  public sealed partial class TrackingOptions : pb::IExtendableMessage<TrackingOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TrackingOptions> _parser = new pb::MessageParser<TrackingOptions>(() => new TrackingOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TrackingOptions> _extensions;
    private pb::ExtensionSet<TrackingOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TrackingOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.RegionFlowComputationReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackingOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackingOptions(TrackingOptions other) : this() {
      _hasBits0 = other._hasBits0;
      internalTrackingDirection_ = other.internalTrackingDirection_;
      outputFlowDirection_ = other.outputFlowDirection_;
      trackingPolicy_ = other.trackingPolicy_;
      multiFramesToTrack_ = other.multiFramesToTrack_;
      longTracksMaxFrames_ = other.longTracksMaxFrames_;
      maxFeatures_ = other.maxFeatures_;
      cornerExtractionMethod_ = other.cornerExtractionMethod_;
      minEigValSettings_ = other.minEigValSettings_ != null ? other.minEigValSettings_.Clone() : null;
      harrisSettings_ = other.harrisSettings_ != null ? other.harrisSettings_.Clone() : null;
      fastSettings_ = other.fastSettings_ != null ? other.fastSettings_.Clone() : null;
      trackingWindowSize_ = other.trackingWindowSize_;
      trackingIterations_ = other.trackingIterations_;
      fractionalTrackingDistance_ = other.fractionalTrackingDistance_;
      adaptiveTrackingDistance_ = other.adaptiveTrackingDistance_;
      minFeatureDistance_ = other.minFeatureDistance_;
      distanceDownscaleSqrt_ = other.distanceDownscaleSqrt_;
      adaptiveGoodFeaturesToTrack_ = other.adaptiveGoodFeaturesToTrack_;
      adaptiveFeaturesBlockSize_ = other.adaptiveFeaturesBlockSize_;
      adaptiveFeaturesLevels_ = other.adaptiveFeaturesLevels_;
      adaptiveExtractionLevels_ = other.adaptiveExtractionLevels_;
      adaptiveExtractionLevelsLowestSize_ = other.adaptiveExtractionLevelsLowestSize_;
      syntheticZeroMotionGridStep_ = other.syntheticZeroMotionGridStep_;
      wideBaselineMatching_ = other.wideBaselineMatching_;
      ratioTestThreshold_ = other.ratioTestThreshold_;
      refineWideBaselineMatches_ = other.refineWideBaselineMatches_;
      reuseFeaturesMaxFrameDistance_ = other.reuseFeaturesMaxFrameDistance_;
      reuseFeaturesMinSurvivedFrac_ = other.reuseFeaturesMinSurvivedFrac_;
      kltTrackerImplementation_ = other.kltTrackerImplementation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackingOptions Clone() {
      return new TrackingOptions(this);
    }

    /// <summary>Field number for the "internal_tracking_direction" field.</summary>
    public const int InternalTrackingDirectionFieldNumber = 19;
    private readonly static global::Mediapipe.TrackingOptions.Types.FlowDirection InternalTrackingDirectionDefaultValue = global::Mediapipe.TrackingOptions.Types.FlowDirection.Backward;

    private global::Mediapipe.TrackingOptions.Types.FlowDirection internalTrackingDirection_;
    /// <summary>
    /// Flow direction used internally during tracking features. Forward tracking
    /// allows reusing tracked features instead of explicitly tracking them in
    /// every frame, and can therefore be faster. See the reuse_features_XXX
    /// options below. However, if not reusing features, then it is best to match
    /// the direction for both internal tracking and output flow, for peformance
    /// reasons.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.FlowDirection InternalTrackingDirection {
      get { if ((_hasBits0 & 32768) != 0) { return internalTrackingDirection_; } else { return InternalTrackingDirectionDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        internalTrackingDirection_ = value;
      }
    }
    /// <summary>Gets whether the "internal_tracking_direction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInternalTrackingDirection {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "internal_tracking_direction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInternalTrackingDirection() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "output_flow_direction" field.</summary>
    public const int OutputFlowDirectionFieldNumber = 20;
    private readonly static global::Mediapipe.TrackingOptions.Types.FlowDirection OutputFlowDirectionDefaultValue = global::Mediapipe.TrackingOptions.Types.FlowDirection.Backward;

    private global::Mediapipe.TrackingOptions.Types.FlowDirection outputFlowDirection_;
    /// <summary>
    /// Direction of flow vectors that are computed and output by calls to retrieve
    /// region flow, tracked features, etc. Note when this is BACKWARD, then the
    /// returned flow for frame N contains features tracked *from* frame N to a
    /// previous frame N-k. When this is FORWARD, the flow for frame N contains
    /// the flow from features in a previous frame N-k, tracked *to* frame N.
    /// Note that the output flow direction can only be set to FORWARD or BACKWARD.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.FlowDirection OutputFlowDirection {
      get { if ((_hasBits0 & 65536) != 0) { return outputFlowDirection_; } else { return OutputFlowDirectionDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        outputFlowDirection_ = value;
      }
    }
    /// <summary>Gets whether the "output_flow_direction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutputFlowDirection {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "output_flow_direction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutputFlowDirection() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "tracking_policy" field.</summary>
    public const int TrackingPolicyFieldNumber = 25;
    private readonly static global::Mediapipe.TrackingOptions.Types.TrackingPolicy TrackingPolicyDefaultValue = global::Mediapipe.TrackingOptions.Types.TrackingPolicy.PolicySingleFrame;

    private global::Mediapipe.TrackingOptions.Types.TrackingPolicy trackingPolicy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.TrackingPolicy TrackingPolicy {
      get { if ((_hasBits0 & 2097152) != 0) { return trackingPolicy_; } else { return TrackingPolicyDefaultValue; } }
      set {
        _hasBits0 |= 2097152;
        trackingPolicy_ = value;
      }
    }
    /// <summary>Gets whether the "tracking_policy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackingPolicy {
      get { return (_hasBits0 & 2097152) != 0; }
    }
    /// <summary>Clears the value of the "tracking_policy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackingPolicy() {
      _hasBits0 &= ~2097152;
    }

    /// <summary>Field number for the "multi_frames_to_track" field.</summary>
    public const int MultiFramesToTrackFieldNumber = 1;
    private readonly static int MultiFramesToTrackDefaultValue = 1;

    private int multiFramesToTrack_;
    /// <summary>
    /// Number of frame-pairs used for POLICY_MULTI_FRAME, ignored for other
    /// policies.
    /// Value of 1 means we are tracking features in the current frame, w.r.t.
    /// the previous one. Value of 2 denotes tracking of features in current
    /// w.r.t the previous one and the one before the previous one, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MultiFramesToTrack {
      get { if ((_hasBits0 & 1) != 0) { return multiFramesToTrack_; } else { return MultiFramesToTrackDefaultValue; } }
      set {
        _hasBits0 |= 1;
        multiFramesToTrack_ = value;
      }
    }
    /// <summary>Gets whether the "multi_frames_to_track" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMultiFramesToTrack {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "multi_frames_to_track" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMultiFramesToTrack() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "long_tracks_max_frames" field.</summary>
    public const int LongTracksMaxFramesFieldNumber = 26;
    private readonly static int LongTracksMaxFramesDefaultValue = 300;

    private int longTracksMaxFrames_;
    /// <summary>
    /// Maximum length of long feature tracks for POLICY_LONG_TRACKS in frames.
    /// Note: This maximum is not hard enforced, to avoid that many long
    /// tracks are dropped at the same time. Instead if a feature reaches
    /// long_tracks_max_frames * 0.8, it will get dropped with a probability of X,
    /// where X is calculated, such that 95% of all qualifying features are
    /// dropped within the interval [.8, 1.2] * long_tracks_max_frames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int LongTracksMaxFrames {
      get { if ((_hasBits0 & 4194304) != 0) { return longTracksMaxFrames_; } else { return LongTracksMaxFramesDefaultValue; } }
      set {
        _hasBits0 |= 4194304;
        longTracksMaxFrames_ = value;
      }
    }
    /// <summary>Gets whether the "long_tracks_max_frames" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLongTracksMaxFrames {
      get { return (_hasBits0 & 4194304) != 0; }
    }
    /// <summary>Clears the value of the "long_tracks_max_frames" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLongTracksMaxFrames() {
      _hasBits0 &= ~4194304;
    }

    /// <summary>Field number for the "max_features" field.</summary>
    public const int MaxFeaturesFieldNumber = 2;
    private readonly static int MaxFeaturesDefaultValue = 2000;

    private int maxFeatures_;
    /// <summary>
    /// Hard limit of maximum number of features. Control density of features, with
    /// min_feature_distance option. This limit is to guarantee that the
    /// run-time of RegionFlowComputation does not spiral out of control.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxFeatures {
      get { if ((_hasBits0 & 2) != 0) { return maxFeatures_; } else { return MaxFeaturesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        maxFeatures_ = value;
      }
    }
    /// <summary>Gets whether the "max_features" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxFeatures {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "max_features" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxFeatures() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "corner_extraction_method" field.</summary>
    public const int CornerExtractionMethodFieldNumber = 27;
    private readonly static global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod CornerExtractionMethodDefaultValue = global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod.ExtractionMinEigVal;

    private global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod cornerExtractionMethod_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod CornerExtractionMethod {
      get { if ((_hasBits0 & 8388608) != 0) { return cornerExtractionMethod_; } else { return CornerExtractionMethodDefaultValue; } }
      set {
        _hasBits0 |= 8388608;
        cornerExtractionMethod_ = value;
      }
    }
    /// <summary>Gets whether the "corner_extraction_method" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCornerExtractionMethod {
      get { return (_hasBits0 & 8388608) != 0; }
    }
    /// <summary>Clears the value of the "corner_extraction_method" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCornerExtractionMethod() {
      _hasBits0 &= ~8388608;
    }

    /// <summary>Field number for the "min_eig_val_settings" field.</summary>
    public const int MinEigValSettingsFieldNumber = 28;
    private global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings minEigValSettings_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings MinEigValSettings {
      get { return minEigValSettings_; }
      set {
        minEigValSettings_ = value;
      }
    }

    /// <summary>Field number for the "harris_settings" field.</summary>
    public const int HarrisSettingsFieldNumber = 29;
    private global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings harrisSettings_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings HarrisSettings {
      get { return harrisSettings_; }
      set {
        harrisSettings_ = value;
      }
    }

    /// <summary>Field number for the "fast_settings" field.</summary>
    public const int FastSettingsFieldNumber = 31;
    private global::Mediapipe.TrackingOptions.Types.FastExtractionSettings fastSettings_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.FastExtractionSettings FastSettings {
      get { return fastSettings_; }
      set {
        fastSettings_ = value;
      }
    }

    /// <summary>Field number for the "tracking_window_size" field.</summary>
    public const int TrackingWindowSizeFieldNumber = 4;
    private readonly static int TrackingWindowSizeDefaultValue = 10;

    private int trackingWindowSize_;
    /// <summary>
    /// Radius of the window size so that the full window is
    /// 2*tracking_window_size+1
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TrackingWindowSize {
      get { if ((_hasBits0 & 4) != 0) { return trackingWindowSize_; } else { return TrackingWindowSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        trackingWindowSize_ = value;
      }
    }
    /// <summary>Gets whether the "tracking_window_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackingWindowSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tracking_window_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackingWindowSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "tracking_iterations" field.</summary>
    public const int TrackingIterationsFieldNumber = 5;
    private readonly static int TrackingIterationsDefaultValue = 10;

    private int trackingIterations_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TrackingIterations {
      get { if ((_hasBits0 & 8) != 0) { return trackingIterations_; } else { return TrackingIterationsDefaultValue; } }
      set {
        _hasBits0 |= 8;
        trackingIterations_ = value;
      }
    }
    /// <summary>Gets whether the "tracking_iterations" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackingIterations {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "tracking_iterations" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackingIterations() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "fractional_tracking_distance" field.</summary>
    public const int FractionalTrackingDistanceFieldNumber = 6;
    private readonly static float FractionalTrackingDistanceDefaultValue = 0.15F;

    private float fractionalTrackingDistance_;
    /// <summary>
    /// Fractional tracking distance w.r.t. to frame diameter d. The number of
    /// pyramid levels l is chosen such that
    /// 2^l * tracking_window_size / 2 >= fractional_tracking_distance * d.
    /// Therefore, theoretically it is guaranteed that objects moving less than
    /// fractional_tracking_distance * d can be tracked.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FractionalTrackingDistance {
      get { if ((_hasBits0 & 16) != 0) { return fractionalTrackingDistance_; } else { return FractionalTrackingDistanceDefaultValue; } }
      set {
        _hasBits0 |= 16;
        fractionalTrackingDistance_ = value;
      }
    }
    /// <summary>Gets whether the "fractional_tracking_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFractionalTrackingDistance {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "fractional_tracking_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFractionalTrackingDistance() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "adaptive_tracking_distance" field.</summary>
    public const int AdaptiveTrackingDistanceFieldNumber = 24;
    private readonly static bool AdaptiveTrackingDistanceDefaultValue = false;

    private bool adaptiveTrackingDistance_;
    /// <summary>
    /// If set, modifies tracking distance to be 130% of maximum average
    /// tracking distances of previous frames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AdaptiveTrackingDistance {
      get { if ((_hasBits0 & 1048576) != 0) { return adaptiveTrackingDistance_; } else { return AdaptiveTrackingDistanceDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        adaptiveTrackingDistance_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_tracking_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveTrackingDistance {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_tracking_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveTrackingDistance() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "min_feature_distance" field.</summary>
    public const int MinFeatureDistanceFieldNumber = 7;
    private readonly static float MinFeatureDistanceDefaultValue = 7F;

    private float minFeatureDistance_;
    /// <summary>
    /// Minimum feature distance in pixels. Close features are suppressed. If value
    /// &lt; 1, the distance is computed as a fraction of the frame diameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinFeatureDistance {
      get { if ((_hasBits0 & 32) != 0) { return minFeatureDistance_; } else { return MinFeatureDistanceDefaultValue; } }
      set {
        _hasBits0 |= 32;
        minFeatureDistance_ = value;
      }
    }
    /// <summary>Gets whether the "min_feature_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatureDistance {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "min_feature_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatureDistance() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "distance_downscale_sqrt" field.</summary>
    public const int DistanceDownscaleSqrtFieldNumber = 21;
    private readonly static bool DistanceDownscaleSqrtDefaultValue = true;

    private bool distanceDownscaleSqrt_;
    /// <summary>
    /// By default, when downscaling by factor x, the minimum feature distance
    /// is downscaled by a factor of sqrt(x). If set false, no scaling is
    /// performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DistanceDownscaleSqrt {
      get { if ((_hasBits0 & 131072) != 0) { return distanceDownscaleSqrt_; } else { return DistanceDownscaleSqrtDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        distanceDownscaleSqrt_ = value;
      }
    }
    /// <summary>Gets whether the "distance_downscale_sqrt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDistanceDownscaleSqrt {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "distance_downscale_sqrt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDistanceDownscaleSqrt() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "adaptive_good_features_to_track" field.</summary>
    public const int AdaptiveGoodFeaturesToTrackFieldNumber = 8;
    private readonly static bool AdaptiveGoodFeaturesToTrackDefaultValue = true;

    private bool adaptiveGoodFeaturesToTrack_;
    /// <summary>
    /// Uses grid based extraction of features. Quality level is local within a
    /// grid cell and results are combined over all cells and multiple scales and
    /// grid offsets.
    /// Default option, setting it to false is deprecated and will fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AdaptiveGoodFeaturesToTrack {
      get { if ((_hasBits0 & 64) != 0) { return adaptiveGoodFeaturesToTrack_; } else { return AdaptiveGoodFeaturesToTrackDefaultValue; } }
      set {
        _hasBits0 |= 64;
        adaptiveGoodFeaturesToTrack_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_good_features_to_track" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveGoodFeaturesToTrack {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_good_features_to_track" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveGoodFeaturesToTrack() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "adaptive_features_block_size" field.</summary>
    public const int AdaptiveFeaturesBlockSizeFieldNumber = 9;
    private readonly static float AdaptiveFeaturesBlockSizeDefaultValue = 0.26F;

    private float adaptiveFeaturesBlockSize_;
    /// <summary>
    /// Size of each grid cell. Values &lt; 1 are interpreted to be relative to
    /// frame_width_ x frame_height_.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AdaptiveFeaturesBlockSize {
      get { if ((_hasBits0 & 128) != 0) { return adaptiveFeaturesBlockSize_; } else { return AdaptiveFeaturesBlockSizeDefaultValue; } }
      set {
        _hasBits0 |= 128;
        adaptiveFeaturesBlockSize_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_features_block_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveFeaturesBlockSize {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_features_block_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveFeaturesBlockSize() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "adaptive_features_levels" field.</summary>
    public const int AdaptiveFeaturesLevelsFieldNumber = 10;
    private readonly static int AdaptiveFeaturesLevelsDefaultValue = 1;

    private int adaptiveFeaturesLevels_;
    /// <summary>
    /// Scales / levels employed for feature extraction. Grid cell size is scaled
    /// by 0.5 for each level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AdaptiveFeaturesLevels {
      get { if ((_hasBits0 & 256) != 0) { return adaptiveFeaturesLevels_; } else { return AdaptiveFeaturesLevelsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        adaptiveFeaturesLevels_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_features_levels" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveFeaturesLevels {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_features_levels" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveFeaturesLevels() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "adaptive_extraction_levels" field.</summary>
    public const int AdaptiveExtractionLevelsFieldNumber = 22;
    private readonly static int AdaptiveExtractionLevelsDefaultValue = 1;

    private int adaptiveExtractionLevels_;
    /// <summary>
    /// If > 1, feature extraction is carried out at multiple scales by downscaling
    /// the image repeatedly, extracting features (eigenvalue images) and upscaling
    /// them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AdaptiveExtractionLevels {
      get { if ((_hasBits0 & 262144) != 0) { return adaptiveExtractionLevels_; } else { return AdaptiveExtractionLevelsDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        adaptiveExtractionLevels_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_extraction_levels" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveExtractionLevels {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_extraction_levels" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveExtractionLevels() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "adaptive_extraction_levels_lowest_size" field.</summary>
    public const int AdaptiveExtractionLevelsLowestSizeFieldNumber = 23;
    private readonly static int AdaptiveExtractionLevelsLowestSizeDefaultValue = 0;

    private int adaptiveExtractionLevelsLowestSize_;
    /// <summary>
    /// Alternate way of specifying extraction levels: number of levels is
    /// automatically computed by downsampling the image until its maximum
    /// dimension (width or height) reaches this value. Overrides
    /// adaptive_extraction_levels if > 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AdaptiveExtractionLevelsLowestSize {
      get { if ((_hasBits0 & 524288) != 0) { return adaptiveExtractionLevelsLowestSize_; } else { return AdaptiveExtractionLevelsLowestSizeDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        adaptiveExtractionLevelsLowestSize_ = value;
      }
    }
    /// <summary>Gets whether the "adaptive_extraction_levels_lowest_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAdaptiveExtractionLevelsLowestSize {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "adaptive_extraction_levels_lowest_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAdaptiveExtractionLevelsLowestSize() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "synthetic_zero_motion_grid_step" field.</summary>
    public const int SyntheticZeroMotionGridStepFieldNumber = 13;
    private readonly static float SyntheticZeroMotionGridStepDefaultValue = 0.04F;

    private float syntheticZeroMotionGridStep_;
    /// <summary>
    /// Grid step-size in fraction of width or height used for creating synthetic
    /// zero motion tracks with feature points lying on a grid. Can be set based on
    /// desired number of total features as 1/sqrt(num_features),
    /// e.g. .04 ~= 1/sqrt(600).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SyntheticZeroMotionGridStep {
      get { if ((_hasBits0 & 512) != 0) { return syntheticZeroMotionGridStep_; } else { return SyntheticZeroMotionGridStepDefaultValue; } }
      set {
        _hasBits0 |= 512;
        syntheticZeroMotionGridStep_ = value;
      }
    }
    /// <summary>Gets whether the "synthetic_zero_motion_grid_step" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSyntheticZeroMotionGridStep {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "synthetic_zero_motion_grid_step" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSyntheticZeroMotionGridStep() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "wide_baseline_matching" field.</summary>
    public const int WideBaselineMatchingFieldNumber = 14;
    private readonly static bool WideBaselineMatchingDefaultValue = false;

    private bool wideBaselineMatching_;
    /// <summary>
    /// If set, uses ORB features with brute force matching and ratio test
    /// to track frames across larger perspective changes than possible with
    /// default KLT features.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool WideBaselineMatching {
      get { if ((_hasBits0 & 1024) != 0) { return wideBaselineMatching_; } else { return WideBaselineMatchingDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        wideBaselineMatching_ = value;
      }
    }
    /// <summary>Gets whether the "wide_baseline_matching" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWideBaselineMatching {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "wide_baseline_matching" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWideBaselineMatching() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "ratio_test_threshold" field.</summary>
    public const int RatioTestThresholdFieldNumber = 15;
    private readonly static float RatioTestThresholdDefaultValue = 0.8F;

    private float ratioTestThreshold_;
    /// <summary>
    /// Only brute force matches with
    /// best_match_distance &lt; ratio_test_threshold * second_best_match_distance
    /// are retained.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RatioTestThreshold {
      get { if ((_hasBits0 & 2048) != 0) { return ratioTestThreshold_; } else { return RatioTestThresholdDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        ratioTestThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "ratio_test_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRatioTestThreshold {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "ratio_test_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRatioTestThreshold() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "refine_wide_baseline_matches" field.</summary>
    public const int RefineWideBaselineMatchesFieldNumber = 16;
    private readonly static bool RefineWideBaselineMatchesDefaultValue = false;

    private bool refineWideBaselineMatches_;
    /// <summary>
    /// Refines wide baseline matches by estimating affine transform to
    /// wide-baseline matches which is used to seed initial positions for KLT
    /// matches.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RefineWideBaselineMatches {
      get { if ((_hasBits0 & 4096) != 0) { return refineWideBaselineMatches_; } else { return RefineWideBaselineMatchesDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        refineWideBaselineMatches_ = value;
      }
    }
    /// <summary>Gets whether the "refine_wide_baseline_matches" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRefineWideBaselineMatches {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "refine_wide_baseline_matches" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRefineWideBaselineMatches() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "reuse_features_max_frame_distance" field.</summary>
    public const int ReuseFeaturesMaxFrameDistanceFieldNumber = 17;
    private readonly static int ReuseFeaturesMaxFrameDistanceDefaultValue = 0;

    private int reuseFeaturesMaxFrameDistance_;
    /// <summary>
    /// When tracking features, features tracked from frame A to frame B may be
    /// reused as the features for frame B when tracking from it (instead of
    /// extracting features). The max_frame_distance flag limits the distance
    /// between A and B for the features to be reused. Setting it to 0 => no
    /// re-use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ReuseFeaturesMaxFrameDistance {
      get { if ((_hasBits0 & 8192) != 0) { return reuseFeaturesMaxFrameDistance_; } else { return ReuseFeaturesMaxFrameDistanceDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        reuseFeaturesMaxFrameDistance_ = value;
      }
    }
    /// <summary>Gets whether the "reuse_features_max_frame_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReuseFeaturesMaxFrameDistance {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "reuse_features_max_frame_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReuseFeaturesMaxFrameDistance() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "reuse_features_min_survived_frac" field.</summary>
    public const int ReuseFeaturesMinSurvivedFracFieldNumber = 18;
    private readonly static float ReuseFeaturesMinSurvivedFracDefaultValue = 0.7F;

    private float reuseFeaturesMinSurvivedFrac_;
    /// <summary>
    /// In conjunction with above, the features are reused in frame B only if they
    /// are at-least this fraction of the original features in frame A. Otherwise
    /// they are reset and extracted from scratch.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ReuseFeaturesMinSurvivedFrac {
      get { if ((_hasBits0 & 16384) != 0) { return reuseFeaturesMinSurvivedFrac_; } else { return ReuseFeaturesMinSurvivedFracDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        reuseFeaturesMinSurvivedFrac_ = value;
      }
    }
    /// <summary>Gets whether the "reuse_features_min_survived_frac" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReuseFeaturesMinSurvivedFrac {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "reuse_features_min_survived_frac" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReuseFeaturesMinSurvivedFrac() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "klt_tracker_implementation" field.</summary>
    public const int KltTrackerImplementationFieldNumber = 32;
    private readonly static global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation KltTrackerImplementationDefaultValue = global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation.KltOpencv;

    private global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation kltTrackerImplementation_;
    /// <summary>
    /// Implementation choice of KLT tracker.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation KltTrackerImplementation {
      get { if ((_hasBits0 & 16777216) != 0) { return kltTrackerImplementation_; } else { return KltTrackerImplementationDefaultValue; } }
      set {
        _hasBits0 |= 16777216;
        kltTrackerImplementation_ = value;
      }
    }
    /// <summary>Gets whether the "klt_tracker_implementation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKltTrackerImplementation {
      get { return (_hasBits0 & 16777216) != 0; }
    }
    /// <summary>Clears the value of the "klt_tracker_implementation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKltTrackerImplementation() {
      _hasBits0 &= ~16777216;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TrackingOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TrackingOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InternalTrackingDirection != other.InternalTrackingDirection) return false;
      if (OutputFlowDirection != other.OutputFlowDirection) return false;
      if (TrackingPolicy != other.TrackingPolicy) return false;
      if (MultiFramesToTrack != other.MultiFramesToTrack) return false;
      if (LongTracksMaxFrames != other.LongTracksMaxFrames) return false;
      if (MaxFeatures != other.MaxFeatures) return false;
      if (CornerExtractionMethod != other.CornerExtractionMethod) return false;
      if (!object.Equals(MinEigValSettings, other.MinEigValSettings)) return false;
      if (!object.Equals(HarrisSettings, other.HarrisSettings)) return false;
      if (!object.Equals(FastSettings, other.FastSettings)) return false;
      if (TrackingWindowSize != other.TrackingWindowSize) return false;
      if (TrackingIterations != other.TrackingIterations) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FractionalTrackingDistance, other.FractionalTrackingDistance)) return false;
      if (AdaptiveTrackingDistance != other.AdaptiveTrackingDistance) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinFeatureDistance, other.MinFeatureDistance)) return false;
      if (DistanceDownscaleSqrt != other.DistanceDownscaleSqrt) return false;
      if (AdaptiveGoodFeaturesToTrack != other.AdaptiveGoodFeaturesToTrack) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AdaptiveFeaturesBlockSize, other.AdaptiveFeaturesBlockSize)) return false;
      if (AdaptiveFeaturesLevels != other.AdaptiveFeaturesLevels) return false;
      if (AdaptiveExtractionLevels != other.AdaptiveExtractionLevels) return false;
      if (AdaptiveExtractionLevelsLowestSize != other.AdaptiveExtractionLevelsLowestSize) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SyntheticZeroMotionGridStep, other.SyntheticZeroMotionGridStep)) return false;
      if (WideBaselineMatching != other.WideBaselineMatching) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RatioTestThreshold, other.RatioTestThreshold)) return false;
      if (RefineWideBaselineMatches != other.RefineWideBaselineMatches) return false;
      if (ReuseFeaturesMaxFrameDistance != other.ReuseFeaturesMaxFrameDistance) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ReuseFeaturesMinSurvivedFrac, other.ReuseFeaturesMinSurvivedFrac)) return false;
      if (KltTrackerImplementation != other.KltTrackerImplementation) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasInternalTrackingDirection) hash ^= InternalTrackingDirection.GetHashCode();
      if (HasOutputFlowDirection) hash ^= OutputFlowDirection.GetHashCode();
      if (HasTrackingPolicy) hash ^= TrackingPolicy.GetHashCode();
      if (HasMultiFramesToTrack) hash ^= MultiFramesToTrack.GetHashCode();
      if (HasLongTracksMaxFrames) hash ^= LongTracksMaxFrames.GetHashCode();
      if (HasMaxFeatures) hash ^= MaxFeatures.GetHashCode();
      if (HasCornerExtractionMethod) hash ^= CornerExtractionMethod.GetHashCode();
      if (minEigValSettings_ != null) hash ^= MinEigValSettings.GetHashCode();
      if (harrisSettings_ != null) hash ^= HarrisSettings.GetHashCode();
      if (fastSettings_ != null) hash ^= FastSettings.GetHashCode();
      if (HasTrackingWindowSize) hash ^= TrackingWindowSize.GetHashCode();
      if (HasTrackingIterations) hash ^= TrackingIterations.GetHashCode();
      if (HasFractionalTrackingDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FractionalTrackingDistance);
      if (HasAdaptiveTrackingDistance) hash ^= AdaptiveTrackingDistance.GetHashCode();
      if (HasMinFeatureDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinFeatureDistance);
      if (HasDistanceDownscaleSqrt) hash ^= DistanceDownscaleSqrt.GetHashCode();
      if (HasAdaptiveGoodFeaturesToTrack) hash ^= AdaptiveGoodFeaturesToTrack.GetHashCode();
      if (HasAdaptiveFeaturesBlockSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AdaptiveFeaturesBlockSize);
      if (HasAdaptiveFeaturesLevels) hash ^= AdaptiveFeaturesLevels.GetHashCode();
      if (HasAdaptiveExtractionLevels) hash ^= AdaptiveExtractionLevels.GetHashCode();
      if (HasAdaptiveExtractionLevelsLowestSize) hash ^= AdaptiveExtractionLevelsLowestSize.GetHashCode();
      if (HasSyntheticZeroMotionGridStep) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SyntheticZeroMotionGridStep);
      if (HasWideBaselineMatching) hash ^= WideBaselineMatching.GetHashCode();
      if (HasRatioTestThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RatioTestThreshold);
      if (HasRefineWideBaselineMatches) hash ^= RefineWideBaselineMatches.GetHashCode();
      if (HasReuseFeaturesMaxFrameDistance) hash ^= ReuseFeaturesMaxFrameDistance.GetHashCode();
      if (HasReuseFeaturesMinSurvivedFrac) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ReuseFeaturesMinSurvivedFrac);
      if (HasKltTrackerImplementation) hash ^= KltTrackerImplementation.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMultiFramesToTrack) {
        output.WriteRawTag(8);
        output.WriteInt32(MultiFramesToTrack);
      }
      if (HasMaxFeatures) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxFeatures);
      }
      if (HasTrackingWindowSize) {
        output.WriteRawTag(32);
        output.WriteInt32(TrackingWindowSize);
      }
      if (HasTrackingIterations) {
        output.WriteRawTag(40);
        output.WriteInt32(TrackingIterations);
      }
      if (HasFractionalTrackingDistance) {
        output.WriteRawTag(53);
        output.WriteFloat(FractionalTrackingDistance);
      }
      if (HasMinFeatureDistance) {
        output.WriteRawTag(61);
        output.WriteFloat(MinFeatureDistance);
      }
      if (HasAdaptiveGoodFeaturesToTrack) {
        output.WriteRawTag(64);
        output.WriteBool(AdaptiveGoodFeaturesToTrack);
      }
      if (HasAdaptiveFeaturesBlockSize) {
        output.WriteRawTag(77);
        output.WriteFloat(AdaptiveFeaturesBlockSize);
      }
      if (HasAdaptiveFeaturesLevels) {
        output.WriteRawTag(80);
        output.WriteInt32(AdaptiveFeaturesLevels);
      }
      if (HasSyntheticZeroMotionGridStep) {
        output.WriteRawTag(109);
        output.WriteFloat(SyntheticZeroMotionGridStep);
      }
      if (HasWideBaselineMatching) {
        output.WriteRawTag(112);
        output.WriteBool(WideBaselineMatching);
      }
      if (HasRatioTestThreshold) {
        output.WriteRawTag(125);
        output.WriteFloat(RatioTestThreshold);
      }
      if (HasRefineWideBaselineMatches) {
        output.WriteRawTag(128, 1);
        output.WriteBool(RefineWideBaselineMatches);
      }
      if (HasReuseFeaturesMaxFrameDistance) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(ReuseFeaturesMaxFrameDistance);
      }
      if (HasReuseFeaturesMinSurvivedFrac) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(ReuseFeaturesMinSurvivedFrac);
      }
      if (HasInternalTrackingDirection) {
        output.WriteRawTag(152, 1);
        output.WriteEnum((int) InternalTrackingDirection);
      }
      if (HasOutputFlowDirection) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) OutputFlowDirection);
      }
      if (HasDistanceDownscaleSqrt) {
        output.WriteRawTag(168, 1);
        output.WriteBool(DistanceDownscaleSqrt);
      }
      if (HasAdaptiveExtractionLevels) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(AdaptiveExtractionLevels);
      }
      if (HasAdaptiveExtractionLevelsLowestSize) {
        output.WriteRawTag(184, 1);
        output.WriteInt32(AdaptiveExtractionLevelsLowestSize);
      }
      if (HasAdaptiveTrackingDistance) {
        output.WriteRawTag(192, 1);
        output.WriteBool(AdaptiveTrackingDistance);
      }
      if (HasTrackingPolicy) {
        output.WriteRawTag(200, 1);
        output.WriteEnum((int) TrackingPolicy);
      }
      if (HasLongTracksMaxFrames) {
        output.WriteRawTag(208, 1);
        output.WriteInt32(LongTracksMaxFrames);
      }
      if (HasCornerExtractionMethod) {
        output.WriteRawTag(216, 1);
        output.WriteEnum((int) CornerExtractionMethod);
      }
      if (minEigValSettings_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(MinEigValSettings);
      }
      if (harrisSettings_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(HarrisSettings);
      }
      if (fastSettings_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(FastSettings);
      }
      if (HasKltTrackerImplementation) {
        output.WriteRawTag(128, 2);
        output.WriteEnum((int) KltTrackerImplementation);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMultiFramesToTrack) {
        output.WriteRawTag(8);
        output.WriteInt32(MultiFramesToTrack);
      }
      if (HasMaxFeatures) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxFeatures);
      }
      if (HasTrackingWindowSize) {
        output.WriteRawTag(32);
        output.WriteInt32(TrackingWindowSize);
      }
      if (HasTrackingIterations) {
        output.WriteRawTag(40);
        output.WriteInt32(TrackingIterations);
      }
      if (HasFractionalTrackingDistance) {
        output.WriteRawTag(53);
        output.WriteFloat(FractionalTrackingDistance);
      }
      if (HasMinFeatureDistance) {
        output.WriteRawTag(61);
        output.WriteFloat(MinFeatureDistance);
      }
      if (HasAdaptiveGoodFeaturesToTrack) {
        output.WriteRawTag(64);
        output.WriteBool(AdaptiveGoodFeaturesToTrack);
      }
      if (HasAdaptiveFeaturesBlockSize) {
        output.WriteRawTag(77);
        output.WriteFloat(AdaptiveFeaturesBlockSize);
      }
      if (HasAdaptiveFeaturesLevels) {
        output.WriteRawTag(80);
        output.WriteInt32(AdaptiveFeaturesLevels);
      }
      if (HasSyntheticZeroMotionGridStep) {
        output.WriteRawTag(109);
        output.WriteFloat(SyntheticZeroMotionGridStep);
      }
      if (HasWideBaselineMatching) {
        output.WriteRawTag(112);
        output.WriteBool(WideBaselineMatching);
      }
      if (HasRatioTestThreshold) {
        output.WriteRawTag(125);
        output.WriteFloat(RatioTestThreshold);
      }
      if (HasRefineWideBaselineMatches) {
        output.WriteRawTag(128, 1);
        output.WriteBool(RefineWideBaselineMatches);
      }
      if (HasReuseFeaturesMaxFrameDistance) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(ReuseFeaturesMaxFrameDistance);
      }
      if (HasReuseFeaturesMinSurvivedFrac) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(ReuseFeaturesMinSurvivedFrac);
      }
      if (HasInternalTrackingDirection) {
        output.WriteRawTag(152, 1);
        output.WriteEnum((int) InternalTrackingDirection);
      }
      if (HasOutputFlowDirection) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) OutputFlowDirection);
      }
      if (HasDistanceDownscaleSqrt) {
        output.WriteRawTag(168, 1);
        output.WriteBool(DistanceDownscaleSqrt);
      }
      if (HasAdaptiveExtractionLevels) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(AdaptiveExtractionLevels);
      }
      if (HasAdaptiveExtractionLevelsLowestSize) {
        output.WriteRawTag(184, 1);
        output.WriteInt32(AdaptiveExtractionLevelsLowestSize);
      }
      if (HasAdaptiveTrackingDistance) {
        output.WriteRawTag(192, 1);
        output.WriteBool(AdaptiveTrackingDistance);
      }
      if (HasTrackingPolicy) {
        output.WriteRawTag(200, 1);
        output.WriteEnum((int) TrackingPolicy);
      }
      if (HasLongTracksMaxFrames) {
        output.WriteRawTag(208, 1);
        output.WriteInt32(LongTracksMaxFrames);
      }
      if (HasCornerExtractionMethod) {
        output.WriteRawTag(216, 1);
        output.WriteEnum((int) CornerExtractionMethod);
      }
      if (minEigValSettings_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(MinEigValSettings);
      }
      if (harrisSettings_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(HarrisSettings);
      }
      if (fastSettings_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(FastSettings);
      }
      if (HasKltTrackerImplementation) {
        output.WriteRawTag(128, 2);
        output.WriteEnum((int) KltTrackerImplementation);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasInternalTrackingDirection) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) InternalTrackingDirection);
      }
      if (HasOutputFlowDirection) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) OutputFlowDirection);
      }
      if (HasTrackingPolicy) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TrackingPolicy);
      }
      if (HasMultiFramesToTrack) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MultiFramesToTrack);
      }
      if (HasLongTracksMaxFrames) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(LongTracksMaxFrames);
      }
      if (HasMaxFeatures) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxFeatures);
      }
      if (HasCornerExtractionMethod) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CornerExtractionMethod);
      }
      if (minEigValSettings_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MinEigValSettings);
      }
      if (harrisSettings_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HarrisSettings);
      }
      if (fastSettings_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FastSettings);
      }
      if (HasTrackingWindowSize) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TrackingWindowSize);
      }
      if (HasTrackingIterations) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TrackingIterations);
      }
      if (HasFractionalTrackingDistance) {
        size += 1 + 4;
      }
      if (HasAdaptiveTrackingDistance) {
        size += 2 + 1;
      }
      if (HasMinFeatureDistance) {
        size += 1 + 4;
      }
      if (HasDistanceDownscaleSqrt) {
        size += 2 + 1;
      }
      if (HasAdaptiveGoodFeaturesToTrack) {
        size += 1 + 1;
      }
      if (HasAdaptiveFeaturesBlockSize) {
        size += 1 + 4;
      }
      if (HasAdaptiveFeaturesLevels) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AdaptiveFeaturesLevels);
      }
      if (HasAdaptiveExtractionLevels) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(AdaptiveExtractionLevels);
      }
      if (HasAdaptiveExtractionLevelsLowestSize) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(AdaptiveExtractionLevelsLowestSize);
      }
      if (HasSyntheticZeroMotionGridStep) {
        size += 1 + 4;
      }
      if (HasWideBaselineMatching) {
        size += 1 + 1;
      }
      if (HasRatioTestThreshold) {
        size += 1 + 4;
      }
      if (HasRefineWideBaselineMatches) {
        size += 2 + 1;
      }
      if (HasReuseFeaturesMaxFrameDistance) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(ReuseFeaturesMaxFrameDistance);
      }
      if (HasReuseFeaturesMinSurvivedFrac) {
        size += 2 + 4;
      }
      if (HasKltTrackerImplementation) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) KltTrackerImplementation);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TrackingOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasInternalTrackingDirection) {
        InternalTrackingDirection = other.InternalTrackingDirection;
      }
      if (other.HasOutputFlowDirection) {
        OutputFlowDirection = other.OutputFlowDirection;
      }
      if (other.HasTrackingPolicy) {
        TrackingPolicy = other.TrackingPolicy;
      }
      if (other.HasMultiFramesToTrack) {
        MultiFramesToTrack = other.MultiFramesToTrack;
      }
      if (other.HasLongTracksMaxFrames) {
        LongTracksMaxFrames = other.LongTracksMaxFrames;
      }
      if (other.HasMaxFeatures) {
        MaxFeatures = other.MaxFeatures;
      }
      if (other.HasCornerExtractionMethod) {
        CornerExtractionMethod = other.CornerExtractionMethod;
      }
      if (other.minEigValSettings_ != null) {
        if (minEigValSettings_ == null) {
          MinEigValSettings = new global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings();
        }
        MinEigValSettings.MergeFrom(other.MinEigValSettings);
      }
      if (other.harrisSettings_ != null) {
        if (harrisSettings_ == null) {
          HarrisSettings = new global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings();
        }
        HarrisSettings.MergeFrom(other.HarrisSettings);
      }
      if (other.fastSettings_ != null) {
        if (fastSettings_ == null) {
          FastSettings = new global::Mediapipe.TrackingOptions.Types.FastExtractionSettings();
        }
        FastSettings.MergeFrom(other.FastSettings);
      }
      if (other.HasTrackingWindowSize) {
        TrackingWindowSize = other.TrackingWindowSize;
      }
      if (other.HasTrackingIterations) {
        TrackingIterations = other.TrackingIterations;
      }
      if (other.HasFractionalTrackingDistance) {
        FractionalTrackingDistance = other.FractionalTrackingDistance;
      }
      if (other.HasAdaptiveTrackingDistance) {
        AdaptiveTrackingDistance = other.AdaptiveTrackingDistance;
      }
      if (other.HasMinFeatureDistance) {
        MinFeatureDistance = other.MinFeatureDistance;
      }
      if (other.HasDistanceDownscaleSqrt) {
        DistanceDownscaleSqrt = other.DistanceDownscaleSqrt;
      }
      if (other.HasAdaptiveGoodFeaturesToTrack) {
        AdaptiveGoodFeaturesToTrack = other.AdaptiveGoodFeaturesToTrack;
      }
      if (other.HasAdaptiveFeaturesBlockSize) {
        AdaptiveFeaturesBlockSize = other.AdaptiveFeaturesBlockSize;
      }
      if (other.HasAdaptiveFeaturesLevels) {
        AdaptiveFeaturesLevels = other.AdaptiveFeaturesLevels;
      }
      if (other.HasAdaptiveExtractionLevels) {
        AdaptiveExtractionLevels = other.AdaptiveExtractionLevels;
      }
      if (other.HasAdaptiveExtractionLevelsLowestSize) {
        AdaptiveExtractionLevelsLowestSize = other.AdaptiveExtractionLevelsLowestSize;
      }
      if (other.HasSyntheticZeroMotionGridStep) {
        SyntheticZeroMotionGridStep = other.SyntheticZeroMotionGridStep;
      }
      if (other.HasWideBaselineMatching) {
        WideBaselineMatching = other.WideBaselineMatching;
      }
      if (other.HasRatioTestThreshold) {
        RatioTestThreshold = other.RatioTestThreshold;
      }
      if (other.HasRefineWideBaselineMatches) {
        RefineWideBaselineMatches = other.RefineWideBaselineMatches;
      }
      if (other.HasReuseFeaturesMaxFrameDistance) {
        ReuseFeaturesMaxFrameDistance = other.ReuseFeaturesMaxFrameDistance;
      }
      if (other.HasReuseFeaturesMinSurvivedFrac) {
        ReuseFeaturesMinSurvivedFrac = other.ReuseFeaturesMinSurvivedFrac;
      }
      if (other.HasKltTrackerImplementation) {
        KltTrackerImplementation = other.KltTrackerImplementation;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            MultiFramesToTrack = input.ReadInt32();
            break;
          }
          case 16: {
            MaxFeatures = input.ReadInt32();
            break;
          }
          case 32: {
            TrackingWindowSize = input.ReadInt32();
            break;
          }
          case 40: {
            TrackingIterations = input.ReadInt32();
            break;
          }
          case 53: {
            FractionalTrackingDistance = input.ReadFloat();
            break;
          }
          case 61: {
            MinFeatureDistance = input.ReadFloat();
            break;
          }
          case 64: {
            AdaptiveGoodFeaturesToTrack = input.ReadBool();
            break;
          }
          case 77: {
            AdaptiveFeaturesBlockSize = input.ReadFloat();
            break;
          }
          case 80: {
            AdaptiveFeaturesLevels = input.ReadInt32();
            break;
          }
          case 109: {
            SyntheticZeroMotionGridStep = input.ReadFloat();
            break;
          }
          case 112: {
            WideBaselineMatching = input.ReadBool();
            break;
          }
          case 125: {
            RatioTestThreshold = input.ReadFloat();
            break;
          }
          case 128: {
            RefineWideBaselineMatches = input.ReadBool();
            break;
          }
          case 136: {
            ReuseFeaturesMaxFrameDistance = input.ReadInt32();
            break;
          }
          case 149: {
            ReuseFeaturesMinSurvivedFrac = input.ReadFloat();
            break;
          }
          case 152: {
            InternalTrackingDirection = (global::Mediapipe.TrackingOptions.Types.FlowDirection) input.ReadEnum();
            break;
          }
          case 160: {
            OutputFlowDirection = (global::Mediapipe.TrackingOptions.Types.FlowDirection) input.ReadEnum();
            break;
          }
          case 168: {
            DistanceDownscaleSqrt = input.ReadBool();
            break;
          }
          case 176: {
            AdaptiveExtractionLevels = input.ReadInt32();
            break;
          }
          case 184: {
            AdaptiveExtractionLevelsLowestSize = input.ReadInt32();
            break;
          }
          case 192: {
            AdaptiveTrackingDistance = input.ReadBool();
            break;
          }
          case 200: {
            TrackingPolicy = (global::Mediapipe.TrackingOptions.Types.TrackingPolicy) input.ReadEnum();
            break;
          }
          case 208: {
            LongTracksMaxFrames = input.ReadInt32();
            break;
          }
          case 216: {
            CornerExtractionMethod = (global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod) input.ReadEnum();
            break;
          }
          case 226: {
            if (minEigValSettings_ == null) {
              MinEigValSettings = new global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings();
            }
            input.ReadMessage(MinEigValSettings);
            break;
          }
          case 234: {
            if (harrisSettings_ == null) {
              HarrisSettings = new global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings();
            }
            input.ReadMessage(HarrisSettings);
            break;
          }
          case 250: {
            if (fastSettings_ == null) {
              FastSettings = new global::Mediapipe.TrackingOptions.Types.FastExtractionSettings();
            }
            input.ReadMessage(FastSettings);
            break;
          }
          case 256: {
            KltTrackerImplementation = (global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            MultiFramesToTrack = input.ReadInt32();
            break;
          }
          case 16: {
            MaxFeatures = input.ReadInt32();
            break;
          }
          case 32: {
            TrackingWindowSize = input.ReadInt32();
            break;
          }
          case 40: {
            TrackingIterations = input.ReadInt32();
            break;
          }
          case 53: {
            FractionalTrackingDistance = input.ReadFloat();
            break;
          }
          case 61: {
            MinFeatureDistance = input.ReadFloat();
            break;
          }
          case 64: {
            AdaptiveGoodFeaturesToTrack = input.ReadBool();
            break;
          }
          case 77: {
            AdaptiveFeaturesBlockSize = input.ReadFloat();
            break;
          }
          case 80: {
            AdaptiveFeaturesLevels = input.ReadInt32();
            break;
          }
          case 109: {
            SyntheticZeroMotionGridStep = input.ReadFloat();
            break;
          }
          case 112: {
            WideBaselineMatching = input.ReadBool();
            break;
          }
          case 125: {
            RatioTestThreshold = input.ReadFloat();
            break;
          }
          case 128: {
            RefineWideBaselineMatches = input.ReadBool();
            break;
          }
          case 136: {
            ReuseFeaturesMaxFrameDistance = input.ReadInt32();
            break;
          }
          case 149: {
            ReuseFeaturesMinSurvivedFrac = input.ReadFloat();
            break;
          }
          case 152: {
            InternalTrackingDirection = (global::Mediapipe.TrackingOptions.Types.FlowDirection) input.ReadEnum();
            break;
          }
          case 160: {
            OutputFlowDirection = (global::Mediapipe.TrackingOptions.Types.FlowDirection) input.ReadEnum();
            break;
          }
          case 168: {
            DistanceDownscaleSqrt = input.ReadBool();
            break;
          }
          case 176: {
            AdaptiveExtractionLevels = input.ReadInt32();
            break;
          }
          case 184: {
            AdaptiveExtractionLevelsLowestSize = input.ReadInt32();
            break;
          }
          case 192: {
            AdaptiveTrackingDistance = input.ReadBool();
            break;
          }
          case 200: {
            TrackingPolicy = (global::Mediapipe.TrackingOptions.Types.TrackingPolicy) input.ReadEnum();
            break;
          }
          case 208: {
            LongTracksMaxFrames = input.ReadInt32();
            break;
          }
          case 216: {
            CornerExtractionMethod = (global::Mediapipe.TrackingOptions.Types.CornerExtractionMethod) input.ReadEnum();
            break;
          }
          case 226: {
            if (minEigValSettings_ == null) {
              MinEigValSettings = new global::Mediapipe.TrackingOptions.Types.MinEigValExtractionSettings();
            }
            input.ReadMessage(MinEigValSettings);
            break;
          }
          case 234: {
            if (harrisSettings_ == null) {
              HarrisSettings = new global::Mediapipe.TrackingOptions.Types.HarrisExtractionSettings();
            }
            input.ReadMessage(HarrisSettings);
            break;
          }
          case 250: {
            if (fastSettings_ == null) {
              FastSettings = new global::Mediapipe.TrackingOptions.Types.FastExtractionSettings();
            }
            input.ReadMessage(FastSettings);
            break;
          }
          case 256: {
            KltTrackerImplementation = (global::Mediapipe.TrackingOptions.Types.KltTrackerImplementation) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TrackingOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TrackingOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TrackingOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TrackingOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TrackingOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TrackingOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TrackingOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TrackingOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Describes direction of flow during feature tracking and for the output
      /// region flow.
      /// </summary>
      public enum FlowDirection {
        /// <summary>
        /// Tracks are forward, from frame N-k -> frame N (k > 0).
        /// </summary>
        [pbr::OriginalName("FORWARD")] Forward = 1,
        /// <summary>
        /// Tracks are backward, from frame N -> frame N-k
        /// </summary>
        [pbr::OriginalName("BACKWARD")] Backward = 2,
        /// <summary>
        /// (k > 0).
        /// </summary>
        [pbr::OriginalName("CONSECUTIVELY")] Consecutively = 3,
      }

      /// <summary>
      /// Specifies how a feature is tracked w.r.t. previous or next frames
      /// (dependent on the FlowDirection options above).
      /// Per default, each frame is tracked w.r.t. a single neighboring frame
      /// (TRACK_SINGLE_FRAME). If associations across multiple frames are desired,
      /// TRACK_MULTI_FRAME creates multiple results for the current frame, by
      /// tracking features w.r.t. multiple neighbors. Number of neighbors is
      /// specified by multi_frames_to_track.
      /// If long feature tracks are desired (i.e. a track across a frame pair
      /// that is identified to belong to an earlier known feature), use
      /// TRACK_ACROSS_FRAMES. Maximum track length can be specified by
      /// long_tracks_max_frames.
      /// </summary>
      public enum TrackingPolicy {
        /// <summary>
        /// Tracks w.r.t. previous or next frame.
        /// </summary>
        [pbr::OriginalName("POLICY_SINGLE_FRAME")] PolicySingleFrame = 1,
        /// <summary>
        /// Tracks w.r.t. multiple frames.
        /// </summary>
        [pbr::OriginalName("POLICY_MULTI_FRAME")] PolicyMultiFrame = 2,
        /// <summary>
        /// Create long feature tracks.
        /// </summary>
        [pbr::OriginalName("POLICY_LONG_TRACKS")] PolicyLongTracks = 3,
      }

      /// <summary>
      /// Specifies the extraction method for features.
      /// </summary>
      public enum CornerExtractionMethod {
        /// <summary>
        /// Using Harris' approximation of
        /// </summary>
        [pbr::OriginalName("EXTRACTION_HARRIS")] ExtractionHarris = 1,
        /// <summary>
        /// EXTRACTION_MIN_EIG_VAL.
        /// </summary>
        [pbr::OriginalName("EXTRACTION_MIN_EIG_VAL")] ExtractionMinEigVal = 2,
        /// <summary>
        /// Extract using FAST feature detector.
        /// </summary>
        [pbr::OriginalName("EXTRACTION_FAST")] ExtractionFast = 3,
      }

      public enum KltTrackerImplementation {
        [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Use OpenCV's implementation of KLT tracker.
        /// </summary>
        [pbr::OriginalName("KLT_OPENCV")] KltOpencv = 1,
      }

      /// <summary>
      /// Settings for above corner extraction methods.
      /// </summary>
      public sealed partial class MinEigValExtractionSettings : pb::IMessage<MinEigValExtractionSettings>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MinEigValExtractionSettings> _parser = new pb::MessageParser<MinEigValExtractionSettings>(() => new MinEigValExtractionSettings());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<MinEigValExtractionSettings> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.TrackingOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MinEigValExtractionSettings() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MinEigValExtractionSettings(MinEigValExtractionSettings other) : this() {
          _hasBits0 = other._hasBits0;
          featureQualityLevel_ = other.featureQualityLevel_;
          adaptiveLowestQualityLevel_ = other.adaptiveLowestQualityLevel_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MinEigValExtractionSettings Clone() {
          return new MinEigValExtractionSettings(this);
        }

        /// <summary>Field number for the "feature_quality_level" field.</summary>
        public const int FeatureQualityLevelFieldNumber = 1;
        private readonly static float FeatureQualityLevelDefaultValue = 0.01F;

        private float featureQualityLevel_;
        /// <summary>
        /// Quality level of features (features with
        /// min_eig_value &lt; quality_level * max_eig_value are rejected).
        /// Here [min|max]_eig_value denote the minimum and maximum eigen value of
        /// the auto-correlation matrix of the patch centered at a feature point. The
        /// ratio of eigenvalues denotes the "cornerness", lower means more
        /// pronounced corners.
        /// (see http://en.wikipedia.org/wiki/Harris-Affine for details.)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FeatureQualityLevel {
          get { if ((_hasBits0 & 1) != 0) { return featureQualityLevel_; } else { return FeatureQualityLevelDefaultValue; } }
          set {
            _hasBits0 |= 1;
            featureQualityLevel_ = value;
          }
        }
        /// <summary>Gets whether the "feature_quality_level" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFeatureQualityLevel {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "feature_quality_level" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFeatureQualityLevel() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "adaptive_lowest_quality_level" field.</summary>
        public const int AdaptiveLowestQualityLevelFieldNumber = 2;
        private readonly static float AdaptiveLowestQualityLevelDefaultValue = 8e-05F;

        private float adaptiveLowestQualityLevel_;
        /// <summary>
        /// Features below this quality level are always discarded, even if their
        /// score is above feature_quality_level() * local maximum within that grid
        /// cell. This prevents us from including very poor features.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float AdaptiveLowestQualityLevel {
          get { if ((_hasBits0 & 2) != 0) { return adaptiveLowestQualityLevel_; } else { return AdaptiveLowestQualityLevelDefaultValue; } }
          set {
            _hasBits0 |= 2;
            adaptiveLowestQualityLevel_ = value;
          }
        }
        /// <summary>Gets whether the "adaptive_lowest_quality_level" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAdaptiveLowestQualityLevel {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "adaptive_lowest_quality_level" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAdaptiveLowestQualityLevel() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as MinEigValExtractionSettings);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(MinEigValExtractionSettings other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FeatureQualityLevel, other.FeatureQualityLevel)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AdaptiveLowestQualityLevel, other.AdaptiveLowestQualityLevel)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasFeatureQualityLevel) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FeatureQualityLevel);
          if (HasAdaptiveLowestQualityLevel) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AdaptiveLowestQualityLevel);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasFeatureQualityLevel) {
            output.WriteRawTag(13);
            output.WriteFloat(FeatureQualityLevel);
          }
          if (HasAdaptiveLowestQualityLevel) {
            output.WriteRawTag(21);
            output.WriteFloat(AdaptiveLowestQualityLevel);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasFeatureQualityLevel) {
            output.WriteRawTag(13);
            output.WriteFloat(FeatureQualityLevel);
          }
          if (HasAdaptiveLowestQualityLevel) {
            output.WriteRawTag(21);
            output.WriteFloat(AdaptiveLowestQualityLevel);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasFeatureQualityLevel) {
            size += 1 + 4;
          }
          if (HasAdaptiveLowestQualityLevel) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(MinEigValExtractionSettings other) {
          if (other == null) {
            return;
          }
          if (other.HasFeatureQualityLevel) {
            FeatureQualityLevel = other.FeatureQualityLevel;
          }
          if (other.HasAdaptiveLowestQualityLevel) {
            AdaptiveLowestQualityLevel = other.AdaptiveLowestQualityLevel;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                FeatureQualityLevel = input.ReadFloat();
                break;
              }
              case 21: {
                AdaptiveLowestQualityLevel = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                FeatureQualityLevel = input.ReadFloat();
                break;
              }
              case 21: {
                AdaptiveLowestQualityLevel = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class HarrisExtractionSettings : pb::IMessage<HarrisExtractionSettings>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HarrisExtractionSettings> _parser = new pb::MessageParser<HarrisExtractionSettings>(() => new HarrisExtractionSettings());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HarrisExtractionSettings> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.TrackingOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HarrisExtractionSettings() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HarrisExtractionSettings(HarrisExtractionSettings other) : this() {
          _hasBits0 = other._hasBits0;
          featureQualityLevel_ = other.featureQualityLevel_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HarrisExtractionSettings Clone() {
          return new HarrisExtractionSettings(this);
        }

        /// <summary>Field number for the "feature_quality_level" field.</summary>
        public const int FeatureQualityLevelFieldNumber = 1;
        private readonly static float FeatureQualityLevelDefaultValue = 0.00025F;

        private float featureQualityLevel_;
        /// <summary>
        /// Same as in MinEigValExtractionSettings.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FeatureQualityLevel {
          get { if ((_hasBits0 & 1) != 0) { return featureQualityLevel_; } else { return FeatureQualityLevelDefaultValue; } }
          set {
            _hasBits0 |= 1;
            featureQualityLevel_ = value;
          }
        }
        /// <summary>Gets whether the "feature_quality_level" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFeatureQualityLevel {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "feature_quality_level" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFeatureQualityLevel() {
          _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HarrisExtractionSettings);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HarrisExtractionSettings other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FeatureQualityLevel, other.FeatureQualityLevel)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasFeatureQualityLevel) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FeatureQualityLevel);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasFeatureQualityLevel) {
            output.WriteRawTag(13);
            output.WriteFloat(FeatureQualityLevel);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasFeatureQualityLevel) {
            output.WriteRawTag(13);
            output.WriteFloat(FeatureQualityLevel);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasFeatureQualityLevel) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HarrisExtractionSettings other) {
          if (other == null) {
            return;
          }
          if (other.HasFeatureQualityLevel) {
            FeatureQualityLevel = other.FeatureQualityLevel;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                FeatureQualityLevel = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                FeatureQualityLevel = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class FastExtractionSettings : pb::IMessage<FastExtractionSettings>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<FastExtractionSettings> _parser = new pb::MessageParser<FastExtractionSettings>(() => new FastExtractionSettings());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FastExtractionSettings> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.TrackingOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FastExtractionSettings() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FastExtractionSettings(FastExtractionSettings other) : this() {
          _hasBits0 = other._hasBits0;
          threshold_ = other.threshold_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FastExtractionSettings Clone() {
          return new FastExtractionSettings(this);
        }

        /// <summary>Field number for the "threshold" field.</summary>
        public const int ThresholdFieldNumber = 1;
        private readonly static int ThresholdDefaultValue = 10;

        private int threshold_;
        /// <summary>
        /// threshold on difference between intensity of the central pixel and pixels
        /// of a circle around this pixel. Empirically, the larger the threshold, the
        /// fewer the keypoints will be detected.
        /// Default value set as the same with OpenCV.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Threshold {
          get { if ((_hasBits0 & 1) != 0) { return threshold_; } else { return ThresholdDefaultValue; } }
          set {
            _hasBits0 |= 1;
            threshold_ = value;
          }
        }
        /// <summary>Gets whether the "threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasThreshold {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearThreshold() {
          _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as FastExtractionSettings);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FastExtractionSettings other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Threshold != other.Threshold) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasThreshold) hash ^= Threshold.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasThreshold) {
            output.WriteRawTag(8);
            output.WriteInt32(Threshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasThreshold) {
            output.WriteRawTag(8);
            output.WriteInt32(Threshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasThreshold) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Threshold);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FastExtractionSettings other) {
          if (other == null) {
            return;
          }
          if (other.HasThreshold) {
            Threshold = other.Threshold;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Threshold = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Threshold = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Next tag: 67
  /// </summary>
  public sealed partial class RegionFlowComputationOptions : pb::IExtendableMessage<RegionFlowComputationOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RegionFlowComputationOptions> _parser = new pb::MessageParser<RegionFlowComputationOptions>(() => new RegionFlowComputationOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<RegionFlowComputationOptions> _extensions;
    private pb::ExtensionSet<RegionFlowComputationOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    private int _hasBits1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RegionFlowComputationOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.RegionFlowComputationReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionFlowComputationOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionFlowComputationOptions(RegionFlowComputationOptions other) : this() {
      _hasBits0 = other._hasBits0;
      _hasBits1 = other._hasBits1;
      trackingOptions_ = other.trackingOptions_ != null ? other.trackingOptions_.Clone() : null;
      minFeatureInliers_ = other.minFeatureInliers_;
      relativeMinFeatureInliers_ = other.relativeMinFeatureInliers_;
      preBlurSigma_ = other.preBlurSigma_;
      ransacRoundsPerRegion_ = other.ransacRoundsPerRegion_;
      absoluteInlierErrorThreshold_ = other.absoluteInlierErrorThreshold_;
      fracInlierErrorThreshold_ = other.fracInlierErrorThreshold_;
      relativeInlierErrorThreshold_ = other.relativeInlierErrorThreshold_;
      topInlierSets_ = other.topInlierSets_;
      noEstimationMode_ = other.noEstimationMode_;
      fastEstimationBlockSize_ = other.fastEstimationBlockSize_;
      fastEstimationMinBlockSize_ = other.fastEstimationMinBlockSize_;
      fastEstimationOverlapGrids_ = other.fastEstimationOverlapGrids_;
      maxMagnitudeThresholdRatio_ = other.maxMagnitudeThresholdRatio_;
      medianMagnitudeBounds_ = other.medianMagnitudeBounds_;
      irlsInitialization_ = other.irlsInitialization_;
      downsampleMode_ = other.downsampleMode_;
      downsamplingSize_ = other.downsamplingSize_;
      downsampleFactor_ = other.downsampleFactor_;
      roundDownsampleFactor_ = other.roundDownsampleFactor_;
      downsampleSchedule_ = other.downsampleSchedule_ != null ? other.downsampleSchedule_.Clone() : null;
      minFeatureRequirement_ = other.minFeatureRequirement_;
      minFeatureCover_ = other.minFeatureCover_;
      minFeatureCoverGrid_ = other.minFeatureCoverGrid_;
      computeBlurScore_ = other.computeBlurScore_;
      blurScoreOptions_ = other.blurScoreOptions_ != null ? other.blurScoreOptions_.Clone() : null;
      visualConsistencyOptions_ = other.visualConsistencyOptions_ != null ? other.visualConsistencyOptions_.Clone() : null;
      patchDescriptorRadius_ = other.patchDescriptorRadius_;
      distanceFromBorder_ = other.distanceFromBorder_;
      cornerResponseScale_ = other.cornerResponseScale_;
      verifyFeatures_ = other.verifyFeatures_;
      verificationDistance_ = other.verificationDistance_;
      verifyLongFeatures_ = other.verifyLongFeatures_;
      longFeatureVerificationThreshold_ = other.longFeatureVerificationThreshold_;
      maxLongFeatureAcceleration_ = other.maxLongFeatureAcceleration_;
      verifyLongFeatureAcceleration_ = other.verifyLongFeatureAcceleration_;
      verifyLongFeatureTriggerRatio_ = other.verifyLongFeatureTriggerRatio_;
      histogramEqualization_ = other.histogramEqualization_;
      useSyntheticZeroMotionTracksAllFrames_ = other.useSyntheticZeroMotionTracksAllFrames_;
      useSyntheticZeroMotionTracksFirstFrame_ = other.useSyntheticZeroMotionTracksFirstFrame_;
      gainCorrection_ = other.gainCorrection_;
      fastGainCorrection_ = other.fastGainCorrection_;
      gainCorrectionMultipleHypotheses_ = other.gainCorrectionMultipleHypotheses_;
      gainCorrectionInlierImprovementFrac_ = other.gainCorrectionInlierImprovementFrac_;
      gainCorrectionBrightReference_ = other.gainCorrectionBrightReference_;
      gainCorrectionTriggeringRatio_ = other.gainCorrectionTriggeringRatio_;
      fracGainFeatureSize_ = other.fracGainFeatureSize_;
      fracGainStep_ = other.fracGainStep_;
      gainCorrectMode_ = other.gainCorrectMode_;
      gainBiasBounds_ = other.gainBiasBounds_ != null ? other.gainBiasBounds_.Clone() : null;
      imageFormat_ = other.imageFormat_;
      descriptorExtractorType_ = other.descriptorExtractorType_;
      computeDerivativeInPyramid_ = other.computeDerivativeInPyramid_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionFlowComputationOptions Clone() {
      return new RegionFlowComputationOptions(this);
    }

    /// <summary>Field number for the "tracking_options" field.</summary>
    public const int TrackingOptionsFieldNumber = 1;
    private global::Mediapipe.TrackingOptions trackingOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TrackingOptions TrackingOptions {
      get { return trackingOptions_; }
      set {
        trackingOptions_ = value;
      }
    }

    /// <summary>Field number for the "min_feature_inliers" field.</summary>
    public const int MinFeatureInliersFieldNumber = 2;
    private readonly static int MinFeatureInliersDefaultValue = 3;

    private int minFeatureInliers_;
    /// <summary>
    /// Features are binned into grids of different resolutions (see
    /// fast_estimation_block_size below) and retained if they survive a localized
    /// translation based RANSAC algorithm and at the survivors are at least of
    /// size min_feature_inliers. Must be at least 3!
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinFeatureInliers {
      get { if ((_hasBits0 & 1) != 0) { return minFeatureInliers_; } else { return MinFeatureInliersDefaultValue; } }
      set {
        _hasBits0 |= 1;
        minFeatureInliers_ = value;
      }
    }
    /// <summary>Gets whether the "min_feature_inliers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatureInliers {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "min_feature_inliers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatureInliers() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "relative_min_feature_inliers" field.</summary>
    public const int RelativeMinFeatureInliersFieldNumber = 46;
    private readonly static float RelativeMinFeatureInliersDefaultValue = 0.2F;

    private float relativeMinFeatureInliers_;
    /// <summary>
    /// Relative number of inlier features w.r.t. average number of features
    /// per grid bin. Maximum of both thresholds is used as actual threshold.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RelativeMinFeatureInliers {
      get { if ((_hasBits0 & 268435456) != 0) { return relativeMinFeatureInliers_; } else { return RelativeMinFeatureInliersDefaultValue; } }
      set {
        _hasBits0 |= 268435456;
        relativeMinFeatureInliers_ = value;
      }
    }
    /// <summary>Gets whether the "relative_min_feature_inliers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRelativeMinFeatureInliers {
      get { return (_hasBits0 & 268435456) != 0; }
    }
    /// <summary>Clears the value of the "relative_min_feature_inliers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRelativeMinFeatureInliers() {
      _hasBits0 &= ~268435456;
    }

    /// <summary>Field number for the "pre_blur_sigma" field.</summary>
    public const int PreBlurSigmaFieldNumber = 33;
    private readonly static float PreBlurSigmaDefaultValue = 0.8F;

    private float preBlurSigma_;
    /// <summary>
    /// Pre-blur before computing features to reduce noise. Set to zero for no
    /// blurring.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float PreBlurSigma {
      get { if ((_hasBits0 & 262144) != 0) { return preBlurSigma_; } else { return PreBlurSigmaDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        preBlurSigma_ = value;
      }
    }
    /// <summary>Gets whether the "pre_blur_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPreBlurSigma {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "pre_blur_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPreBlurSigma() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "ransac_rounds_per_region" field.</summary>
    public const int RansacRoundsPerRegionFieldNumber = 3;
    private readonly static int RansacRoundsPerRegionDefaultValue = 15;

    private int ransacRoundsPerRegion_;
    /// <summary>
    /// Number of ransac rounds to estimate per region flow vector. This could be
    /// adaptive, but the required number of rounds is so low, that estimating
    /// the bound is more costly than just running it for a fixed number of times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RansacRoundsPerRegion {
      get { if ((_hasBits0 & 2) != 0) { return ransacRoundsPerRegion_; } else { return RansacRoundsPerRegionDefaultValue; } }
      set {
        _hasBits0 |= 2;
        ransacRoundsPerRegion_ = value;
      }
    }
    /// <summary>Gets whether the "ransac_rounds_per_region" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRansacRoundsPerRegion {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "ransac_rounds_per_region" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRansacRoundsPerRegion() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "absolute_inlier_error_threshold" field.</summary>
    public const int AbsoluteInlierErrorThresholdFieldNumber = 4;
    private readonly static float AbsoluteInlierErrorThresholdDefaultValue = 2F;

    private float absoluteInlierErrorThreshold_;
    /// <summary>
    /// Error thresholds for a feature to be considered as an inlier in
    /// pixel-distance. The max of all three thresholds below is used as the actual
    /// threshold.
    /// Absolute in pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AbsoluteInlierErrorThreshold {
      get { if ((_hasBits0 & 4) != 0) { return absoluteInlierErrorThreshold_; } else { return AbsoluteInlierErrorThresholdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        absoluteInlierErrorThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "absolute_inlier_error_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAbsoluteInlierErrorThreshold {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "absolute_inlier_error_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAbsoluteInlierErrorThreshold() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "frac_inlier_error_threshold" field.</summary>
    public const int FracInlierErrorThresholdFieldNumber = 52;
    private readonly static float FracInlierErrorThresholdDefaultValue = 0F;

    private float fracInlierErrorThreshold_;
    /// <summary>
    /// Scaled w.r.t. frame diameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FracInlierErrorThreshold {
      get { if ((_hasBits1 & 4) != 0) { return fracInlierErrorThreshold_; } else { return FracInlierErrorThresholdDefaultValue; } }
      set {
        _hasBits1 |= 4;
        fracInlierErrorThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "frac_inlier_error_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFracInlierErrorThreshold {
      get { return (_hasBits1 & 4) != 0; }
    }
    /// <summary>Clears the value of the "frac_inlier_error_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFracInlierErrorThreshold() {
      _hasBits1 &= ~4;
    }

    /// <summary>Field number for the "relative_inlier_error_threshold" field.</summary>
    public const int RelativeInlierErrorThresholdFieldNumber = 44;
    private readonly static float RelativeInlierErrorThresholdDefaultValue = 0.1F;

    private float relativeInlierErrorThreshold_;
    /// <summary>
    /// Scaled w.r.t model estimated during each RANSAC round.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RelativeInlierErrorThreshold {
      get { if ((_hasBits0 & 67108864) != 0) { return relativeInlierErrorThreshold_; } else { return RelativeInlierErrorThresholdDefaultValue; } }
      set {
        _hasBits0 |= 67108864;
        relativeInlierErrorThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "relative_inlier_error_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRelativeInlierErrorThreshold {
      get { return (_hasBits0 & 67108864) != 0; }
    }
    /// <summary>Clears the value of the "relative_inlier_error_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRelativeInlierErrorThreshold() {
      _hasBits0 &= ~67108864;
    }

    /// <summary>Field number for the "top_inlier_sets" field.</summary>
    public const int TopInlierSetsFieldNumber = 45;
    private readonly static int TopInlierSetsDefaultValue = 2;

    private int topInlierSets_;
    /// <summary>
    /// Returns for each grid only the top N inlier sets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TopInlierSets {
      get { if ((_hasBits0 & 134217728) != 0) { return topInlierSets_; } else { return TopInlierSetsDefaultValue; } }
      set {
        _hasBits0 |= 134217728;
        topInlierSets_ = value;
      }
    }
    /// <summary>Gets whether the "top_inlier_sets" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTopInlierSets {
      get { return (_hasBits0 & 134217728) != 0; }
    }
    /// <summary>Clears the value of the "top_inlier_sets" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTopInlierSets() {
      _hasBits0 &= ~134217728;
    }

    /// <summary>Field number for the "no_estimation_mode" field.</summary>
    public const int NoEstimationModeFieldNumber = 40;
    private readonly static bool NoEstimationModeDefaultValue = false;

    private bool noEstimationMode_;
    /// <summary>
    /// For debugging purposes, uses all tracked features regardless of the above
    /// setting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool NoEstimationMode {
      get { if ((_hasBits0 & 16777216) != 0) { return noEstimationMode_; } else { return NoEstimationModeDefaultValue; } }
      set {
        _hasBits0 |= 16777216;
        noEstimationMode_ = value;
      }
    }
    /// <summary>Gets whether the "no_estimation_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNoEstimationMode {
      get { return (_hasBits0 & 16777216) != 0; }
    }
    /// <summary>Clears the value of the "no_estimation_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNoEstimationMode() {
      _hasBits0 &= ~16777216;
    }

    /// <summary>Field number for the "fast_estimation_block_size" field.</summary>
    public const int FastEstimationBlockSizeFieldNumber = 6;
    private readonly static float FastEstimationBlockSizeDefaultValue = 0.25F;

    private float fastEstimationBlockSize_;
    /// <summary>
    /// Block size in pixels. If fractional block_size is used (0 &lt; size &lt; 1),
    /// it is interpreted as fraction of the image dimensions.
    /// We use 4 blocks in each dimension by standard.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FastEstimationBlockSize {
      get { if ((_hasBits0 & 8) != 0) { return fastEstimationBlockSize_; } else { return FastEstimationBlockSizeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        fastEstimationBlockSize_ = value;
      }
    }
    /// <summary>Gets whether the "fast_estimation_block_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFastEstimationBlockSize {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "fast_estimation_block_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFastEstimationBlockSize() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "fast_estimation_min_block_size" field.</summary>
    public const int FastEstimationMinBlockSizeFieldNumber = 25;
    private readonly static int FastEstimationMinBlockSizeDefaultValue = 100;

    private int fastEstimationMinBlockSize_;
    /// <summary>
    /// Minimum block size in pixels (larger dimension) to perform fast estimation
    /// on. Pyramid levels are allocated such that
    /// block_size * 0.5^(level - 1) = min_block_size.
    /// At least two levels are used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FastEstimationMinBlockSize {
      get { if ((_hasBits0 & 16384) != 0) { return fastEstimationMinBlockSize_; } else { return FastEstimationMinBlockSizeDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        fastEstimationMinBlockSize_ = value;
      }
    }
    /// <summary>Gets whether the "fast_estimation_min_block_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFastEstimationMinBlockSize {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "fast_estimation_min_block_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFastEstimationMinBlockSize() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "fast_estimation_overlap_grids" field.</summary>
    public const int FastEstimationOverlapGridsFieldNumber = 22;
    private readonly static int FastEstimationOverlapGridsDefaultValue = 3;

    private int fastEstimationOverlapGrids_;
    /// <summary>
    /// We use overlapping versions of the grid, next parameters specifies how
    /// many in each dimensions (total is therefore, the value squared!).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FastEstimationOverlapGrids {
      get { if ((_hasBits0 & 4096) != 0) { return fastEstimationOverlapGrids_; } else { return FastEstimationOverlapGridsDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        fastEstimationOverlapGrids_ = value;
      }
    }
    /// <summary>Gets whether the "fast_estimation_overlap_grids" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFastEstimationOverlapGrids {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "fast_estimation_overlap_grids" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFastEstimationOverlapGrids() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "max_magnitude_threshold_ratio" field.</summary>
    public const int MaxMagnitudeThresholdRatioFieldNumber = 23;
    private readonly static float MaxMagnitudeThresholdRatioDefaultValue = 0.2F;

    private float maxMagnitudeThresholdRatio_;
    /// <summary>
    /// Flow features with motion above this thresholds (w.r.t. frame diameter)
    /// are rejected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MaxMagnitudeThresholdRatio {
      get { if ((_hasBits0 & 8192) != 0) { return maxMagnitudeThresholdRatio_; } else { return MaxMagnitudeThresholdRatioDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        maxMagnitudeThresholdRatio_ = value;
      }
    }
    /// <summary>Gets whether the "max_magnitude_threshold_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxMagnitudeThresholdRatio {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "max_magnitude_threshold_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxMagnitudeThresholdRatio() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "median_magnitude_bounds" field.</summary>
    public const int MedianMagnitudeBoundsFieldNumber = 51;
    private readonly static float MedianMagnitudeBoundsDefaultValue = 0F;

    private float medianMagnitudeBounds_;
    /// <summary>
    /// Flow features that have a motion that is larger than
    /// median_magnitude_bounds times the median magnitude are discarded.
    /// If set to zero, test is not enforced.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MedianMagnitudeBounds {
      get { if ((_hasBits1 & 2) != 0) { return medianMagnitudeBounds_; } else { return MedianMagnitudeBoundsDefaultValue; } }
      set {
        _hasBits1 |= 2;
        medianMagnitudeBounds_ = value;
      }
    }
    /// <summary>Gets whether the "median_magnitude_bounds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMedianMagnitudeBounds {
      get { return (_hasBits1 & 2) != 0; }
    }
    /// <summary>Clears the value of the "median_magnitude_bounds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMedianMagnitudeBounds() {
      _hasBits1 &= ~2;
    }

    /// <summary>Field number for the "irls_initialization" field.</summary>
    public const int IrlsInitializationFieldNumber = 49;
    private readonly static global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization IrlsInitializationDefaultValue = global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization.InitConsistency;

    private global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization irlsInitialization_;
    /// <summary>
    /// If this option is activated, feature's irls weight is initialized to the
    /// inverse of its computed flow.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization IrlsInitialization {
      get { if ((_hasBits0 & -2147483648) != 0) { return irlsInitialization_; } else { return IrlsInitializationDefaultValue; } }
      set {
        _hasBits0 |= -2147483648;
        irlsInitialization_ = value;
      }
    }
    /// <summary>Gets whether the "irls_initialization" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsInitialization {
      get { return (_hasBits0 & -2147483648) != 0; }
    }
    /// <summary>Clears the value of the "irls_initialization" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsInitialization() {
      _hasBits0 &= ~-2147483648;
    }

    /// <summary>Field number for the "downsample_mode" field.</summary>
    public const int DownsampleModeFieldNumber = 11;
    private readonly static global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode DownsampleModeDefaultValue = global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode.DownsampleNone;

    private global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode downsampleMode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode DownsampleMode {
      get { if ((_hasBits0 & 16) != 0) { return downsampleMode_; } else { return DownsampleModeDefaultValue; } }
      set {
        _hasBits0 |= 16;
        downsampleMode_ = value;
      }
    }
    /// <summary>Gets whether the "downsample_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDownsampleMode {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "downsample_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDownsampleMode() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "downsampling_size" field.</summary>
    public const int DownsamplingSizeFieldNumber = 12;
    private readonly static int DownsamplingSizeDefaultValue = 256;

    private int downsamplingSize_;
    /// <summary>
    /// Specify the size of either dimension here, the frame will be
    /// downsampled to fit downsampling_size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DownsamplingSize {
      get { if ((_hasBits0 & 32) != 0) { return downsamplingSize_; } else { return DownsamplingSizeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        downsamplingSize_ = value;
      }
    }
    /// <summary>Gets whether the "downsampling_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDownsamplingSize {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "downsampling_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDownsamplingSize() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "downsample_factor" field.</summary>
    public const int DownsampleFactorFieldNumber = 18;
    private readonly static float DownsampleFactorDefaultValue = 2F;

    private float downsampleFactor_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float DownsampleFactor {
      get { if ((_hasBits0 & 512) != 0) { return downsampleFactor_; } else { return DownsampleFactorDefaultValue; } }
      set {
        _hasBits0 |= 512;
        downsampleFactor_ = value;
      }
    }
    /// <summary>Gets whether the "downsample_factor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDownsampleFactor {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "downsample_factor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDownsampleFactor() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "round_downsample_factor" field.</summary>
    public const int RoundDownsampleFactorFieldNumber = 62;
    private readonly static bool RoundDownsampleFactorDefaultValue = false;

    private bool roundDownsampleFactor_;
    /// <summary>
    /// If set, we will force the computed downsampling factor to be the nearest
    /// integer, resulting in faster downsampling.  This will have no effect for
    /// DOWNSAMPLE_TO_INPUT_SIZE, DOWNSAMPLE_BY_FACTOR, and DOWNSAMPLE_BY_SCHEDULE,
    /// which should have exact values defined.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RoundDownsampleFactor {
      get { if ((_hasBits1 & 2048) != 0) { return roundDownsampleFactor_; } else { return RoundDownsampleFactorDefaultValue; } }
      set {
        _hasBits1 |= 2048;
        roundDownsampleFactor_ = value;
      }
    }
    /// <summary>Gets whether the "round_downsample_factor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRoundDownsampleFactor {
      get { return (_hasBits1 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "round_downsample_factor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRoundDownsampleFactor() {
      _hasBits1 &= ~2048;
    }

    /// <summary>Field number for the "downsample_schedule" field.</summary>
    public const int DownsampleScheduleFieldNumber = 19;
    private global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule downsampleSchedule_;
    /// <summary>
    /// Used if downsample_mode is DOWNSAMPLE_BY_SCHEDULE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule DownsampleSchedule {
      get { return downsampleSchedule_; }
      set {
        downsampleSchedule_ = value;
      }
    }

    /// <summary>Field number for the "min_feature_requirement" field.</summary>
    public const int MinFeatureRequirementFieldNumber = 13;
    private readonly static int MinFeatureRequirementDefaultValue = 20;

    private int minFeatureRequirement_;
    /// <summary>
    /// Minimum number of good features that we require to be present.
    /// Without good features, the estimated motion models will do more harm than
    /// good, so it is better to use simply the identity transform for this frame,
    /// and set the flag unstable_models to true in RegionFlow.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinFeatureRequirement {
      get { if ((_hasBits0 & 64) != 0) { return minFeatureRequirement_; } else { return MinFeatureRequirementDefaultValue; } }
      set {
        _hasBits0 |= 64;
        minFeatureRequirement_ = value;
      }
    }
    /// <summary>Gets whether the "min_feature_requirement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatureRequirement {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "min_feature_requirement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatureRequirement() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "min_feature_cover" field.</summary>
    public const int MinFeatureCoverFieldNumber = 14;
    private readonly static float MinFeatureCoverDefaultValue = 0.15F;

    private float minFeatureCover_;
    /// <summary>
    /// We also require features to cover a minimum percentage area of the frame.
    /// We use downsampling and plot each feature by a 1 in a grid, this is
    /// equivalent to plotting each feature by a rectangle in the original frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinFeatureCover {
      get { if ((_hasBits0 & 128) != 0) { return minFeatureCover_; } else { return MinFeatureCoverDefaultValue; } }
      set {
        _hasBits0 |= 128;
        minFeatureCover_ = value;
      }
    }
    /// <summary>Gets whether the "min_feature_cover" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatureCover {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "min_feature_cover" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatureCover() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "min_feature_cover_grid" field.</summary>
    public const int MinFeatureCoverGridFieldNumber = 20;
    private readonly static int MinFeatureCoverGridDefaultValue = 8;

    private int minFeatureCoverGrid_;
    /// <summary>
    /// Grid size for above min feature cover.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinFeatureCoverGrid {
      get { if ((_hasBits0 & 1024) != 0) { return minFeatureCoverGrid_; } else { return MinFeatureCoverGridDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        minFeatureCoverGrid_ = value;
      }
    }
    /// <summary>Gets whether the "min_feature_cover_grid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatureCoverGrid {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "min_feature_cover_grid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatureCoverGrid() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "compute_blur_score" field.</summary>
    public const int ComputeBlurScoreFieldNumber = 17;
    private readonly static bool ComputeBlurScoreDefaultValue = false;

    private bool computeBlurScore_;
    /// <summary>
    /// Computes blur score for each frame. Score is proportional to amount of
    /// blur present in a frame, i.e. higher scores reflect more blurred frames.
    /// Note that the score is dependent on the gradient distribution of the image
    /// content, i.e. the score itself is rather meaningless but needs to be
    /// compared to scores of neighboring frames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ComputeBlurScore {
      get { if ((_hasBits0 & 256) != 0) { return computeBlurScore_; } else { return ComputeBlurScoreDefaultValue; } }
      set {
        _hasBits0 |= 256;
        computeBlurScore_ = value;
      }
    }
    /// <summary>Gets whether the "compute_blur_score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasComputeBlurScore {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "compute_blur_score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearComputeBlurScore() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "blur_score_options" field.</summary>
    public const int BlurScoreOptionsFieldNumber = 31;
    private global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions blurScoreOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions BlurScoreOptions {
      get { return blurScoreOptions_; }
      set {
        blurScoreOptions_ = value;
      }
    }

    /// <summary>Field number for the "visual_consistency_options" field.</summary>
    public const int VisualConsistencyOptionsFieldNumber = 55;
    private global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions visualConsistencyOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions VisualConsistencyOptions {
      get { return visualConsistencyOptions_; }
      set {
        visualConsistencyOptions_ = value;
      }
    }

    /// <summary>Field number for the "patch_descriptor_radius" field.</summary>
    public const int PatchDescriptorRadiusFieldNumber = 21;
    private readonly static int PatchDescriptorRadiusDefaultValue = 3;

    private int patchDescriptorRadius_;
    /// <summary>
    /// Radius of patch descriptor computed during RetrieveRegionFlowFeatureList
    /// call.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PatchDescriptorRadius {
      get { if ((_hasBits0 & 2048) != 0) { return patchDescriptorRadius_; } else { return PatchDescriptorRadiusDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        patchDescriptorRadius_ = value;
      }
    }
    /// <summary>Gets whether the "patch_descriptor_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPatchDescriptorRadius {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "patch_descriptor_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPatchDescriptorRadius() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "distance_from_border" field.</summary>
    public const int DistanceFromBorderFieldNumber = 50;
    private readonly static int DistanceFromBorderDefaultValue = 3;

    private int distanceFromBorder_;
    /// <summary>
    /// Minimum distance from image border. Must be greater or equal to
    /// patch_descriptor_radius.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DistanceFromBorder {
      get { if ((_hasBits1 & 1) != 0) { return distanceFromBorder_; } else { return DistanceFromBorderDefaultValue; } }
      set {
        _hasBits1 |= 1;
        distanceFromBorder_ = value;
      }
    }
    /// <summary>Gets whether the "distance_from_border" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDistanceFromBorder {
      get { return (_hasBits1 & 1) != 0; }
    }
    /// <summary>Clears the value of the "distance_from_border" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDistanceFromBorder() {
      _hasBits1 &= ~1;
    }

    /// <summary>Field number for the "corner_response_scale" field.</summary>
    public const int CornerResponseScaleFieldNumber = 26;
    private readonly static float CornerResponseScaleDefaultValue = 1500F;

    private float cornerResponseScale_;
    /// <summary>
    /// Corner response is scaled by scalar below and normalized to lie within
    /// [0, 1], where 0 is low corner score and 1 high corner score.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float CornerResponseScale {
      get { if ((_hasBits0 & 32768) != 0) { return cornerResponseScale_; } else { return CornerResponseScaleDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        cornerResponseScale_ = value;
      }
    }
    /// <summary>Gets whether the "corner_response_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCornerResponseScale {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "corner_response_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCornerResponseScale() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "verify_features" field.</summary>
    public const int VerifyFeaturesFieldNumber = 27;
    private readonly static bool VerifyFeaturesDefaultValue = false;

    private bool verifyFeatures_;
    /// <summary>
    /// Verifies reliablity of features, by back-tracking operation from matched
    /// location. If returned location is within verification_distance feature is
    /// accepted otherwise discarded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool VerifyFeatures {
      get { if ((_hasBits0 & 65536) != 0) { return verifyFeatures_; } else { return VerifyFeaturesDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        verifyFeatures_ = value;
      }
    }
    /// <summary>Gets whether the "verify_features" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVerifyFeatures {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "verify_features" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVerifyFeatures() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "verification_distance" field.</summary>
    public const int VerificationDistanceFieldNumber = 28;
    private readonly static float VerificationDistanceDefaultValue = 0.5F;

    private float verificationDistance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float VerificationDistance {
      get { if ((_hasBits0 & 131072) != 0) { return verificationDistance_; } else { return VerificationDistanceDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        verificationDistance_ = value;
      }
    }
    /// <summary>Gets whether the "verification_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVerificationDistance {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "verification_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVerificationDistance() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "verify_long_features" field.</summary>
    public const int VerifyLongFeaturesFieldNumber = 53;
    private readonly static bool VerifyLongFeaturesDefaultValue = true;

    private bool verifyLongFeatures_;
    /// <summary>
    /// If set, consistency of long features is verified (in case tracking_policy
    /// is set to POLICY_LONG_FEATURES) by extracting a patch
    /// around the feature during the very first observation and comparing the
    /// matching patching along the long feature trajectory via SSD. If the
    /// difference is above the long_feature_verification_threshold the feature is
    /// removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool VerifyLongFeatures {
      get { if ((_hasBits1 & 8) != 0) { return verifyLongFeatures_; } else { return VerifyLongFeaturesDefaultValue; } }
      set {
        _hasBits1 |= 8;
        verifyLongFeatures_ = value;
      }
    }
    /// <summary>Gets whether the "verify_long_features" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVerifyLongFeatures {
      get { return (_hasBits1 & 8) != 0; }
    }
    /// <summary>Clears the value of the "verify_long_features" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVerifyLongFeatures() {
      _hasBits1 &= ~8;
    }

    /// <summary>Field number for the "long_feature_verification_threshold" field.</summary>
    public const int LongFeatureVerificationThresholdFieldNumber = 54;
    private readonly static float LongFeatureVerificationThresholdDefaultValue = 0.04F;

    private float longFeatureVerificationThreshold_;
    /// <summary>
    /// Maximum average per pixel error (in L1 norm) in the normalized intensity
    /// domain for matching patches to be considered to be consistent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LongFeatureVerificationThreshold {
      get { if ((_hasBits1 & 16) != 0) { return longFeatureVerificationThreshold_; } else { return LongFeatureVerificationThresholdDefaultValue; } }
      set {
        _hasBits1 |= 16;
        longFeatureVerificationThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "long_feature_verification_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLongFeatureVerificationThreshold {
      get { return (_hasBits1 & 16) != 0; }
    }
    /// <summary>Clears the value of the "long_feature_verification_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLongFeatureVerificationThreshold() {
      _hasBits1 &= ~16;
    }

    /// <summary>Field number for the "max_long_feature_acceleration" field.</summary>
    public const int MaxLongFeatureAccelerationFieldNumber = 56;
    private readonly static float MaxLongFeatureAccelerationDefaultValue = 5F;

    private float maxLongFeatureAcceleration_;
    /// <summary>
    /// Long features are expected to have limited acceleration over time.
    /// If acceleration exceeds specified value based on the setting in
    /// verify_long_feature_acceleration either:
    /// a) verify_long_feature_acceleration = false
    ///    A new track is started instead of continuing the old one.
    ///    The track itself is not removed in this case.
    ///
    /// b) verify_long_feature_acceleration = true
    ///    The track is flagged for verification, by back-tracking operation from
    ///    matched location. If track fails verification test it is
    ///    discarded. This only triggers if at least
    ///    verify_long_feature_trigger_ratio of features have been flagged,
    ///    otherwise option a is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MaxLongFeatureAcceleration {
      get { if ((_hasBits1 & 32) != 0) { return maxLongFeatureAcceleration_; } else { return MaxLongFeatureAccelerationDefaultValue; } }
      set {
        _hasBits1 |= 32;
        maxLongFeatureAcceleration_ = value;
      }
    }
    /// <summary>Gets whether the "max_long_feature_acceleration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxLongFeatureAcceleration {
      get { return (_hasBits1 & 32) != 0; }
    }
    /// <summary>Clears the value of the "max_long_feature_acceleration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxLongFeatureAcceleration() {
      _hasBits1 &= ~32;
    }

    /// <summary>Field number for the "verify_long_feature_acceleration" field.</summary>
    public const int VerifyLongFeatureAccelerationFieldNumber = 63;
    private readonly static bool VerifyLongFeatureAccelerationDefaultValue = false;

    private bool verifyLongFeatureAcceleration_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool VerifyLongFeatureAcceleration {
      get { if ((_hasBits1 & 4096) != 0) { return verifyLongFeatureAcceleration_; } else { return VerifyLongFeatureAccelerationDefaultValue; } }
      set {
        _hasBits1 |= 4096;
        verifyLongFeatureAcceleration_ = value;
      }
    }
    /// <summary>Gets whether the "verify_long_feature_acceleration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVerifyLongFeatureAcceleration {
      get { return (_hasBits1 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "verify_long_feature_acceleration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVerifyLongFeatureAcceleration() {
      _hasBits1 &= ~4096;
    }

    /// <summary>Field number for the "verify_long_feature_trigger_ratio" field.</summary>
    public const int VerifyLongFeatureTriggerRatioFieldNumber = 64;
    private readonly static float VerifyLongFeatureTriggerRatioDefaultValue = 0F;

    private float verifyLongFeatureTriggerRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float VerifyLongFeatureTriggerRatio {
      get { if ((_hasBits1 & 8192) != 0) { return verifyLongFeatureTriggerRatio_; } else { return VerifyLongFeatureTriggerRatioDefaultValue; } }
      set {
        _hasBits1 |= 8192;
        verifyLongFeatureTriggerRatio_ = value;
      }
    }
    /// <summary>Gets whether the "verify_long_feature_trigger_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVerifyLongFeatureTriggerRatio {
      get { return (_hasBits1 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "verify_long_feature_trigger_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVerifyLongFeatureTriggerRatio() {
      _hasBits1 &= ~8192;
    }

    /// <summary>Field number for the "histogram_equalization" field.</summary>
    public const int HistogramEqualizationFieldNumber = 57;
    private readonly static bool HistogramEqualizationDefaultValue = false;

    private bool histogramEqualization_;
    /// <summary>
    /// If true, histogram equalization is performed to the input image sequence
    /// before registration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HistogramEqualization {
      get { if ((_hasBits1 & 64) != 0) { return histogramEqualization_; } else { return HistogramEqualizationDefaultValue; } }
      set {
        _hasBits1 |= 64;
        histogramEqualization_ = value;
      }
    }
    /// <summary>Gets whether the "histogram_equalization" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHistogramEqualization {
      get { return (_hasBits1 & 64) != 0; }
    }
    /// <summary>Clears the value of the "histogram_equalization" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHistogramEqualization() {
      _hasBits1 &= ~64;
    }

    /// <summary>Field number for the "use_synthetic_zero_motion_tracks_all_frames" field.</summary>
    public const int UseSyntheticZeroMotionTracksAllFramesFieldNumber = 34;
    private readonly static bool UseSyntheticZeroMotionTracksAllFramesDefaultValue = false;

    private bool useSyntheticZeroMotionTracksAllFrames_;
    /// <summary>
    /// If true, synthetic region flows with zero motion are used for all (or just
    /// the first) frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseSyntheticZeroMotionTracksAllFrames {
      get { if ((_hasBits0 & 524288) != 0) { return useSyntheticZeroMotionTracksAllFrames_; } else { return UseSyntheticZeroMotionTracksAllFramesDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        useSyntheticZeroMotionTracksAllFrames_ = value;
      }
    }
    /// <summary>Gets whether the "use_synthetic_zero_motion_tracks_all_frames" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseSyntheticZeroMotionTracksAllFrames {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "use_synthetic_zero_motion_tracks_all_frames" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseSyntheticZeroMotionTracksAllFrames() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "use_synthetic_zero_motion_tracks_first_frame" field.</summary>
    public const int UseSyntheticZeroMotionTracksFirstFrameFieldNumber = 35;
    private readonly static bool UseSyntheticZeroMotionTracksFirstFrameDefaultValue = false;

    private bool useSyntheticZeroMotionTracksFirstFrame_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseSyntheticZeroMotionTracksFirstFrame {
      get { if ((_hasBits0 & 1048576) != 0) { return useSyntheticZeroMotionTracksFirstFrame_; } else { return UseSyntheticZeroMotionTracksFirstFrameDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        useSyntheticZeroMotionTracksFirstFrame_ = value;
      }
    }
    /// <summary>Gets whether the "use_synthetic_zero_motion_tracks_first_frame" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseSyntheticZeroMotionTracksFirstFrame {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "use_synthetic_zero_motion_tracks_first_frame" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseSyntheticZeroMotionTracksFirstFrame() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "gain_correction" field.</summary>
    public const int GainCorrectionFieldNumber = 36;
    private readonly static bool GainCorrectionDefaultValue = false;

    private bool gainCorrection_;
    /// <summary>
    /// Optional gain correction before tracking features. Improves robustness when
    /// lighting is changing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool GainCorrection {
      get { if ((_hasBits0 & 2097152) != 0) { return gainCorrection_; } else { return GainCorrectionDefaultValue; } }
      set {
        _hasBits0 |= 2097152;
        gainCorrection_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrection {
      get { return (_hasBits0 & 2097152) != 0; }
    }
    /// <summary>Clears the value of the "gain_correction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrection() {
      _hasBits0 &= ~2097152;
    }

    /// <summary>Field number for the "fast_gain_correction" field.</summary>
    public const int FastGainCorrectionFieldNumber = 61;
    private readonly static bool FastGainCorrectionDefaultValue = false;

    private bool fastGainCorrection_;
    /// <summary>
    /// If set performs gain correction by simply equalizing mean intensity
    /// between frames, instead of using ToneEstimation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FastGainCorrection {
      get { if ((_hasBits1 & 1024) != 0) { return fastGainCorrection_; } else { return FastGainCorrectionDefaultValue; } }
      set {
        _hasBits1 |= 1024;
        fastGainCorrection_ = value;
      }
    }
    /// <summary>Gets whether the "fast_gain_correction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFastGainCorrection {
      get { return (_hasBits1 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "fast_gain_correction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFastGainCorrection() {
      _hasBits1 &= ~1024;
    }

    /// <summary>Field number for the "gain_correction_multiple_hypotheses" field.</summary>
    public const int GainCorrectionMultipleHypothesesFieldNumber = 47;
    private readonly static bool GainCorrectionMultipleHypothesesDefaultValue = true;

    private bool gainCorrectionMultipleHypotheses_;
    /// <summary>
    /// If the multiple hypothesis flag is set, features are tracked using both
    /// with and without gain correction, and the hypothesis with more inliers
    /// is selected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool GainCorrectionMultipleHypotheses {
      get { if ((_hasBits0 & 536870912) != 0) { return gainCorrectionMultipleHypotheses_; } else { return GainCorrectionMultipleHypothesesDefaultValue; } }
      set {
        _hasBits0 |= 536870912;
        gainCorrectionMultipleHypotheses_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correction_multiple_hypotheses" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrectionMultipleHypotheses {
      get { return (_hasBits0 & 536870912) != 0; }
    }
    /// <summary>Clears the value of the "gain_correction_multiple_hypotheses" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrectionMultipleHypotheses() {
      _hasBits0 &= ~536870912;
    }

    /// <summary>Field number for the "gain_correction_inlier_improvement_frac" field.</summary>
    public const int GainCorrectionInlierImprovementFracFieldNumber = 48;
    private readonly static float GainCorrectionInlierImprovementFracDefaultValue = 0.1F;

    private float gainCorrectionInlierImprovementFrac_;
    /// <summary>
    /// This flag, when used together with the multiple hypotheses flag, specifies
    /// that gain correction should increase the number of inliers by at least this
    /// fraction for it to be used instead of default tracking.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float GainCorrectionInlierImprovementFrac {
      get { if ((_hasBits0 & 1073741824) != 0) { return gainCorrectionInlierImprovementFrac_; } else { return GainCorrectionInlierImprovementFracDefaultValue; } }
      set {
        _hasBits0 |= 1073741824;
        gainCorrectionInlierImprovementFrac_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correction_inlier_improvement_frac" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrectionInlierImprovementFrac {
      get { return (_hasBits0 & 1073741824) != 0; }
    }
    /// <summary>Clears the value of the "gain_correction_inlier_improvement_frac" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrectionInlierImprovementFrac() {
      _hasBits0 &= ~1073741824;
    }

    /// <summary>Field number for the "gain_correction_bright_reference" field.</summary>
    public const int GainCorrectionBrightReferenceFieldNumber = 59;
    private readonly static bool GainCorrectionBrightReferenceDefaultValue = false;

    private bool gainCorrectionBrightReference_;
    /// <summary>
    /// If set, always uses the brighter frame as reference. This is the
    /// preferred direction of correction, to avoid overexposed regions from
    /// being corrected which leads to spurious matches.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool GainCorrectionBrightReference {
      get { if ((_hasBits1 & 256) != 0) { return gainCorrectionBrightReference_; } else { return GainCorrectionBrightReferenceDefaultValue; } }
      set {
        _hasBits1 |= 256;
        gainCorrectionBrightReference_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correction_bright_reference" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrectionBrightReference {
      get { return (_hasBits1 & 256) != 0; }
    }
    /// <summary>Clears the value of the "gain_correction_bright_reference" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrectionBrightReference() {
      _hasBits1 &= ~256;
    }

    /// <summary>Field number for the "gain_correction_triggering_ratio" field.</summary>
    public const int GainCorrectionTriggeringRatioFieldNumber = 60;
    private readonly static float GainCorrectionTriggeringRatioDefaultValue = 0F;

    private float gainCorrectionTriggeringRatio_;
    /// <summary>
    /// Only performs gain correction if number of tracked features falls under
    /// specified ratio (w.r.t. previous frame).
    /// Set to zero, to always perform gain correction if requested.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float GainCorrectionTriggeringRatio {
      get { if ((_hasBits1 & 512) != 0) { return gainCorrectionTriggeringRatio_; } else { return GainCorrectionTriggeringRatioDefaultValue; } }
      set {
        _hasBits1 |= 512;
        gainCorrectionTriggeringRatio_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correction_triggering_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrectionTriggeringRatio {
      get { return (_hasBits1 & 512) != 0; }
    }
    /// <summary>Clears the value of the "gain_correction_triggering_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrectionTriggeringRatio() {
      _hasBits1 &= ~512;
    }

    /// <summary>Field number for the "frac_gain_feature_size" field.</summary>
    public const int FracGainFeatureSizeFieldNumber = 37;
    private readonly static float FracGainFeatureSizeDefaultValue = 0.3F;

    private float fracGainFeatureSize_;
    /// <summary>
    /// Gain correction is based on a grid of zero motion features, independent of
    /// the underlying motion. Fractional parameter specifies resolution of the
    /// grid w.r.t. frame size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FracGainFeatureSize {
      get { if ((_hasBits0 & 4194304) != 0) { return fracGainFeatureSize_; } else { return FracGainFeatureSizeDefaultValue; } }
      set {
        _hasBits0 |= 4194304;
        fracGainFeatureSize_ = value;
      }
    }
    /// <summary>Gets whether the "frac_gain_feature_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFracGainFeatureSize {
      get { return (_hasBits0 & 4194304) != 0; }
    }
    /// <summary>Clears the value of the "frac_gain_feature_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFracGainFeatureSize() {
      _hasBits0 &= ~4194304;
    }

    /// <summary>Field number for the "frac_gain_step" field.</summary>
    public const int FracGainStepFieldNumber = 38;
    private readonly static float FracGainStepDefaultValue = 0.1F;

    private float fracGainStep_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FracGainStep {
      get { if ((_hasBits0 & 8388608) != 0) { return fracGainStep_; } else { return FracGainStepDefaultValue; } }
      set {
        _hasBits0 |= 8388608;
        fracGainStep_ = value;
      }
    }
    /// <summary>Gets whether the "frac_gain_step" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFracGainStep {
      get { return (_hasBits0 & 8388608) != 0; }
    }
    /// <summary>Clears the value of the "frac_gain_step" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFracGainStep() {
      _hasBits0 &= ~8388608;
    }

    /// <summary>Field number for the "gain_correct_mode" field.</summary>
    public const int GainCorrectModeFieldNumber = 41;
    private readonly static global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode GainCorrectModeDefaultValue = global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode.GainCorrectDefaultUser;

    private global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode gainCorrectMode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode GainCorrectMode {
      get { if ((_hasBits0 & 33554432) != 0) { return gainCorrectMode_; } else { return GainCorrectModeDefaultValue; } }
      set {
        _hasBits0 |= 33554432;
        gainCorrectMode_ = value;
      }
    }
    /// <summary>Gets whether the "gain_correct_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGainCorrectMode {
      get { return (_hasBits0 & 33554432) != 0; }
    }
    /// <summary>Clears the value of the "gain_correct_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGainCorrectMode() {
      _hasBits0 &= ~33554432;
    }

    /// <summary>Field number for the "gain_bias_bounds" field.</summary>
    public const int GainBiasBoundsFieldNumber = 39;
    private global::Mediapipe.ToneEstimationOptions.Types.GainBiasBounds gainBiasBounds_;
    /// <summary>
    /// Bounds for the estimated model. If not set externally, will be set
    /// based on GainCorrectMode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ToneEstimationOptions.Types.GainBiasBounds GainBiasBounds {
      get { return gainBiasBounds_; }
      set {
        gainBiasBounds_ = value;
      }
    }

    /// <summary>Field number for the "image_format" field.</summary>
    public const int ImageFormatFieldNumber = 58;
    private readonly static global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat ImageFormatDefaultValue = global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat.FormatRgb;

    private global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat imageFormat_;
    /// <summary>
    /// Image format of the input.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat ImageFormat {
      get { if ((_hasBits1 & 128) != 0) { return imageFormat_; } else { return ImageFormatDefaultValue; } }
      set {
        _hasBits1 |= 128;
        imageFormat_ = value;
      }
    }
    /// <summary>Gets whether the "image_format" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImageFormat {
      get { return (_hasBits1 & 128) != 0; }
    }
    /// <summary>Clears the value of the "image_format" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImageFormat() {
      _hasBits1 &= ~128;
    }

    /// <summary>Field number for the "descriptor_extractor_type" field.</summary>
    public const int DescriptorExtractorTypeFieldNumber = 65;
    private readonly static global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType DescriptorExtractorTypeDefaultValue = global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType.Orb;

    private global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType descriptorExtractorType_;
    /// <summary>
    /// The descriptor extractor type used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType DescriptorExtractorType {
      get { if ((_hasBits1 & 16384) != 0) { return descriptorExtractorType_; } else { return DescriptorExtractorTypeDefaultValue; } }
      set {
        _hasBits1 |= 16384;
        descriptorExtractorType_ = value;
      }
    }
    /// <summary>Gets whether the "descriptor_extractor_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDescriptorExtractorType {
      get { return (_hasBits1 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "descriptor_extractor_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDescriptorExtractorType() {
      _hasBits1 &= ~16384;
    }

    /// <summary>Field number for the "compute_derivative_in_pyramid" field.</summary>
    public const int ComputeDerivativeInPyramidFieldNumber = 66;
    private readonly static bool ComputeDerivativeInPyramidDefaultValue = true;

    private bool computeDerivativeInPyramid_;
    /// <summary>
    /// Whether to compute derivatives when building the pyramid. When set to
    /// true, it's building a Laplacian pyramid. When set to false, it's building
    /// a Gaussian pyramid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ComputeDerivativeInPyramid {
      get { if ((_hasBits1 & 32768) != 0) { return computeDerivativeInPyramid_; } else { return ComputeDerivativeInPyramidDefaultValue; } }
      set {
        _hasBits1 |= 32768;
        computeDerivativeInPyramid_ = value;
      }
    }
    /// <summary>Gets whether the "compute_derivative_in_pyramid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasComputeDerivativeInPyramid {
      get { return (_hasBits1 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "compute_derivative_in_pyramid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearComputeDerivativeInPyramid() {
      _hasBits1 &= ~32768;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RegionFlowComputationOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RegionFlowComputationOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TrackingOptions, other.TrackingOptions)) return false;
      if (MinFeatureInliers != other.MinFeatureInliers) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RelativeMinFeatureInliers, other.RelativeMinFeatureInliers)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PreBlurSigma, other.PreBlurSigma)) return false;
      if (RansacRoundsPerRegion != other.RansacRoundsPerRegion) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AbsoluteInlierErrorThreshold, other.AbsoluteInlierErrorThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracInlierErrorThreshold, other.FracInlierErrorThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RelativeInlierErrorThreshold, other.RelativeInlierErrorThreshold)) return false;
      if (TopInlierSets != other.TopInlierSets) return false;
      if (NoEstimationMode != other.NoEstimationMode) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FastEstimationBlockSize, other.FastEstimationBlockSize)) return false;
      if (FastEstimationMinBlockSize != other.FastEstimationMinBlockSize) return false;
      if (FastEstimationOverlapGrids != other.FastEstimationOverlapGrids) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxMagnitudeThresholdRatio, other.MaxMagnitudeThresholdRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MedianMagnitudeBounds, other.MedianMagnitudeBounds)) return false;
      if (IrlsInitialization != other.IrlsInitialization) return false;
      if (DownsampleMode != other.DownsampleMode) return false;
      if (DownsamplingSize != other.DownsamplingSize) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DownsampleFactor, other.DownsampleFactor)) return false;
      if (RoundDownsampleFactor != other.RoundDownsampleFactor) return false;
      if (!object.Equals(DownsampleSchedule, other.DownsampleSchedule)) return false;
      if (MinFeatureRequirement != other.MinFeatureRequirement) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinFeatureCover, other.MinFeatureCover)) return false;
      if (MinFeatureCoverGrid != other.MinFeatureCoverGrid) return false;
      if (ComputeBlurScore != other.ComputeBlurScore) return false;
      if (!object.Equals(BlurScoreOptions, other.BlurScoreOptions)) return false;
      if (!object.Equals(VisualConsistencyOptions, other.VisualConsistencyOptions)) return false;
      if (PatchDescriptorRadius != other.PatchDescriptorRadius) return false;
      if (DistanceFromBorder != other.DistanceFromBorder) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(CornerResponseScale, other.CornerResponseScale)) return false;
      if (VerifyFeatures != other.VerifyFeatures) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(VerificationDistance, other.VerificationDistance)) return false;
      if (VerifyLongFeatures != other.VerifyLongFeatures) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LongFeatureVerificationThreshold, other.LongFeatureVerificationThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxLongFeatureAcceleration, other.MaxLongFeatureAcceleration)) return false;
      if (VerifyLongFeatureAcceleration != other.VerifyLongFeatureAcceleration) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(VerifyLongFeatureTriggerRatio, other.VerifyLongFeatureTriggerRatio)) return false;
      if (HistogramEqualization != other.HistogramEqualization) return false;
      if (UseSyntheticZeroMotionTracksAllFrames != other.UseSyntheticZeroMotionTracksAllFrames) return false;
      if (UseSyntheticZeroMotionTracksFirstFrame != other.UseSyntheticZeroMotionTracksFirstFrame) return false;
      if (GainCorrection != other.GainCorrection) return false;
      if (FastGainCorrection != other.FastGainCorrection) return false;
      if (GainCorrectionMultipleHypotheses != other.GainCorrectionMultipleHypotheses) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GainCorrectionInlierImprovementFrac, other.GainCorrectionInlierImprovementFrac)) return false;
      if (GainCorrectionBrightReference != other.GainCorrectionBrightReference) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GainCorrectionTriggeringRatio, other.GainCorrectionTriggeringRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracGainFeatureSize, other.FracGainFeatureSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracGainStep, other.FracGainStep)) return false;
      if (GainCorrectMode != other.GainCorrectMode) return false;
      if (!object.Equals(GainBiasBounds, other.GainBiasBounds)) return false;
      if (ImageFormat != other.ImageFormat) return false;
      if (DescriptorExtractorType != other.DescriptorExtractorType) return false;
      if (ComputeDerivativeInPyramid != other.ComputeDerivativeInPyramid) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (trackingOptions_ != null) hash ^= TrackingOptions.GetHashCode();
      if (HasMinFeatureInliers) hash ^= MinFeatureInliers.GetHashCode();
      if (HasRelativeMinFeatureInliers) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RelativeMinFeatureInliers);
      if (HasPreBlurSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PreBlurSigma);
      if (HasRansacRoundsPerRegion) hash ^= RansacRoundsPerRegion.GetHashCode();
      if (HasAbsoluteInlierErrorThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AbsoluteInlierErrorThreshold);
      if (HasFracInlierErrorThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracInlierErrorThreshold);
      if (HasRelativeInlierErrorThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RelativeInlierErrorThreshold);
      if (HasTopInlierSets) hash ^= TopInlierSets.GetHashCode();
      if (HasNoEstimationMode) hash ^= NoEstimationMode.GetHashCode();
      if (HasFastEstimationBlockSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FastEstimationBlockSize);
      if (HasFastEstimationMinBlockSize) hash ^= FastEstimationMinBlockSize.GetHashCode();
      if (HasFastEstimationOverlapGrids) hash ^= FastEstimationOverlapGrids.GetHashCode();
      if (HasMaxMagnitudeThresholdRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxMagnitudeThresholdRatio);
      if (HasMedianMagnitudeBounds) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MedianMagnitudeBounds);
      if (HasIrlsInitialization) hash ^= IrlsInitialization.GetHashCode();
      if (HasDownsampleMode) hash ^= DownsampleMode.GetHashCode();
      if (HasDownsamplingSize) hash ^= DownsamplingSize.GetHashCode();
      if (HasDownsampleFactor) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DownsampleFactor);
      if (HasRoundDownsampleFactor) hash ^= RoundDownsampleFactor.GetHashCode();
      if (downsampleSchedule_ != null) hash ^= DownsampleSchedule.GetHashCode();
      if (HasMinFeatureRequirement) hash ^= MinFeatureRequirement.GetHashCode();
      if (HasMinFeatureCover) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinFeatureCover);
      if (HasMinFeatureCoverGrid) hash ^= MinFeatureCoverGrid.GetHashCode();
      if (HasComputeBlurScore) hash ^= ComputeBlurScore.GetHashCode();
      if (blurScoreOptions_ != null) hash ^= BlurScoreOptions.GetHashCode();
      if (visualConsistencyOptions_ != null) hash ^= VisualConsistencyOptions.GetHashCode();
      if (HasPatchDescriptorRadius) hash ^= PatchDescriptorRadius.GetHashCode();
      if (HasDistanceFromBorder) hash ^= DistanceFromBorder.GetHashCode();
      if (HasCornerResponseScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(CornerResponseScale);
      if (HasVerifyFeatures) hash ^= VerifyFeatures.GetHashCode();
      if (HasVerificationDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(VerificationDistance);
      if (HasVerifyLongFeatures) hash ^= VerifyLongFeatures.GetHashCode();
      if (HasLongFeatureVerificationThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LongFeatureVerificationThreshold);
      if (HasMaxLongFeatureAcceleration) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxLongFeatureAcceleration);
      if (HasVerifyLongFeatureAcceleration) hash ^= VerifyLongFeatureAcceleration.GetHashCode();
      if (HasVerifyLongFeatureTriggerRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(VerifyLongFeatureTriggerRatio);
      if (HasHistogramEqualization) hash ^= HistogramEqualization.GetHashCode();
      if (HasUseSyntheticZeroMotionTracksAllFrames) hash ^= UseSyntheticZeroMotionTracksAllFrames.GetHashCode();
      if (HasUseSyntheticZeroMotionTracksFirstFrame) hash ^= UseSyntheticZeroMotionTracksFirstFrame.GetHashCode();
      if (HasGainCorrection) hash ^= GainCorrection.GetHashCode();
      if (HasFastGainCorrection) hash ^= FastGainCorrection.GetHashCode();
      if (HasGainCorrectionMultipleHypotheses) hash ^= GainCorrectionMultipleHypotheses.GetHashCode();
      if (HasGainCorrectionInlierImprovementFrac) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GainCorrectionInlierImprovementFrac);
      if (HasGainCorrectionBrightReference) hash ^= GainCorrectionBrightReference.GetHashCode();
      if (HasGainCorrectionTriggeringRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GainCorrectionTriggeringRatio);
      if (HasFracGainFeatureSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracGainFeatureSize);
      if (HasFracGainStep) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracGainStep);
      if (HasGainCorrectMode) hash ^= GainCorrectMode.GetHashCode();
      if (gainBiasBounds_ != null) hash ^= GainBiasBounds.GetHashCode();
      if (HasImageFormat) hash ^= ImageFormat.GetHashCode();
      if (HasDescriptorExtractorType) hash ^= DescriptorExtractorType.GetHashCode();
      if (HasComputeDerivativeInPyramid) hash ^= ComputeDerivativeInPyramid.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (trackingOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrackingOptions);
      }
      if (HasMinFeatureInliers) {
        output.WriteRawTag(16);
        output.WriteInt32(MinFeatureInliers);
      }
      if (HasRansacRoundsPerRegion) {
        output.WriteRawTag(24);
        output.WriteInt32(RansacRoundsPerRegion);
      }
      if (HasAbsoluteInlierErrorThreshold) {
        output.WriteRawTag(37);
        output.WriteFloat(AbsoluteInlierErrorThreshold);
      }
      if (HasFastEstimationBlockSize) {
        output.WriteRawTag(53);
        output.WriteFloat(FastEstimationBlockSize);
      }
      if (HasDownsampleMode) {
        output.WriteRawTag(88);
        output.WriteEnum((int) DownsampleMode);
      }
      if (HasDownsamplingSize) {
        output.WriteRawTag(96);
        output.WriteInt32(DownsamplingSize);
      }
      if (HasMinFeatureRequirement) {
        output.WriteRawTag(104);
        output.WriteInt32(MinFeatureRequirement);
      }
      if (HasMinFeatureCover) {
        output.WriteRawTag(117);
        output.WriteFloat(MinFeatureCover);
      }
      if (HasComputeBlurScore) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ComputeBlurScore);
      }
      if (HasDownsampleFactor) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(DownsampleFactor);
      }
      if (downsampleSchedule_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(DownsampleSchedule);
      }
      if (HasMinFeatureCoverGrid) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(MinFeatureCoverGrid);
      }
      if (HasPatchDescriptorRadius) {
        output.WriteRawTag(168, 1);
        output.WriteInt32(PatchDescriptorRadius);
      }
      if (HasFastEstimationOverlapGrids) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(FastEstimationOverlapGrids);
      }
      if (HasMaxMagnitudeThresholdRatio) {
        output.WriteRawTag(189, 1);
        output.WriteFloat(MaxMagnitudeThresholdRatio);
      }
      if (HasFastEstimationMinBlockSize) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(FastEstimationMinBlockSize);
      }
      if (HasCornerResponseScale) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(CornerResponseScale);
      }
      if (HasVerifyFeatures) {
        output.WriteRawTag(216, 1);
        output.WriteBool(VerifyFeatures);
      }
      if (HasVerificationDistance) {
        output.WriteRawTag(229, 1);
        output.WriteFloat(VerificationDistance);
      }
      if (blurScoreOptions_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(BlurScoreOptions);
      }
      if (HasPreBlurSigma) {
        output.WriteRawTag(141, 2);
        output.WriteFloat(PreBlurSigma);
      }
      if (HasUseSyntheticZeroMotionTracksAllFrames) {
        output.WriteRawTag(144, 2);
        output.WriteBool(UseSyntheticZeroMotionTracksAllFrames);
      }
      if (HasUseSyntheticZeroMotionTracksFirstFrame) {
        output.WriteRawTag(152, 2);
        output.WriteBool(UseSyntheticZeroMotionTracksFirstFrame);
      }
      if (HasGainCorrection) {
        output.WriteRawTag(160, 2);
        output.WriteBool(GainCorrection);
      }
      if (HasFracGainFeatureSize) {
        output.WriteRawTag(173, 2);
        output.WriteFloat(FracGainFeatureSize);
      }
      if (HasFracGainStep) {
        output.WriteRawTag(181, 2);
        output.WriteFloat(FracGainStep);
      }
      if (gainBiasBounds_ != null) {
        output.WriteRawTag(186, 2);
        output.WriteMessage(GainBiasBounds);
      }
      if (HasNoEstimationMode) {
        output.WriteRawTag(192, 2);
        output.WriteBool(NoEstimationMode);
      }
      if (HasGainCorrectMode) {
        output.WriteRawTag(200, 2);
        output.WriteEnum((int) GainCorrectMode);
      }
      if (HasRelativeInlierErrorThreshold) {
        output.WriteRawTag(229, 2);
        output.WriteFloat(RelativeInlierErrorThreshold);
      }
      if (HasTopInlierSets) {
        output.WriteRawTag(232, 2);
        output.WriteInt32(TopInlierSets);
      }
      if (HasRelativeMinFeatureInliers) {
        output.WriteRawTag(245, 2);
        output.WriteFloat(RelativeMinFeatureInliers);
      }
      if (HasGainCorrectionMultipleHypotheses) {
        output.WriteRawTag(248, 2);
        output.WriteBool(GainCorrectionMultipleHypotheses);
      }
      if (HasGainCorrectionInlierImprovementFrac) {
        output.WriteRawTag(133, 3);
        output.WriteFloat(GainCorrectionInlierImprovementFrac);
      }
      if (HasIrlsInitialization) {
        output.WriteRawTag(136, 3);
        output.WriteEnum((int) IrlsInitialization);
      }
      if (HasDistanceFromBorder) {
        output.WriteRawTag(144, 3);
        output.WriteInt32(DistanceFromBorder);
      }
      if (HasMedianMagnitudeBounds) {
        output.WriteRawTag(157, 3);
        output.WriteFloat(MedianMagnitudeBounds);
      }
      if (HasFracInlierErrorThreshold) {
        output.WriteRawTag(165, 3);
        output.WriteFloat(FracInlierErrorThreshold);
      }
      if (HasVerifyLongFeatures) {
        output.WriteRawTag(168, 3);
        output.WriteBool(VerifyLongFeatures);
      }
      if (HasLongFeatureVerificationThreshold) {
        output.WriteRawTag(181, 3);
        output.WriteFloat(LongFeatureVerificationThreshold);
      }
      if (visualConsistencyOptions_ != null) {
        output.WriteRawTag(186, 3);
        output.WriteMessage(VisualConsistencyOptions);
      }
      if (HasMaxLongFeatureAcceleration) {
        output.WriteRawTag(197, 3);
        output.WriteFloat(MaxLongFeatureAcceleration);
      }
      if (HasHistogramEqualization) {
        output.WriteRawTag(200, 3);
        output.WriteBool(HistogramEqualization);
      }
      if (HasImageFormat) {
        output.WriteRawTag(208, 3);
        output.WriteEnum((int) ImageFormat);
      }
      if (HasGainCorrectionBrightReference) {
        output.WriteRawTag(216, 3);
        output.WriteBool(GainCorrectionBrightReference);
      }
      if (HasGainCorrectionTriggeringRatio) {
        output.WriteRawTag(229, 3);
        output.WriteFloat(GainCorrectionTriggeringRatio);
      }
      if (HasFastGainCorrection) {
        output.WriteRawTag(232, 3);
        output.WriteBool(FastGainCorrection);
      }
      if (HasRoundDownsampleFactor) {
        output.WriteRawTag(240, 3);
        output.WriteBool(RoundDownsampleFactor);
      }
      if (HasVerifyLongFeatureAcceleration) {
        output.WriteRawTag(248, 3);
        output.WriteBool(VerifyLongFeatureAcceleration);
      }
      if (HasVerifyLongFeatureTriggerRatio) {
        output.WriteRawTag(133, 4);
        output.WriteFloat(VerifyLongFeatureTriggerRatio);
      }
      if (HasDescriptorExtractorType) {
        output.WriteRawTag(136, 4);
        output.WriteEnum((int) DescriptorExtractorType);
      }
      if (HasComputeDerivativeInPyramid) {
        output.WriteRawTag(144, 4);
        output.WriteBool(ComputeDerivativeInPyramid);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (trackingOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrackingOptions);
      }
      if (HasMinFeatureInliers) {
        output.WriteRawTag(16);
        output.WriteInt32(MinFeatureInliers);
      }
      if (HasRansacRoundsPerRegion) {
        output.WriteRawTag(24);
        output.WriteInt32(RansacRoundsPerRegion);
      }
      if (HasAbsoluteInlierErrorThreshold) {
        output.WriteRawTag(37);
        output.WriteFloat(AbsoluteInlierErrorThreshold);
      }
      if (HasFastEstimationBlockSize) {
        output.WriteRawTag(53);
        output.WriteFloat(FastEstimationBlockSize);
      }
      if (HasDownsampleMode) {
        output.WriteRawTag(88);
        output.WriteEnum((int) DownsampleMode);
      }
      if (HasDownsamplingSize) {
        output.WriteRawTag(96);
        output.WriteInt32(DownsamplingSize);
      }
      if (HasMinFeatureRequirement) {
        output.WriteRawTag(104);
        output.WriteInt32(MinFeatureRequirement);
      }
      if (HasMinFeatureCover) {
        output.WriteRawTag(117);
        output.WriteFloat(MinFeatureCover);
      }
      if (HasComputeBlurScore) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ComputeBlurScore);
      }
      if (HasDownsampleFactor) {
        output.WriteRawTag(149, 1);
        output.WriteFloat(DownsampleFactor);
      }
      if (downsampleSchedule_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(DownsampleSchedule);
      }
      if (HasMinFeatureCoverGrid) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(MinFeatureCoverGrid);
      }
      if (HasPatchDescriptorRadius) {
        output.WriteRawTag(168, 1);
        output.WriteInt32(PatchDescriptorRadius);
      }
      if (HasFastEstimationOverlapGrids) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(FastEstimationOverlapGrids);
      }
      if (HasMaxMagnitudeThresholdRatio) {
        output.WriteRawTag(189, 1);
        output.WriteFloat(MaxMagnitudeThresholdRatio);
      }
      if (HasFastEstimationMinBlockSize) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(FastEstimationMinBlockSize);
      }
      if (HasCornerResponseScale) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(CornerResponseScale);
      }
      if (HasVerifyFeatures) {
        output.WriteRawTag(216, 1);
        output.WriteBool(VerifyFeatures);
      }
      if (HasVerificationDistance) {
        output.WriteRawTag(229, 1);
        output.WriteFloat(VerificationDistance);
      }
      if (blurScoreOptions_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(BlurScoreOptions);
      }
      if (HasPreBlurSigma) {
        output.WriteRawTag(141, 2);
        output.WriteFloat(PreBlurSigma);
      }
      if (HasUseSyntheticZeroMotionTracksAllFrames) {
        output.WriteRawTag(144, 2);
        output.WriteBool(UseSyntheticZeroMotionTracksAllFrames);
      }
      if (HasUseSyntheticZeroMotionTracksFirstFrame) {
        output.WriteRawTag(152, 2);
        output.WriteBool(UseSyntheticZeroMotionTracksFirstFrame);
      }
      if (HasGainCorrection) {
        output.WriteRawTag(160, 2);
        output.WriteBool(GainCorrection);
      }
      if (HasFracGainFeatureSize) {
        output.WriteRawTag(173, 2);
        output.WriteFloat(FracGainFeatureSize);
      }
      if (HasFracGainStep) {
        output.WriteRawTag(181, 2);
        output.WriteFloat(FracGainStep);
      }
      if (gainBiasBounds_ != null) {
        output.WriteRawTag(186, 2);
        output.WriteMessage(GainBiasBounds);
      }
      if (HasNoEstimationMode) {
        output.WriteRawTag(192, 2);
        output.WriteBool(NoEstimationMode);
      }
      if (HasGainCorrectMode) {
        output.WriteRawTag(200, 2);
        output.WriteEnum((int) GainCorrectMode);
      }
      if (HasRelativeInlierErrorThreshold) {
        output.WriteRawTag(229, 2);
        output.WriteFloat(RelativeInlierErrorThreshold);
      }
      if (HasTopInlierSets) {
        output.WriteRawTag(232, 2);
        output.WriteInt32(TopInlierSets);
      }
      if (HasRelativeMinFeatureInliers) {
        output.WriteRawTag(245, 2);
        output.WriteFloat(RelativeMinFeatureInliers);
      }
      if (HasGainCorrectionMultipleHypotheses) {
        output.WriteRawTag(248, 2);
        output.WriteBool(GainCorrectionMultipleHypotheses);
      }
      if (HasGainCorrectionInlierImprovementFrac) {
        output.WriteRawTag(133, 3);
        output.WriteFloat(GainCorrectionInlierImprovementFrac);
      }
      if (HasIrlsInitialization) {
        output.WriteRawTag(136, 3);
        output.WriteEnum((int) IrlsInitialization);
      }
      if (HasDistanceFromBorder) {
        output.WriteRawTag(144, 3);
        output.WriteInt32(DistanceFromBorder);
      }
      if (HasMedianMagnitudeBounds) {
        output.WriteRawTag(157, 3);
        output.WriteFloat(MedianMagnitudeBounds);
      }
      if (HasFracInlierErrorThreshold) {
        output.WriteRawTag(165, 3);
        output.WriteFloat(FracInlierErrorThreshold);
      }
      if (HasVerifyLongFeatures) {
        output.WriteRawTag(168, 3);
        output.WriteBool(VerifyLongFeatures);
      }
      if (HasLongFeatureVerificationThreshold) {
        output.WriteRawTag(181, 3);
        output.WriteFloat(LongFeatureVerificationThreshold);
      }
      if (visualConsistencyOptions_ != null) {
        output.WriteRawTag(186, 3);
        output.WriteMessage(VisualConsistencyOptions);
      }
      if (HasMaxLongFeatureAcceleration) {
        output.WriteRawTag(197, 3);
        output.WriteFloat(MaxLongFeatureAcceleration);
      }
      if (HasHistogramEqualization) {
        output.WriteRawTag(200, 3);
        output.WriteBool(HistogramEqualization);
      }
      if (HasImageFormat) {
        output.WriteRawTag(208, 3);
        output.WriteEnum((int) ImageFormat);
      }
      if (HasGainCorrectionBrightReference) {
        output.WriteRawTag(216, 3);
        output.WriteBool(GainCorrectionBrightReference);
      }
      if (HasGainCorrectionTriggeringRatio) {
        output.WriteRawTag(229, 3);
        output.WriteFloat(GainCorrectionTriggeringRatio);
      }
      if (HasFastGainCorrection) {
        output.WriteRawTag(232, 3);
        output.WriteBool(FastGainCorrection);
      }
      if (HasRoundDownsampleFactor) {
        output.WriteRawTag(240, 3);
        output.WriteBool(RoundDownsampleFactor);
      }
      if (HasVerifyLongFeatureAcceleration) {
        output.WriteRawTag(248, 3);
        output.WriteBool(VerifyLongFeatureAcceleration);
      }
      if (HasVerifyLongFeatureTriggerRatio) {
        output.WriteRawTag(133, 4);
        output.WriteFloat(VerifyLongFeatureTriggerRatio);
      }
      if (HasDescriptorExtractorType) {
        output.WriteRawTag(136, 4);
        output.WriteEnum((int) DescriptorExtractorType);
      }
      if (HasComputeDerivativeInPyramid) {
        output.WriteRawTag(144, 4);
        output.WriteBool(ComputeDerivativeInPyramid);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (trackingOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrackingOptions);
      }
      if (HasMinFeatureInliers) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinFeatureInliers);
      }
      if (HasRelativeMinFeatureInliers) {
        size += 2 + 4;
      }
      if (HasPreBlurSigma) {
        size += 2 + 4;
      }
      if (HasRansacRoundsPerRegion) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RansacRoundsPerRegion);
      }
      if (HasAbsoluteInlierErrorThreshold) {
        size += 1 + 4;
      }
      if (HasFracInlierErrorThreshold) {
        size += 2 + 4;
      }
      if (HasRelativeInlierErrorThreshold) {
        size += 2 + 4;
      }
      if (HasTopInlierSets) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(TopInlierSets);
      }
      if (HasNoEstimationMode) {
        size += 2 + 1;
      }
      if (HasFastEstimationBlockSize) {
        size += 1 + 4;
      }
      if (HasFastEstimationMinBlockSize) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(FastEstimationMinBlockSize);
      }
      if (HasFastEstimationOverlapGrids) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(FastEstimationOverlapGrids);
      }
      if (HasMaxMagnitudeThresholdRatio) {
        size += 2 + 4;
      }
      if (HasMedianMagnitudeBounds) {
        size += 2 + 4;
      }
      if (HasIrlsInitialization) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) IrlsInitialization);
      }
      if (HasDownsampleMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DownsampleMode);
      }
      if (HasDownsamplingSize) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DownsamplingSize);
      }
      if (HasDownsampleFactor) {
        size += 2 + 4;
      }
      if (HasRoundDownsampleFactor) {
        size += 2 + 1;
      }
      if (downsampleSchedule_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DownsampleSchedule);
      }
      if (HasMinFeatureRequirement) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinFeatureRequirement);
      }
      if (HasMinFeatureCover) {
        size += 1 + 4;
      }
      if (HasMinFeatureCoverGrid) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MinFeatureCoverGrid);
      }
      if (HasComputeBlurScore) {
        size += 2 + 1;
      }
      if (blurScoreOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BlurScoreOptions);
      }
      if (visualConsistencyOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(VisualConsistencyOptions);
      }
      if (HasPatchDescriptorRadius) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(PatchDescriptorRadius);
      }
      if (HasDistanceFromBorder) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(DistanceFromBorder);
      }
      if (HasCornerResponseScale) {
        size += 2 + 4;
      }
      if (HasVerifyFeatures) {
        size += 2 + 1;
      }
      if (HasVerificationDistance) {
        size += 2 + 4;
      }
      if (HasVerifyLongFeatures) {
        size += 2 + 1;
      }
      if (HasLongFeatureVerificationThreshold) {
        size += 2 + 4;
      }
      if (HasMaxLongFeatureAcceleration) {
        size += 2 + 4;
      }
      if (HasVerifyLongFeatureAcceleration) {
        size += 2 + 1;
      }
      if (HasVerifyLongFeatureTriggerRatio) {
        size += 2 + 4;
      }
      if (HasHistogramEqualization) {
        size += 2 + 1;
      }
      if (HasUseSyntheticZeroMotionTracksAllFrames) {
        size += 2 + 1;
      }
      if (HasUseSyntheticZeroMotionTracksFirstFrame) {
        size += 2 + 1;
      }
      if (HasGainCorrection) {
        size += 2 + 1;
      }
      if (HasFastGainCorrection) {
        size += 2 + 1;
      }
      if (HasGainCorrectionMultipleHypotheses) {
        size += 2 + 1;
      }
      if (HasGainCorrectionInlierImprovementFrac) {
        size += 2 + 4;
      }
      if (HasGainCorrectionBrightReference) {
        size += 2 + 1;
      }
      if (HasGainCorrectionTriggeringRatio) {
        size += 2 + 4;
      }
      if (HasFracGainFeatureSize) {
        size += 2 + 4;
      }
      if (HasFracGainStep) {
        size += 2 + 4;
      }
      if (HasGainCorrectMode) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) GainCorrectMode);
      }
      if (gainBiasBounds_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(GainBiasBounds);
      }
      if (HasImageFormat) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ImageFormat);
      }
      if (HasDescriptorExtractorType) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DescriptorExtractorType);
      }
      if (HasComputeDerivativeInPyramid) {
        size += 2 + 1;
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RegionFlowComputationOptions other) {
      if (other == null) {
        return;
      }
      if (other.trackingOptions_ != null) {
        if (trackingOptions_ == null) {
          TrackingOptions = new global::Mediapipe.TrackingOptions();
        }
        TrackingOptions.MergeFrom(other.TrackingOptions);
      }
      if (other.HasMinFeatureInliers) {
        MinFeatureInliers = other.MinFeatureInliers;
      }
      if (other.HasRelativeMinFeatureInliers) {
        RelativeMinFeatureInliers = other.RelativeMinFeatureInliers;
      }
      if (other.HasPreBlurSigma) {
        PreBlurSigma = other.PreBlurSigma;
      }
      if (other.HasRansacRoundsPerRegion) {
        RansacRoundsPerRegion = other.RansacRoundsPerRegion;
      }
      if (other.HasAbsoluteInlierErrorThreshold) {
        AbsoluteInlierErrorThreshold = other.AbsoluteInlierErrorThreshold;
      }
      if (other.HasFracInlierErrorThreshold) {
        FracInlierErrorThreshold = other.FracInlierErrorThreshold;
      }
      if (other.HasRelativeInlierErrorThreshold) {
        RelativeInlierErrorThreshold = other.RelativeInlierErrorThreshold;
      }
      if (other.HasTopInlierSets) {
        TopInlierSets = other.TopInlierSets;
      }
      if (other.HasNoEstimationMode) {
        NoEstimationMode = other.NoEstimationMode;
      }
      if (other.HasFastEstimationBlockSize) {
        FastEstimationBlockSize = other.FastEstimationBlockSize;
      }
      if (other.HasFastEstimationMinBlockSize) {
        FastEstimationMinBlockSize = other.FastEstimationMinBlockSize;
      }
      if (other.HasFastEstimationOverlapGrids) {
        FastEstimationOverlapGrids = other.FastEstimationOverlapGrids;
      }
      if (other.HasMaxMagnitudeThresholdRatio) {
        MaxMagnitudeThresholdRatio = other.MaxMagnitudeThresholdRatio;
      }
      if (other.HasMedianMagnitudeBounds) {
        MedianMagnitudeBounds = other.MedianMagnitudeBounds;
      }
      if (other.HasIrlsInitialization) {
        IrlsInitialization = other.IrlsInitialization;
      }
      if (other.HasDownsampleMode) {
        DownsampleMode = other.DownsampleMode;
      }
      if (other.HasDownsamplingSize) {
        DownsamplingSize = other.DownsamplingSize;
      }
      if (other.HasDownsampleFactor) {
        DownsampleFactor = other.DownsampleFactor;
      }
      if (other.HasRoundDownsampleFactor) {
        RoundDownsampleFactor = other.RoundDownsampleFactor;
      }
      if (other.downsampleSchedule_ != null) {
        if (downsampleSchedule_ == null) {
          DownsampleSchedule = new global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule();
        }
        DownsampleSchedule.MergeFrom(other.DownsampleSchedule);
      }
      if (other.HasMinFeatureRequirement) {
        MinFeatureRequirement = other.MinFeatureRequirement;
      }
      if (other.HasMinFeatureCover) {
        MinFeatureCover = other.MinFeatureCover;
      }
      if (other.HasMinFeatureCoverGrid) {
        MinFeatureCoverGrid = other.MinFeatureCoverGrid;
      }
      if (other.HasComputeBlurScore) {
        ComputeBlurScore = other.ComputeBlurScore;
      }
      if (other.blurScoreOptions_ != null) {
        if (blurScoreOptions_ == null) {
          BlurScoreOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions();
        }
        BlurScoreOptions.MergeFrom(other.BlurScoreOptions);
      }
      if (other.visualConsistencyOptions_ != null) {
        if (visualConsistencyOptions_ == null) {
          VisualConsistencyOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions();
        }
        VisualConsistencyOptions.MergeFrom(other.VisualConsistencyOptions);
      }
      if (other.HasPatchDescriptorRadius) {
        PatchDescriptorRadius = other.PatchDescriptorRadius;
      }
      if (other.HasDistanceFromBorder) {
        DistanceFromBorder = other.DistanceFromBorder;
      }
      if (other.HasCornerResponseScale) {
        CornerResponseScale = other.CornerResponseScale;
      }
      if (other.HasVerifyFeatures) {
        VerifyFeatures = other.VerifyFeatures;
      }
      if (other.HasVerificationDistance) {
        VerificationDistance = other.VerificationDistance;
      }
      if (other.HasVerifyLongFeatures) {
        VerifyLongFeatures = other.VerifyLongFeatures;
      }
      if (other.HasLongFeatureVerificationThreshold) {
        LongFeatureVerificationThreshold = other.LongFeatureVerificationThreshold;
      }
      if (other.HasMaxLongFeatureAcceleration) {
        MaxLongFeatureAcceleration = other.MaxLongFeatureAcceleration;
      }
      if (other.HasVerifyLongFeatureAcceleration) {
        VerifyLongFeatureAcceleration = other.VerifyLongFeatureAcceleration;
      }
      if (other.HasVerifyLongFeatureTriggerRatio) {
        VerifyLongFeatureTriggerRatio = other.VerifyLongFeatureTriggerRatio;
      }
      if (other.HasHistogramEqualization) {
        HistogramEqualization = other.HistogramEqualization;
      }
      if (other.HasUseSyntheticZeroMotionTracksAllFrames) {
        UseSyntheticZeroMotionTracksAllFrames = other.UseSyntheticZeroMotionTracksAllFrames;
      }
      if (other.HasUseSyntheticZeroMotionTracksFirstFrame) {
        UseSyntheticZeroMotionTracksFirstFrame = other.UseSyntheticZeroMotionTracksFirstFrame;
      }
      if (other.HasGainCorrection) {
        GainCorrection = other.GainCorrection;
      }
      if (other.HasFastGainCorrection) {
        FastGainCorrection = other.FastGainCorrection;
      }
      if (other.HasGainCorrectionMultipleHypotheses) {
        GainCorrectionMultipleHypotheses = other.GainCorrectionMultipleHypotheses;
      }
      if (other.HasGainCorrectionInlierImprovementFrac) {
        GainCorrectionInlierImprovementFrac = other.GainCorrectionInlierImprovementFrac;
      }
      if (other.HasGainCorrectionBrightReference) {
        GainCorrectionBrightReference = other.GainCorrectionBrightReference;
      }
      if (other.HasGainCorrectionTriggeringRatio) {
        GainCorrectionTriggeringRatio = other.GainCorrectionTriggeringRatio;
      }
      if (other.HasFracGainFeatureSize) {
        FracGainFeatureSize = other.FracGainFeatureSize;
      }
      if (other.HasFracGainStep) {
        FracGainStep = other.FracGainStep;
      }
      if (other.HasGainCorrectMode) {
        GainCorrectMode = other.GainCorrectMode;
      }
      if (other.gainBiasBounds_ != null) {
        if (gainBiasBounds_ == null) {
          GainBiasBounds = new global::Mediapipe.ToneEstimationOptions.Types.GainBiasBounds();
        }
        GainBiasBounds.MergeFrom(other.GainBiasBounds);
      }
      if (other.HasImageFormat) {
        ImageFormat = other.ImageFormat;
      }
      if (other.HasDescriptorExtractorType) {
        DescriptorExtractorType = other.DescriptorExtractorType;
      }
      if (other.HasComputeDerivativeInPyramid) {
        ComputeDerivativeInPyramid = other.ComputeDerivativeInPyramid;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (trackingOptions_ == null) {
              TrackingOptions = new global::Mediapipe.TrackingOptions();
            }
            input.ReadMessage(TrackingOptions);
            break;
          }
          case 16: {
            MinFeatureInliers = input.ReadInt32();
            break;
          }
          case 24: {
            RansacRoundsPerRegion = input.ReadInt32();
            break;
          }
          case 37: {
            AbsoluteInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 53: {
            FastEstimationBlockSize = input.ReadFloat();
            break;
          }
          case 88: {
            DownsampleMode = (global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode) input.ReadEnum();
            break;
          }
          case 96: {
            DownsamplingSize = input.ReadInt32();
            break;
          }
          case 104: {
            MinFeatureRequirement = input.ReadInt32();
            break;
          }
          case 117: {
            MinFeatureCover = input.ReadFloat();
            break;
          }
          case 136: {
            ComputeBlurScore = input.ReadBool();
            break;
          }
          case 149: {
            DownsampleFactor = input.ReadFloat();
            break;
          }
          case 154: {
            if (downsampleSchedule_ == null) {
              DownsampleSchedule = new global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule();
            }
            input.ReadMessage(DownsampleSchedule);
            break;
          }
          case 160: {
            MinFeatureCoverGrid = input.ReadInt32();
            break;
          }
          case 168: {
            PatchDescriptorRadius = input.ReadInt32();
            break;
          }
          case 176: {
            FastEstimationOverlapGrids = input.ReadInt32();
            break;
          }
          case 189: {
            MaxMagnitudeThresholdRatio = input.ReadFloat();
            break;
          }
          case 200: {
            FastEstimationMinBlockSize = input.ReadInt32();
            break;
          }
          case 213: {
            CornerResponseScale = input.ReadFloat();
            break;
          }
          case 216: {
            VerifyFeatures = input.ReadBool();
            break;
          }
          case 229: {
            VerificationDistance = input.ReadFloat();
            break;
          }
          case 250: {
            if (blurScoreOptions_ == null) {
              BlurScoreOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions();
            }
            input.ReadMessage(BlurScoreOptions);
            break;
          }
          case 269: {
            PreBlurSigma = input.ReadFloat();
            break;
          }
          case 272: {
            UseSyntheticZeroMotionTracksAllFrames = input.ReadBool();
            break;
          }
          case 280: {
            UseSyntheticZeroMotionTracksFirstFrame = input.ReadBool();
            break;
          }
          case 288: {
            GainCorrection = input.ReadBool();
            break;
          }
          case 301: {
            FracGainFeatureSize = input.ReadFloat();
            break;
          }
          case 309: {
            FracGainStep = input.ReadFloat();
            break;
          }
          case 314: {
            if (gainBiasBounds_ == null) {
              GainBiasBounds = new global::Mediapipe.ToneEstimationOptions.Types.GainBiasBounds();
            }
            input.ReadMessage(GainBiasBounds);
            break;
          }
          case 320: {
            NoEstimationMode = input.ReadBool();
            break;
          }
          case 328: {
            GainCorrectMode = (global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode) input.ReadEnum();
            break;
          }
          case 357: {
            RelativeInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 360: {
            TopInlierSets = input.ReadInt32();
            break;
          }
          case 373: {
            RelativeMinFeatureInliers = input.ReadFloat();
            break;
          }
          case 376: {
            GainCorrectionMultipleHypotheses = input.ReadBool();
            break;
          }
          case 389: {
            GainCorrectionInlierImprovementFrac = input.ReadFloat();
            break;
          }
          case 392: {
            IrlsInitialization = (global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization) input.ReadEnum();
            break;
          }
          case 400: {
            DistanceFromBorder = input.ReadInt32();
            break;
          }
          case 413: {
            MedianMagnitudeBounds = input.ReadFloat();
            break;
          }
          case 421: {
            FracInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 424: {
            VerifyLongFeatures = input.ReadBool();
            break;
          }
          case 437: {
            LongFeatureVerificationThreshold = input.ReadFloat();
            break;
          }
          case 442: {
            if (visualConsistencyOptions_ == null) {
              VisualConsistencyOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions();
            }
            input.ReadMessage(VisualConsistencyOptions);
            break;
          }
          case 453: {
            MaxLongFeatureAcceleration = input.ReadFloat();
            break;
          }
          case 456: {
            HistogramEqualization = input.ReadBool();
            break;
          }
          case 464: {
            ImageFormat = (global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat) input.ReadEnum();
            break;
          }
          case 472: {
            GainCorrectionBrightReference = input.ReadBool();
            break;
          }
          case 485: {
            GainCorrectionTriggeringRatio = input.ReadFloat();
            break;
          }
          case 488: {
            FastGainCorrection = input.ReadBool();
            break;
          }
          case 496: {
            RoundDownsampleFactor = input.ReadBool();
            break;
          }
          case 504: {
            VerifyLongFeatureAcceleration = input.ReadBool();
            break;
          }
          case 517: {
            VerifyLongFeatureTriggerRatio = input.ReadFloat();
            break;
          }
          case 520: {
            DescriptorExtractorType = (global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType) input.ReadEnum();
            break;
          }
          case 528: {
            ComputeDerivativeInPyramid = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            if (trackingOptions_ == null) {
              TrackingOptions = new global::Mediapipe.TrackingOptions();
            }
            input.ReadMessage(TrackingOptions);
            break;
          }
          case 16: {
            MinFeatureInliers = input.ReadInt32();
            break;
          }
          case 24: {
            RansacRoundsPerRegion = input.ReadInt32();
            break;
          }
          case 37: {
            AbsoluteInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 53: {
            FastEstimationBlockSize = input.ReadFloat();
            break;
          }
          case 88: {
            DownsampleMode = (global::Mediapipe.RegionFlowComputationOptions.Types.DownsampleMode) input.ReadEnum();
            break;
          }
          case 96: {
            DownsamplingSize = input.ReadInt32();
            break;
          }
          case 104: {
            MinFeatureRequirement = input.ReadInt32();
            break;
          }
          case 117: {
            MinFeatureCover = input.ReadFloat();
            break;
          }
          case 136: {
            ComputeBlurScore = input.ReadBool();
            break;
          }
          case 149: {
            DownsampleFactor = input.ReadFloat();
            break;
          }
          case 154: {
            if (downsampleSchedule_ == null) {
              DownsampleSchedule = new global::Mediapipe.RegionFlowComputationOptions.Types.DownSampleSchedule();
            }
            input.ReadMessage(DownsampleSchedule);
            break;
          }
          case 160: {
            MinFeatureCoverGrid = input.ReadInt32();
            break;
          }
          case 168: {
            PatchDescriptorRadius = input.ReadInt32();
            break;
          }
          case 176: {
            FastEstimationOverlapGrids = input.ReadInt32();
            break;
          }
          case 189: {
            MaxMagnitudeThresholdRatio = input.ReadFloat();
            break;
          }
          case 200: {
            FastEstimationMinBlockSize = input.ReadInt32();
            break;
          }
          case 213: {
            CornerResponseScale = input.ReadFloat();
            break;
          }
          case 216: {
            VerifyFeatures = input.ReadBool();
            break;
          }
          case 229: {
            VerificationDistance = input.ReadFloat();
            break;
          }
          case 250: {
            if (blurScoreOptions_ == null) {
              BlurScoreOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.BlurScoreOptions();
            }
            input.ReadMessage(BlurScoreOptions);
            break;
          }
          case 269: {
            PreBlurSigma = input.ReadFloat();
            break;
          }
          case 272: {
            UseSyntheticZeroMotionTracksAllFrames = input.ReadBool();
            break;
          }
          case 280: {
            UseSyntheticZeroMotionTracksFirstFrame = input.ReadBool();
            break;
          }
          case 288: {
            GainCorrection = input.ReadBool();
            break;
          }
          case 301: {
            FracGainFeatureSize = input.ReadFloat();
            break;
          }
          case 309: {
            FracGainStep = input.ReadFloat();
            break;
          }
          case 314: {
            if (gainBiasBounds_ == null) {
              GainBiasBounds = new global::Mediapipe.ToneEstimationOptions.Types.GainBiasBounds();
            }
            input.ReadMessage(GainBiasBounds);
            break;
          }
          case 320: {
            NoEstimationMode = input.ReadBool();
            break;
          }
          case 328: {
            GainCorrectMode = (global::Mediapipe.RegionFlowComputationOptions.Types.GainCorrectMode) input.ReadEnum();
            break;
          }
          case 357: {
            RelativeInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 360: {
            TopInlierSets = input.ReadInt32();
            break;
          }
          case 373: {
            RelativeMinFeatureInliers = input.ReadFloat();
            break;
          }
          case 376: {
            GainCorrectionMultipleHypotheses = input.ReadBool();
            break;
          }
          case 389: {
            GainCorrectionInlierImprovementFrac = input.ReadFloat();
            break;
          }
          case 392: {
            IrlsInitialization = (global::Mediapipe.RegionFlowComputationOptions.Types.IrlsInitialization) input.ReadEnum();
            break;
          }
          case 400: {
            DistanceFromBorder = input.ReadInt32();
            break;
          }
          case 413: {
            MedianMagnitudeBounds = input.ReadFloat();
            break;
          }
          case 421: {
            FracInlierErrorThreshold = input.ReadFloat();
            break;
          }
          case 424: {
            VerifyLongFeatures = input.ReadBool();
            break;
          }
          case 437: {
            LongFeatureVerificationThreshold = input.ReadFloat();
            break;
          }
          case 442: {
            if (visualConsistencyOptions_ == null) {
              VisualConsistencyOptions = new global::Mediapipe.RegionFlowComputationOptions.Types.VisualConsistencyOptions();
            }
            input.ReadMessage(VisualConsistencyOptions);
            break;
          }
          case 453: {
            MaxLongFeatureAcceleration = input.ReadFloat();
            break;
          }
          case 456: {
            HistogramEqualization = input.ReadBool();
            break;
          }
          case 464: {
            ImageFormat = (global::Mediapipe.RegionFlowComputationOptions.Types.ImageFormat) input.ReadEnum();
            break;
          }
          case 472: {
            GainCorrectionBrightReference = input.ReadBool();
            break;
          }
          case 485: {
            GainCorrectionTriggeringRatio = input.ReadFloat();
            break;
          }
          case 488: {
            FastGainCorrection = input.ReadBool();
            break;
          }
          case 496: {
            RoundDownsampleFactor = input.ReadBool();
            break;
          }
          case 504: {
            VerifyLongFeatureAcceleration = input.ReadBool();
            break;
          }
          case 517: {
            VerifyLongFeatureTriggerRatio = input.ReadFloat();
            break;
          }
          case 520: {
            DescriptorExtractorType = (global::Mediapipe.RegionFlowComputationOptions.Types.DescriptorExtractorType) input.ReadEnum();
            break;
          }
          case 528: {
            ComputeDerivativeInPyramid = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<RegionFlowComputationOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<RegionFlowComputationOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<RegionFlowComputationOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<RegionFlowComputationOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<RegionFlowComputationOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<RegionFlowComputationOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<RegionFlowComputationOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RegionFlowComputationOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Determines how irls weights for computed features are initialized.
      /// In general, more stable features are given higher weight.
      /// </summary>
      public enum IrlsInitialization {
        /// <summary>
        /// All weights equal 1
        /// </summary>
        [pbr::OriginalName("INIT_UNIFORM")] InitUniform = 1,
        /// <summary>
        /// Feature's irls weight is initialized to a value in [0, 2]
        /// indicating how consistent the feature's motion is w.r.t. neighboring
        /// features (high values = very consistent). Determined by counting how
        /// often a feature is part of the inlier set for a particular bin.
        /// </summary>
        [pbr::OriginalName("INIT_CONSISTENCY")] InitConsistency = 2,
      }

      /// <summary>
      /// We support down-sampling of an incoming frame before running the
      /// resolution dependent part of the region flow computation (feature
      /// extraction and tracking if desired).
      /// Note that in all downsampling modes except for DOWNSAMPLE_TO_INPUT_SIZE,
      /// for uneven dimensions after downsampling, we always round up to
      /// the nearest even dimension, i.e. 350p with a downsample_factor of 2.0
      /// would expect an input of size 176p.
      /// </summary>
      public enum DownsampleMode {
        /// <summary>
        /// No downsampling.
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_NONE")] DownsampleNone = 1,
        /// <summary>
        /// Downsizes the input frame such that frame_size == downsampling_size,
        /// where frame_size := max(width, height).
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_TO_MAX_SIZE")] DownsampleToMaxSize = 2,
        /// <summary>
        /// Downsizes frame by pre-defined factor, downsample_factor below.
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_BY_FACTOR")] DownsampleByFactor = 3,
        /// <summary>
        /// Downsampling based on downsampling schedule, see DownsampleSchedule below
        /// for details.
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_BY_SCHEDULE")] DownsampleBySchedule = 4,
        /// <summary>
        /// Downsizes the input frame such that frame_size == downsampling_size,
        /// where frame_size := min(width, height).
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_TO_MIN_SIZE")] DownsampleToMinSize = 5,
        /// <summary>
        /// Input frame is assumed to be already downsampled by the factor specified
        /// by downsample_factor below. For example if the original frame is 720p,
        /// and downsample_factor is set to 2.0, then we expect as input 360p.
        /// </summary>
        [pbr::OriginalName("DOWNSAMPLE_TO_INPUT_SIZE")] DownsampleToInputSize = 6,
      }

      public enum GainCorrectMode {
        /// <summary>
        /// Uses default or user supplied bounds,
        /// </summary>
        [pbr::OriginalName("GAIN_CORRECT_DEFAULT_USER")] GainCorrectDefaultUser = 1,
        /// <summary>
        /// i.e. gain_bias_bounds is left untouched.
        /// </summary>
        [pbr::OriginalName("GAIN_CORRECT_VIDEO")] GainCorrectVideo = 2,
        /// <summary>
        /// Uses most relaxed settings to track
        /// </summary>
        [pbr::OriginalName("GAIN_CORRECT_HDR")] GainCorrectHdr = 3,
        /// <summary>
        /// across HDR frames, taken at different
        /// exposures.
        /// </summary>
        [pbr::OriginalName("GAIN_CORRECT_PHOTO_BURST")] GainCorrectPhotoBurst = 4,
      }

      /// <summary>
      /// Supported image formats. All images are converted to grayscale
      /// before processing. These image formats only concern AddImage.
      /// IMPORTANT: All the Retrieve* methods expect RGB when the descriptors
      /// are computed.
      /// </summary>
      public enum ImageFormat {
        [pbr::OriginalName("FORMAT_GRAYSCALE")] FormatGrayscale = 1,
        [pbr::OriginalName("FORMAT_RGB")] FormatRgb = 2,
        [pbr::OriginalName("FORMAT_RGBA")] FormatRgba = 3,
        [pbr::OriginalName("FORMAT_BGR")] FormatBgr = 4,
        [pbr::OriginalName("FORMAT_BGRA")] FormatBgra = 5,
      }

      public enum DescriptorExtractorType {
        /// <summary>
        /// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.370.4395&amp;rep=rep1&amp;type=pdf
        /// </summary>
        [pbr::OriginalName("ORB")] Orb = 0,
      }

      /// <summary>
      /// Downsampling schedule. Frame sizes up to which a particular downsampling
      /// factor is applied. Factor chosen by comparing actual frame area against
      /// standard area (standard_width * standard_height), where standard_width =
      /// 16/9 X standard_height.
      /// </summary>
      public sealed partial class DownSampleSchedule : pb::IMessage<DownSampleSchedule>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DownSampleSchedule> _parser = new pb::MessageParser<DownSampleSchedule>(() => new DownSampleSchedule());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DownSampleSchedule> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.RegionFlowComputationOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DownSampleSchedule() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DownSampleSchedule(DownSampleSchedule other) : this() {
          _hasBits0 = other._hasBits0;
          downsampleFactor360P_ = other.downsampleFactor360P_;
          downsampleFactor480P_ = other.downsampleFactor480P_;
          downsampleFactor720P_ = other.downsampleFactor720P_;
          downsampleFactor1080P_ = other.downsampleFactor1080P_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DownSampleSchedule Clone() {
          return new DownSampleSchedule(this);
        }

        /// <summary>Field number for the "downsample_factor_360p" field.</summary>
        public const int DownsampleFactor360PFieldNumber = 1;
        private readonly static float DownsampleFactor360PDefaultValue = 1F;

        private float downsampleFactor360P_;
        /// <summary>
        /// For &lt;= 360p.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float DownsampleFactor360P {
          get { if ((_hasBits0 & 1) != 0) { return downsampleFactor360P_; } else { return DownsampleFactor360PDefaultValue; } }
          set {
            _hasBits0 |= 1;
            downsampleFactor360P_ = value;
          }
        }
        /// <summary>Gets whether the "downsample_factor_360p" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDownsampleFactor360P {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "downsample_factor_360p" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDownsampleFactor360P() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "downsample_factor_480p" field.</summary>
        public const int DownsampleFactor480PFieldNumber = 2;
        private readonly static float DownsampleFactor480PDefaultValue = 1F;

        private float downsampleFactor480P_;
        /// <summary>
        /// For &lt;= 480p.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float DownsampleFactor480P {
          get { if ((_hasBits0 & 2) != 0) { return downsampleFactor480P_; } else { return DownsampleFactor480PDefaultValue; } }
          set {
            _hasBits0 |= 2;
            downsampleFactor480P_ = value;
          }
        }
        /// <summary>Gets whether the "downsample_factor_480p" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDownsampleFactor480P {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "downsample_factor_480p" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDownsampleFactor480P() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "downsample_factor_720p" field.</summary>
        public const int DownsampleFactor720PFieldNumber = 3;
        private readonly static float DownsampleFactor720PDefaultValue = 2F;

        private float downsampleFactor720P_;
        /// <summary>
        /// For &lt;= 720p.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float DownsampleFactor720P {
          get { if ((_hasBits0 & 4) != 0) { return downsampleFactor720P_; } else { return DownsampleFactor720PDefaultValue; } }
          set {
            _hasBits0 |= 4;
            downsampleFactor720P_ = value;
          }
        }
        /// <summary>Gets whether the "downsample_factor_720p" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDownsampleFactor720P {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "downsample_factor_720p" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDownsampleFactor720P() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "downsample_factor_1080p" field.</summary>
        public const int DownsampleFactor1080PFieldNumber = 4;
        private readonly static float DownsampleFactor1080PDefaultValue = 2F;

        private float downsampleFactor1080P_;
        /// <summary>
        /// >= 720p.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float DownsampleFactor1080P {
          get { if ((_hasBits0 & 8) != 0) { return downsampleFactor1080P_; } else { return DownsampleFactor1080PDefaultValue; } }
          set {
            _hasBits0 |= 8;
            downsampleFactor1080P_ = value;
          }
        }
        /// <summary>Gets whether the "downsample_factor_1080p" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDownsampleFactor1080P {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "downsample_factor_1080p" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDownsampleFactor1080P() {
          _hasBits0 &= ~8;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DownSampleSchedule);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DownSampleSchedule other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DownsampleFactor360P, other.DownsampleFactor360P)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DownsampleFactor480P, other.DownsampleFactor480P)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DownsampleFactor720P, other.DownsampleFactor720P)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DownsampleFactor1080P, other.DownsampleFactor1080P)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasDownsampleFactor360P) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DownsampleFactor360P);
          if (HasDownsampleFactor480P) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DownsampleFactor480P);
          if (HasDownsampleFactor720P) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DownsampleFactor720P);
          if (HasDownsampleFactor1080P) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DownsampleFactor1080P);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasDownsampleFactor360P) {
            output.WriteRawTag(13);
            output.WriteFloat(DownsampleFactor360P);
          }
          if (HasDownsampleFactor480P) {
            output.WriteRawTag(21);
            output.WriteFloat(DownsampleFactor480P);
          }
          if (HasDownsampleFactor720P) {
            output.WriteRawTag(29);
            output.WriteFloat(DownsampleFactor720P);
          }
          if (HasDownsampleFactor1080P) {
            output.WriteRawTag(37);
            output.WriteFloat(DownsampleFactor1080P);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasDownsampleFactor360P) {
            output.WriteRawTag(13);
            output.WriteFloat(DownsampleFactor360P);
          }
          if (HasDownsampleFactor480P) {
            output.WriteRawTag(21);
            output.WriteFloat(DownsampleFactor480P);
          }
          if (HasDownsampleFactor720P) {
            output.WriteRawTag(29);
            output.WriteFloat(DownsampleFactor720P);
          }
          if (HasDownsampleFactor1080P) {
            output.WriteRawTag(37);
            output.WriteFloat(DownsampleFactor1080P);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasDownsampleFactor360P) {
            size += 1 + 4;
          }
          if (HasDownsampleFactor480P) {
            size += 1 + 4;
          }
          if (HasDownsampleFactor720P) {
            size += 1 + 4;
          }
          if (HasDownsampleFactor1080P) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DownSampleSchedule other) {
          if (other == null) {
            return;
          }
          if (other.HasDownsampleFactor360P) {
            DownsampleFactor360P = other.DownsampleFactor360P;
          }
          if (other.HasDownsampleFactor480P) {
            DownsampleFactor480P = other.DownsampleFactor480P;
          }
          if (other.HasDownsampleFactor720P) {
            DownsampleFactor720P = other.DownsampleFactor720P;
          }
          if (other.HasDownsampleFactor1080P) {
            DownsampleFactor1080P = other.DownsampleFactor1080P;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                DownsampleFactor360P = input.ReadFloat();
                break;
              }
              case 21: {
                DownsampleFactor480P = input.ReadFloat();
                break;
              }
              case 29: {
                DownsampleFactor720P = input.ReadFloat();
                break;
              }
              case 37: {
                DownsampleFactor1080P = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                DownsampleFactor360P = input.ReadFloat();
                break;
              }
              case 21: {
                DownsampleFactor480P = input.ReadFloat();
                break;
              }
              case 29: {
                DownsampleFactor720P = input.ReadFloat();
                break;
              }
              case 37: {
                DownsampleFactor1080P = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class BlurScoreOptions : pb::IMessage<BlurScoreOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BlurScoreOptions> _parser = new pb::MessageParser<BlurScoreOptions>(() => new BlurScoreOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<BlurScoreOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.RegionFlowComputationOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BlurScoreOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BlurScoreOptions(BlurScoreOptions other) : this() {
          _hasBits0 = other._hasBits0;
          boxFilterDiam_ = other.boxFilterDiam_;
          relativeCornernessThreshold_ = other.relativeCornernessThreshold_;
          absoluteCornernessThreshold_ = other.absoluteCornernessThreshold_;
          medianPercentile_ = other.medianPercentile_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BlurScoreOptions Clone() {
          return new BlurScoreOptions(this);
        }

        /// <summary>Field number for the "box_filter_diam" field.</summary>
        public const int BoxFilterDiamFieldNumber = 1;
        private readonly static int BoxFilterDiamDefaultValue = 3;

        private int boxFilterDiam_;
        /// <summary>
        /// Blur score is only computed over image regions of high cornerness
        /// (as blur in any direction will always alter these regions). First, the
        /// corner image (smallest eigenvalue of 2nd moment matrix) is box filtered,
        /// and then thresholded.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int BoxFilterDiam {
          get { if ((_hasBits0 & 1) != 0) { return boxFilterDiam_; } else { return BoxFilterDiamDefaultValue; } }
          set {
            _hasBits0 |= 1;
            boxFilterDiam_ = value;
          }
        }
        /// <summary>Gets whether the "box_filter_diam" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBoxFilterDiam {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "box_filter_diam" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBoxFilterDiam() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "relative_cornerness_threshold" field.</summary>
        public const int RelativeCornernessThresholdFieldNumber = 2;
        private readonly static float RelativeCornernessThresholdDefaultValue = 0.03F;

        private float relativeCornernessThreshold_;
        /// <summary>
        /// Specifies relative (w.r.t. maximum) and absolute corneress threshold
        /// for threshold operation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float RelativeCornernessThreshold {
          get { if ((_hasBits0 & 2) != 0) { return relativeCornernessThreshold_; } else { return RelativeCornernessThresholdDefaultValue; } }
          set {
            _hasBits0 |= 2;
            relativeCornernessThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "relative_cornerness_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRelativeCornernessThreshold {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "relative_cornerness_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRelativeCornernessThreshold() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "absolute_cornerness_threshold" field.</summary>
        public const int AbsoluteCornernessThresholdFieldNumber = 3;
        private readonly static float AbsoluteCornernessThresholdDefaultValue = 0.0001F;

        private float absoluteCornernessThreshold_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float AbsoluteCornernessThreshold {
          get { if ((_hasBits0 & 4) != 0) { return absoluteCornernessThreshold_; } else { return AbsoluteCornernessThresholdDefaultValue; } }
          set {
            _hasBits0 |= 4;
            absoluteCornernessThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "absolute_cornerness_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAbsoluteCornernessThreshold {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "absolute_cornerness_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAbsoluteCornernessThreshold() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "median_percentile" field.</summary>
        public const int MedianPercentileFieldNumber = 5;
        private readonly static float MedianPercentileDefaultValue = 0.85F;

        private float medianPercentile_;
        /// <summary>
        /// Blur score is defined as 1.0 / &lt;median cornerness>, where
        /// &lt;median cornerness> is the n-th percentile of the cornerness evaluated
        /// over the image regions of high corness as specified above.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MedianPercentile {
          get { if ((_hasBits0 & 8) != 0) { return medianPercentile_; } else { return MedianPercentileDefaultValue; } }
          set {
            _hasBits0 |= 8;
            medianPercentile_ = value;
          }
        }
        /// <summary>Gets whether the "median_percentile" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMedianPercentile {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "median_percentile" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMedianPercentile() {
          _hasBits0 &= ~8;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as BlurScoreOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(BlurScoreOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BoxFilterDiam != other.BoxFilterDiam) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RelativeCornernessThreshold, other.RelativeCornernessThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AbsoluteCornernessThreshold, other.AbsoluteCornernessThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MedianPercentile, other.MedianPercentile)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasBoxFilterDiam) hash ^= BoxFilterDiam.GetHashCode();
          if (HasRelativeCornernessThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RelativeCornernessThreshold);
          if (HasAbsoluteCornernessThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AbsoluteCornernessThreshold);
          if (HasMedianPercentile) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MedianPercentile);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasBoxFilterDiam) {
            output.WriteRawTag(8);
            output.WriteInt32(BoxFilterDiam);
          }
          if (HasRelativeCornernessThreshold) {
            output.WriteRawTag(21);
            output.WriteFloat(RelativeCornernessThreshold);
          }
          if (HasAbsoluteCornernessThreshold) {
            output.WriteRawTag(29);
            output.WriteFloat(AbsoluteCornernessThreshold);
          }
          if (HasMedianPercentile) {
            output.WriteRawTag(45);
            output.WriteFloat(MedianPercentile);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasBoxFilterDiam) {
            output.WriteRawTag(8);
            output.WriteInt32(BoxFilterDiam);
          }
          if (HasRelativeCornernessThreshold) {
            output.WriteRawTag(21);
            output.WriteFloat(RelativeCornernessThreshold);
          }
          if (HasAbsoluteCornernessThreshold) {
            output.WriteRawTag(29);
            output.WriteFloat(AbsoluteCornernessThreshold);
          }
          if (HasMedianPercentile) {
            output.WriteRawTag(45);
            output.WriteFloat(MedianPercentile);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasBoxFilterDiam) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxFilterDiam);
          }
          if (HasRelativeCornernessThreshold) {
            size += 1 + 4;
          }
          if (HasAbsoluteCornernessThreshold) {
            size += 1 + 4;
          }
          if (HasMedianPercentile) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(BlurScoreOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasBoxFilterDiam) {
            BoxFilterDiam = other.BoxFilterDiam;
          }
          if (other.HasRelativeCornernessThreshold) {
            RelativeCornernessThreshold = other.RelativeCornernessThreshold;
          }
          if (other.HasAbsoluteCornernessThreshold) {
            AbsoluteCornernessThreshold = other.AbsoluteCornernessThreshold;
          }
          if (other.HasMedianPercentile) {
            MedianPercentile = other.MedianPercentile;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                BoxFilterDiam = input.ReadInt32();
                break;
              }
              case 21: {
                RelativeCornernessThreshold = input.ReadFloat();
                break;
              }
              case 29: {
                AbsoluteCornernessThreshold = input.ReadFloat();
                break;
              }
              case 45: {
                MedianPercentile = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                BoxFilterDiam = input.ReadInt32();
                break;
              }
              case 21: {
                RelativeCornernessThreshold = input.ReadFloat();
                break;
              }
              case 29: {
                AbsoluteCornernessThreshold = input.ReadFloat();
                break;
              }
              case 45: {
                MedianPercentile = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Determines how/if visual consistency is computed. If activated,
      /// computes the absolute *change* in visual difference between two adjancent
      /// frame pairs, i.e. the modulus of the 2nd derivative of the frame
      /// appearance. Stores result in RegionFlowFeatureList::visual_consistency.
      /// </summary>
      public sealed partial class VisualConsistencyOptions : pb::IMessage<VisualConsistencyOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VisualConsistencyOptions> _parser = new pb::MessageParser<VisualConsistencyOptions>(() => new VisualConsistencyOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VisualConsistencyOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.RegionFlowComputationOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualConsistencyOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualConsistencyOptions(VisualConsistencyOptions other) : this() {
          _hasBits0 = other._hasBits0;
          computeConsistency_ = other.computeConsistency_;
          tinyImageDimension_ = other.tinyImageDimension_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualConsistencyOptions Clone() {
          return new VisualConsistencyOptions(this);
        }

        /// <summary>Field number for the "compute_consistency" field.</summary>
        public const int ComputeConsistencyFieldNumber = 1;
        private readonly static bool ComputeConsistencyDefaultValue = true;

        private bool computeConsistency_;
        /// <summary>
        /// Computation of visual consistency is only performed if activated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ComputeConsistency {
          get { if ((_hasBits0 & 1) != 0) { return computeConsistency_; } else { return ComputeConsistencyDefaultValue; } }
          set {
            _hasBits0 |= 1;
            computeConsistency_ = value;
          }
        }
        /// <summary>Gets whether the "compute_consistency" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasComputeConsistency {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "compute_consistency" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearComputeConsistency() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "tiny_image_dimension" field.</summary>
        public const int TinyImageDimensionFieldNumber = 2;
        private readonly static int TinyImageDimensionDefaultValue = 20;

        private int tinyImageDimension_;
        /// <summary>
        /// Incoming color or gray scale image is scaled to a tiny square image of
        /// the specified dimension. Used to compare adjacent images via SSD.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int TinyImageDimension {
          get { if ((_hasBits0 & 2) != 0) { return tinyImageDimension_; } else { return TinyImageDimensionDefaultValue; } }
          set {
            _hasBits0 |= 2;
            tinyImageDimension_ = value;
          }
        }
        /// <summary>Gets whether the "tiny_image_dimension" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTinyImageDimension {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "tiny_image_dimension" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTinyImageDimension() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VisualConsistencyOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VisualConsistencyOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ComputeConsistency != other.ComputeConsistency) return false;
          if (TinyImageDimension != other.TinyImageDimension) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasComputeConsistency) hash ^= ComputeConsistency.GetHashCode();
          if (HasTinyImageDimension) hash ^= TinyImageDimension.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasComputeConsistency) {
            output.WriteRawTag(8);
            output.WriteBool(ComputeConsistency);
          }
          if (HasTinyImageDimension) {
            output.WriteRawTag(16);
            output.WriteInt32(TinyImageDimension);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasComputeConsistency) {
            output.WriteRawTag(8);
            output.WriteBool(ComputeConsistency);
          }
          if (HasTinyImageDimension) {
            output.WriteRawTag(16);
            output.WriteInt32(TinyImageDimension);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasComputeConsistency) {
            size += 1 + 1;
          }
          if (HasTinyImageDimension) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(TinyImageDimension);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VisualConsistencyOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasComputeConsistency) {
            ComputeConsistency = other.ComputeConsistency;
          }
          if (other.HasTinyImageDimension) {
            TinyImageDimension = other.TinyImageDimension;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ComputeConsistency = input.ReadBool();
                break;
              }
              case 16: {
                TinyImageDimension = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ComputeConsistency = input.ReadBool();
                break;
              }
              case 16: {
                TinyImageDimension = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

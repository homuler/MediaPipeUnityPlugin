// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/util/tracking/motion_saliency.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/util/tracking/motion_saliency.proto</summary>
  public static partial class MotionSaliencyReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/util/tracking/motion_saliency.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MotionSaliencyReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci1tZWRpYXBpcGUvdXRpbC90cmFja2luZy9tb3Rpb25fc2FsaWVuY3kucHJv",
            "dG8SCW1lZGlhcGlwZSKlBAoVTW90aW9uU2FsaWVuY3lPcHRpb25zEhcKCmJv",
            "dW5kX2xlZnQYASABKAI6AzAuMxIZCgxib3VuZF9ib3R0b20YAiABKAI6AzAu",
            "MxIYCgtib3VuZF9yaWdodBgPIAEoAjoDMC4zEhYKCWJvdW5kX3RvcBgQIAEo",
            "AjoDMC4zEhsKD3NhbGllbmN5X3dlaWdodBgDIAEoAjoCMjASLQoec2NhbGVf",
            "d2VpZ2h0X2J5X2Zsb3dfbWFnbml0dWRlGAggASgIOgVmYWxzZRIXCgxtaW5f",
            "ZmVhdHVyZXMYBCABKAU6ATUSKgobdXNlX29ubHlfZm9yZWdyb3VuZF9yZWdp",
            "b25zGAkgASgIOgVmYWxzZRIgChRtaW5faXJsc19tb2RlX3dlaWdodBgKIAEo",
            "AjoCMTASHQoSbnVtX3RvcF9pcmxzX21vZGVzGAsgASgFOgEzEhwKD21vZGVf",
            "YmFuZF93aWR0aBgMIAEoAjoDMC4xEiEKFnNlbGVjdGlvbl9mcmFtZV9yYWRp",
            "dXMYBSABKAU6ATUSJwoac2VsZWN0aW9uX3N1cHBvcnRfZGlzdGFuY2UYBiAB",
            "KAI6AzAuMhIkChlzZWxlY3Rpb25fbWluaW11bV9zdXBwb3J0GAcgASgFOgE0",
            "EiMKFWZpbHRlcmluZ19zaWdtYV9zcGFjZRgNIAEoAjoEMC4wNRIfChRmaWx0",
            "ZXJpbmdfc2lnbWFfdGltZRgOIAEoAjoBNQ=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionSaliencyOptions), global::Mediapipe.MotionSaliencyOptions.Parser, new[]{ "BoundLeft", "BoundBottom", "BoundRight", "BoundTop", "SaliencyWeight", "ScaleWeightByFlowMagnitude", "MinFeatures", "UseOnlyForegroundRegions", "MinIrlsModeWeight", "NumTopIrlsModes", "ModeBandWidth", "SelectionFrameRadius", "SelectionSupportDistance", "SelectionMinimumSupport", "FilteringSigmaSpace", "FilteringSigmaTime" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Next tag: 17
  /// </summary>
  public sealed partial class MotionSaliencyOptions : pb::IMessage<MotionSaliencyOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MotionSaliencyOptions> _parser = new pb::MessageParser<MotionSaliencyOptions>(() => new MotionSaliencyOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MotionSaliencyOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.MotionSaliencyReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionSaliencyOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionSaliencyOptions(MotionSaliencyOptions other) : this() {
      _hasBits0 = other._hasBits0;
      boundLeft_ = other.boundLeft_;
      boundBottom_ = other.boundBottom_;
      boundRight_ = other.boundRight_;
      boundTop_ = other.boundTop_;
      saliencyWeight_ = other.saliencyWeight_;
      scaleWeightByFlowMagnitude_ = other.scaleWeightByFlowMagnitude_;
      minFeatures_ = other.minFeatures_;
      useOnlyForegroundRegions_ = other.useOnlyForegroundRegions_;
      minIrlsModeWeight_ = other.minIrlsModeWeight_;
      numTopIrlsModes_ = other.numTopIrlsModes_;
      modeBandWidth_ = other.modeBandWidth_;
      selectionFrameRadius_ = other.selectionFrameRadius_;
      selectionSupportDistance_ = other.selectionSupportDistance_;
      selectionMinimumSupport_ = other.selectionMinimumSupport_;
      filteringSigmaSpace_ = other.filteringSigmaSpace_;
      filteringSigmaTime_ = other.filteringSigmaTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionSaliencyOptions Clone() {
      return new MotionSaliencyOptions(this);
    }

    /// <summary>Field number for the "bound_left" field.</summary>
    public const int BoundLeftFieldNumber = 1;
    private readonly static float BoundLeftDefaultValue = 0.3F;

    private float boundLeft_;
    /// <summary>
    /// Standard normalized bounds and weights used to initialize salient points.
    /// See region_flow.proto for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BoundLeft {
      get { if ((_hasBits0 & 1) != 0) { return boundLeft_; } else { return BoundLeftDefaultValue; } }
      set {
        _hasBits0 |= 1;
        boundLeft_ = value;
      }
    }
    /// <summary>Gets whether the "bound_left" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoundLeft {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "bound_left" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoundLeft() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "bound_bottom" field.</summary>
    public const int BoundBottomFieldNumber = 2;
    private readonly static float BoundBottomDefaultValue = 0.3F;

    private float boundBottom_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BoundBottom {
      get { if ((_hasBits0 & 2) != 0) { return boundBottom_; } else { return BoundBottomDefaultValue; } }
      set {
        _hasBits0 |= 2;
        boundBottom_ = value;
      }
    }
    /// <summary>Gets whether the "bound_bottom" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoundBottom {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "bound_bottom" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoundBottom() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "bound_right" field.</summary>
    public const int BoundRightFieldNumber = 15;
    private readonly static float BoundRightDefaultValue = 0.3F;

    private float boundRight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BoundRight {
      get { if ((_hasBits0 & 16384) != 0) { return boundRight_; } else { return BoundRightDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        boundRight_ = value;
      }
    }
    /// <summary>Gets whether the "bound_right" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoundRight {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "bound_right" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoundRight() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "bound_top" field.</summary>
    public const int BoundTopFieldNumber = 16;
    private readonly static float BoundTopDefaultValue = 0.3F;

    private float boundTop_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BoundTop {
      get { if ((_hasBits0 & 32768) != 0) { return boundTop_; } else { return BoundTopDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        boundTop_ = value;
      }
    }
    /// <summary>Gets whether the "bound_top" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoundTop {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "bound_top" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoundTop() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "saliency_weight" field.</summary>
    public const int SaliencyWeightFieldNumber = 3;
    private readonly static float SaliencyWeightDefaultValue = 20F;

    private float saliencyWeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SaliencyWeight {
      get { if ((_hasBits0 & 4) != 0) { return saliencyWeight_; } else { return SaliencyWeightDefaultValue; } }
      set {
        _hasBits0 |= 4;
        saliencyWeight_ = value;
      }
    }
    /// <summary>Gets whether the "saliency_weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSaliencyWeight {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "saliency_weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSaliencyWeight() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "scale_weight_by_flow_magnitude" field.</summary>
    public const int ScaleWeightByFlowMagnitudeFieldNumber = 8;
    private readonly static bool ScaleWeightByFlowMagnitudeDefaultValue = false;

    private bool scaleWeightByFlowMagnitude_;
    /// <summary>
    /// If set, scales saliency_weight by flow magnitude.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ScaleWeightByFlowMagnitude {
      get { if ((_hasBits0 & 128) != 0) { return scaleWeightByFlowMagnitude_; } else { return ScaleWeightByFlowMagnitudeDefaultValue; } }
      set {
        _hasBits0 |= 128;
        scaleWeightByFlowMagnitude_ = value;
      }
    }
    /// <summary>Gets whether the "scale_weight_by_flow_magnitude" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScaleWeightByFlowMagnitude {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "scale_weight_by_flow_magnitude" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScaleWeightByFlowMagnitude() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "min_features" field.</summary>
    public const int MinFeaturesFieldNumber = 4;
    private readonly static int MinFeaturesDefaultValue = 5;

    private int minFeatures_;
    /// <summary>
    /// Minimum number of features within a region to be considered salient.
    /// Only applicable for functions accepting RegionFlowFrames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinFeatures {
      get { if ((_hasBits0 & 8) != 0) { return minFeatures_; } else { return MinFeaturesDefaultValue; } }
      set {
        _hasBits0 |= 8;
        minFeatures_ = value;
      }
    }
    /// <summary>Gets whether the "min_features" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinFeatures {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "min_features" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinFeatures() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "use_only_foreground_regions" field.</summary>
    public const int UseOnlyForegroundRegionsFieldNumber = 9;
    private readonly static bool UseOnlyForegroundRegionsDefaultValue = false;

    private bool useOnlyForegroundRegions_;
    /// <summary>
    /// If set, only considers regions flagged as forground.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseOnlyForegroundRegions {
      get { if ((_hasBits0 & 256) != 0) { return useOnlyForegroundRegions_; } else { return UseOnlyForegroundRegionsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        useOnlyForegroundRegions_ = value;
      }
    }
    /// <summary>Gets whether the "use_only_foreground_regions" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseOnlyForegroundRegions {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "use_only_foreground_regions" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseOnlyForegroundRegions() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "min_irls_mode_weight" field.</summary>
    public const int MinIrlsModeWeightFieldNumber = 10;
    private readonly static float MinIrlsModeWeightDefaultValue = 10F;

    private float minIrlsModeWeight_;
    /// <summary>
    /// Specifies roughly number of foreground features mapped to one mode,
    /// for mode to be considered salient.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinIrlsModeWeight {
      get { if ((_hasBits0 & 512) != 0) { return minIrlsModeWeight_; } else { return MinIrlsModeWeightDefaultValue; } }
      set {
        _hasBits0 |= 512;
        minIrlsModeWeight_ = value;
      }
    }
    /// <summary>Gets whether the "min_irls_mode_weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinIrlsModeWeight {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "min_irls_mode_weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinIrlsModeWeight() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "num_top_irls_modes" field.</summary>
    public const int NumTopIrlsModesFieldNumber = 11;
    private readonly static int NumTopIrlsModesDefaultValue = 3;

    private int numTopIrlsModes_;
    /// <summary>
    /// Only returns the top N irls modes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumTopIrlsModes {
      get { if ((_hasBits0 & 1024) != 0) { return numTopIrlsModes_; } else { return NumTopIrlsModesDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        numTopIrlsModes_ = value;
      }
    }
    /// <summary>Gets whether the "num_top_irls_modes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumTopIrlsModes {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "num_top_irls_modes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumTopIrlsModes() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "mode_band_width" field.</summary>
    public const int ModeBandWidthFieldNumber = 12;
    private readonly static float ModeBandWidthDefaultValue = 0.1F;

    private float modeBandWidth_;
    /// <summary>
    /// Mode finding is performed with a fraction radius of 10% of frame
    /// diameter by default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ModeBandWidth {
      get { if ((_hasBits0 & 2048) != 0) { return modeBandWidth_; } else { return ModeBandWidthDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        modeBandWidth_ = value;
      }
    }
    /// <summary>Gets whether the "mode_band_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasModeBandWidth {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "mode_band_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearModeBandWidth() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "selection_frame_radius" field.</summary>
    public const int SelectionFrameRadiusFieldNumber = 5;
    private readonly static int SelectionFrameRadiusDefaultValue = 5;

    private int selectionFrameRadius_;
    /// <summary>
    /// We filter salient points along the temporal dimension only, keeping those
    /// that have sufficient support (in form of neighboring salient points). For
    /// every salient point in frame n, all points in frames
    /// [n - filtering_frame_radius, n + filtering_frame_radius] are tested,
    /// whether they support the current test point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SelectionFrameRadius {
      get { if ((_hasBits0 & 16) != 0) { return selectionFrameRadius_; } else { return SelectionFrameRadiusDefaultValue; } }
      set {
        _hasBits0 |= 16;
        selectionFrameRadius_ = value;
      }
    }
    /// <summary>Gets whether the "selection_frame_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSelectionFrameRadius {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "selection_frame_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelectionFrameRadius() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "selection_support_distance" field.</summary>
    public const int SelectionSupportDistanceFieldNumber = 6;
    private readonly static float SelectionSupportDistanceDefaultValue = 0.2F;

    private float selectionSupportDistance_;
    /// <summary>
    /// Fractional distance to be considered a supporting salient point for a test
    /// point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SelectionSupportDistance {
      get { if ((_hasBits0 & 32) != 0) { return selectionSupportDistance_; } else { return SelectionSupportDistanceDefaultValue; } }
      set {
        _hasBits0 |= 32;
        selectionSupportDistance_ = value;
      }
    }
    /// <summary>Gets whether the "selection_support_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSelectionSupportDistance {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "selection_support_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelectionSupportDistance() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "selection_minimum_support" field.</summary>
    public const int SelectionMinimumSupportFieldNumber = 7;
    private readonly static int SelectionMinimumSupportDefaultValue = 4;

    private int selectionMinimumSupport_;
    /// <summary>
    /// Minimum number of supporting salient points that need to be present in
    /// order for a point to be considered an inlier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SelectionMinimumSupport {
      get { if ((_hasBits0 & 64) != 0) { return selectionMinimumSupport_; } else { return SelectionMinimumSupportDefaultValue; } }
      set {
        _hasBits0 |= 64;
        selectionMinimumSupport_ = value;
      }
    }
    /// <summary>Gets whether the "selection_minimum_support" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSelectionMinimumSupport {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "selection_minimum_support" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelectionMinimumSupport() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "filtering_sigma_space" field.</summary>
    public const int FilteringSigmaSpaceFieldNumber = 13;
    private readonly static float FilteringSigmaSpaceDefaultValue = 0.05F;

    private float filteringSigmaSpace_;
    /// <summary>
    /// Sigma in space (normalized domain).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FilteringSigmaSpace {
      get { if ((_hasBits0 & 4096) != 0) { return filteringSigmaSpace_; } else { return FilteringSigmaSpaceDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        filteringSigmaSpace_ = value;
      }
    }
    /// <summary>Gets whether the "filtering_sigma_space" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilteringSigmaSpace {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "filtering_sigma_space" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilteringSigmaSpace() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "filtering_sigma_time" field.</summary>
    public const int FilteringSigmaTimeFieldNumber = 14;
    private readonly static float FilteringSigmaTimeDefaultValue = 5F;

    private float filteringSigmaTime_;
    /// <summary>
    /// Sigma in time (in frames).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FilteringSigmaTime {
      get { if ((_hasBits0 & 8192) != 0) { return filteringSigmaTime_; } else { return FilteringSigmaTimeDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        filteringSigmaTime_ = value;
      }
    }
    /// <summary>Gets whether the "filtering_sigma_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilteringSigmaTime {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "filtering_sigma_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilteringSigmaTime() {
      _hasBits0 &= ~8192;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MotionSaliencyOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MotionSaliencyOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BoundLeft, other.BoundLeft)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BoundBottom, other.BoundBottom)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BoundRight, other.BoundRight)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BoundTop, other.BoundTop)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SaliencyWeight, other.SaliencyWeight)) return false;
      if (ScaleWeightByFlowMagnitude != other.ScaleWeightByFlowMagnitude) return false;
      if (MinFeatures != other.MinFeatures) return false;
      if (UseOnlyForegroundRegions != other.UseOnlyForegroundRegions) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinIrlsModeWeight, other.MinIrlsModeWeight)) return false;
      if (NumTopIrlsModes != other.NumTopIrlsModes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ModeBandWidth, other.ModeBandWidth)) return false;
      if (SelectionFrameRadius != other.SelectionFrameRadius) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SelectionSupportDistance, other.SelectionSupportDistance)) return false;
      if (SelectionMinimumSupport != other.SelectionMinimumSupport) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FilteringSigmaSpace, other.FilteringSigmaSpace)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FilteringSigmaTime, other.FilteringSigmaTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBoundLeft) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BoundLeft);
      if (HasBoundBottom) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BoundBottom);
      if (HasBoundRight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BoundRight);
      if (HasBoundTop) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BoundTop);
      if (HasSaliencyWeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SaliencyWeight);
      if (HasScaleWeightByFlowMagnitude) hash ^= ScaleWeightByFlowMagnitude.GetHashCode();
      if (HasMinFeatures) hash ^= MinFeatures.GetHashCode();
      if (HasUseOnlyForegroundRegions) hash ^= UseOnlyForegroundRegions.GetHashCode();
      if (HasMinIrlsModeWeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinIrlsModeWeight);
      if (HasNumTopIrlsModes) hash ^= NumTopIrlsModes.GetHashCode();
      if (HasModeBandWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ModeBandWidth);
      if (HasSelectionFrameRadius) hash ^= SelectionFrameRadius.GetHashCode();
      if (HasSelectionSupportDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SelectionSupportDistance);
      if (HasSelectionMinimumSupport) hash ^= SelectionMinimumSupport.GetHashCode();
      if (HasFilteringSigmaSpace) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FilteringSigmaSpace);
      if (HasFilteringSigmaTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FilteringSigmaTime);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasBoundLeft) {
        output.WriteRawTag(13);
        output.WriteFloat(BoundLeft);
      }
      if (HasBoundBottom) {
        output.WriteRawTag(21);
        output.WriteFloat(BoundBottom);
      }
      if (HasSaliencyWeight) {
        output.WriteRawTag(29);
        output.WriteFloat(SaliencyWeight);
      }
      if (HasMinFeatures) {
        output.WriteRawTag(32);
        output.WriteInt32(MinFeatures);
      }
      if (HasSelectionFrameRadius) {
        output.WriteRawTag(40);
        output.WriteInt32(SelectionFrameRadius);
      }
      if (HasSelectionSupportDistance) {
        output.WriteRawTag(53);
        output.WriteFloat(SelectionSupportDistance);
      }
      if (HasSelectionMinimumSupport) {
        output.WriteRawTag(56);
        output.WriteInt32(SelectionMinimumSupport);
      }
      if (HasScaleWeightByFlowMagnitude) {
        output.WriteRawTag(64);
        output.WriteBool(ScaleWeightByFlowMagnitude);
      }
      if (HasUseOnlyForegroundRegions) {
        output.WriteRawTag(72);
        output.WriteBool(UseOnlyForegroundRegions);
      }
      if (HasMinIrlsModeWeight) {
        output.WriteRawTag(85);
        output.WriteFloat(MinIrlsModeWeight);
      }
      if (HasNumTopIrlsModes) {
        output.WriteRawTag(88);
        output.WriteInt32(NumTopIrlsModes);
      }
      if (HasModeBandWidth) {
        output.WriteRawTag(101);
        output.WriteFloat(ModeBandWidth);
      }
      if (HasFilteringSigmaSpace) {
        output.WriteRawTag(109);
        output.WriteFloat(FilteringSigmaSpace);
      }
      if (HasFilteringSigmaTime) {
        output.WriteRawTag(117);
        output.WriteFloat(FilteringSigmaTime);
      }
      if (HasBoundRight) {
        output.WriteRawTag(125);
        output.WriteFloat(BoundRight);
      }
      if (HasBoundTop) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(BoundTop);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasBoundLeft) {
        output.WriteRawTag(13);
        output.WriteFloat(BoundLeft);
      }
      if (HasBoundBottom) {
        output.WriteRawTag(21);
        output.WriteFloat(BoundBottom);
      }
      if (HasSaliencyWeight) {
        output.WriteRawTag(29);
        output.WriteFloat(SaliencyWeight);
      }
      if (HasMinFeatures) {
        output.WriteRawTag(32);
        output.WriteInt32(MinFeatures);
      }
      if (HasSelectionFrameRadius) {
        output.WriteRawTag(40);
        output.WriteInt32(SelectionFrameRadius);
      }
      if (HasSelectionSupportDistance) {
        output.WriteRawTag(53);
        output.WriteFloat(SelectionSupportDistance);
      }
      if (HasSelectionMinimumSupport) {
        output.WriteRawTag(56);
        output.WriteInt32(SelectionMinimumSupport);
      }
      if (HasScaleWeightByFlowMagnitude) {
        output.WriteRawTag(64);
        output.WriteBool(ScaleWeightByFlowMagnitude);
      }
      if (HasUseOnlyForegroundRegions) {
        output.WriteRawTag(72);
        output.WriteBool(UseOnlyForegroundRegions);
      }
      if (HasMinIrlsModeWeight) {
        output.WriteRawTag(85);
        output.WriteFloat(MinIrlsModeWeight);
      }
      if (HasNumTopIrlsModes) {
        output.WriteRawTag(88);
        output.WriteInt32(NumTopIrlsModes);
      }
      if (HasModeBandWidth) {
        output.WriteRawTag(101);
        output.WriteFloat(ModeBandWidth);
      }
      if (HasFilteringSigmaSpace) {
        output.WriteRawTag(109);
        output.WriteFloat(FilteringSigmaSpace);
      }
      if (HasFilteringSigmaTime) {
        output.WriteRawTag(117);
        output.WriteFloat(FilteringSigmaTime);
      }
      if (HasBoundRight) {
        output.WriteRawTag(125);
        output.WriteFloat(BoundRight);
      }
      if (HasBoundTop) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(BoundTop);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasBoundLeft) {
        size += 1 + 4;
      }
      if (HasBoundBottom) {
        size += 1 + 4;
      }
      if (HasBoundRight) {
        size += 1 + 4;
      }
      if (HasBoundTop) {
        size += 2 + 4;
      }
      if (HasSaliencyWeight) {
        size += 1 + 4;
      }
      if (HasScaleWeightByFlowMagnitude) {
        size += 1 + 1;
      }
      if (HasMinFeatures) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinFeatures);
      }
      if (HasUseOnlyForegroundRegions) {
        size += 1 + 1;
      }
      if (HasMinIrlsModeWeight) {
        size += 1 + 4;
      }
      if (HasNumTopIrlsModes) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumTopIrlsModes);
      }
      if (HasModeBandWidth) {
        size += 1 + 4;
      }
      if (HasSelectionFrameRadius) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SelectionFrameRadius);
      }
      if (HasSelectionSupportDistance) {
        size += 1 + 4;
      }
      if (HasSelectionMinimumSupport) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SelectionMinimumSupport);
      }
      if (HasFilteringSigmaSpace) {
        size += 1 + 4;
      }
      if (HasFilteringSigmaTime) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MotionSaliencyOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasBoundLeft) {
        BoundLeft = other.BoundLeft;
      }
      if (other.HasBoundBottom) {
        BoundBottom = other.BoundBottom;
      }
      if (other.HasBoundRight) {
        BoundRight = other.BoundRight;
      }
      if (other.HasBoundTop) {
        BoundTop = other.BoundTop;
      }
      if (other.HasSaliencyWeight) {
        SaliencyWeight = other.SaliencyWeight;
      }
      if (other.HasScaleWeightByFlowMagnitude) {
        ScaleWeightByFlowMagnitude = other.ScaleWeightByFlowMagnitude;
      }
      if (other.HasMinFeatures) {
        MinFeatures = other.MinFeatures;
      }
      if (other.HasUseOnlyForegroundRegions) {
        UseOnlyForegroundRegions = other.UseOnlyForegroundRegions;
      }
      if (other.HasMinIrlsModeWeight) {
        MinIrlsModeWeight = other.MinIrlsModeWeight;
      }
      if (other.HasNumTopIrlsModes) {
        NumTopIrlsModes = other.NumTopIrlsModes;
      }
      if (other.HasModeBandWidth) {
        ModeBandWidth = other.ModeBandWidth;
      }
      if (other.HasSelectionFrameRadius) {
        SelectionFrameRadius = other.SelectionFrameRadius;
      }
      if (other.HasSelectionSupportDistance) {
        SelectionSupportDistance = other.SelectionSupportDistance;
      }
      if (other.HasSelectionMinimumSupport) {
        SelectionMinimumSupport = other.SelectionMinimumSupport;
      }
      if (other.HasFilteringSigmaSpace) {
        FilteringSigmaSpace = other.FilteringSigmaSpace;
      }
      if (other.HasFilteringSigmaTime) {
        FilteringSigmaTime = other.FilteringSigmaTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            BoundLeft = input.ReadFloat();
            break;
          }
          case 21: {
            BoundBottom = input.ReadFloat();
            break;
          }
          case 29: {
            SaliencyWeight = input.ReadFloat();
            break;
          }
          case 32: {
            MinFeatures = input.ReadInt32();
            break;
          }
          case 40: {
            SelectionFrameRadius = input.ReadInt32();
            break;
          }
          case 53: {
            SelectionSupportDistance = input.ReadFloat();
            break;
          }
          case 56: {
            SelectionMinimumSupport = input.ReadInt32();
            break;
          }
          case 64: {
            ScaleWeightByFlowMagnitude = input.ReadBool();
            break;
          }
          case 72: {
            UseOnlyForegroundRegions = input.ReadBool();
            break;
          }
          case 85: {
            MinIrlsModeWeight = input.ReadFloat();
            break;
          }
          case 88: {
            NumTopIrlsModes = input.ReadInt32();
            break;
          }
          case 101: {
            ModeBandWidth = input.ReadFloat();
            break;
          }
          case 109: {
            FilteringSigmaSpace = input.ReadFloat();
            break;
          }
          case 117: {
            FilteringSigmaTime = input.ReadFloat();
            break;
          }
          case 125: {
            BoundRight = input.ReadFloat();
            break;
          }
          case 133: {
            BoundTop = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            BoundLeft = input.ReadFloat();
            break;
          }
          case 21: {
            BoundBottom = input.ReadFloat();
            break;
          }
          case 29: {
            SaliencyWeight = input.ReadFloat();
            break;
          }
          case 32: {
            MinFeatures = input.ReadInt32();
            break;
          }
          case 40: {
            SelectionFrameRadius = input.ReadInt32();
            break;
          }
          case 53: {
            SelectionSupportDistance = input.ReadFloat();
            break;
          }
          case 56: {
            SelectionMinimumSupport = input.ReadInt32();
            break;
          }
          case 64: {
            ScaleWeightByFlowMagnitude = input.ReadBool();
            break;
          }
          case 72: {
            UseOnlyForegroundRegions = input.ReadBool();
            break;
          }
          case 85: {
            MinIrlsModeWeight = input.ReadFloat();
            break;
          }
          case 88: {
            NumTopIrlsModes = input.ReadInt32();
            break;
          }
          case 101: {
            ModeBandWidth = input.ReadFloat();
            break;
          }
          case 109: {
            FilteringSigmaSpace = input.ReadFloat();
            break;
          }
          case 117: {
            FilteringSigmaTime = input.ReadFloat();
            break;
          }
          case 125: {
            BoundRight = input.ReadFloat();
            break;
          }
          case 133: {
            BoundTop = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/util/tracking/camera_motion.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/util/tracking/camera_motion.proto</summary>
  public static partial class CameraMotionReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/util/tracking/camera_motion.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CameraMotionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CittZWRpYXBpcGUvdXRpbC90cmFja2luZy9jYW1lcmFfbW90aW9uLnByb3Rv",
            "EgltZWRpYXBpcGUaK21lZGlhcGlwZS91dGlsL3RyYWNraW5nL21vdGlvbl9t",
            "b2RlbHMucHJvdG8ihgsKDENhbWVyYU1vdGlvbhIwCgt0cmFuc2xhdGlvbhgB",
            "IAEoCzIbLm1lZGlhcGlwZS5UcmFuc2xhdGlvbk1vZGVsEi4KCnNpbWlsYXJp",
            "dHkYAiABKAsyGi5tZWRpYXBpcGUuU2ltaWxhcml0eU1vZGVsEjsKEWxpbmVh",
            "cl9zaW1pbGFyaXR5GAMgASgLMiAubWVkaWFwaXBlLkxpbmVhclNpbWlsYXJp",
            "dHlNb2RlbBImCgZhZmZpbmUYBCABKAsyFi5tZWRpYXBpcGUuQWZmaW5lTW9k",
            "ZWwSKQoKaG9tb2dyYXBoeRgFIAEoCzIVLm1lZGlhcGlwZS5Ib21vZ3JhcGh5",
            "EjgKEm1peHR1cmVfaG9tb2dyYXBoeRgIIAEoCzIcLm1lZGlhcGlwZS5NaXh0",
            "dXJlSG9tb2dyYXBoeRITCgtmcmFtZV93aWR0aBgfIAEoAhIUCgxmcmFtZV9o",
            "ZWlnaHQYICABKAISQQobbWl4dHVyZV9ob21vZ3JhcGh5X3NwZWN0cnVtGBcg",
            "AygLMhwubWVkaWFwaXBlLk1peHR1cmVIb21vZ3JhcGh5EhkKEW1peHR1cmVf",
            "cm93X3NpZ21hGAogASgCEhwKEWF2ZXJhZ2VfbWFnbml0dWRlGBggASgCOgEw",
            "Eh8KFHRyYW5zbGF0aW9uX3ZhcmlhbmNlGBkgASgCOgEwEiIKF3NpbWlsYXJp",
            "dHlfaW5saWVyX3JhdGlvGB0gASgCOgEwEikKHnNpbWlsYXJpdHlfc3RyaWN0",
            "X2lubGllcl9yYXRpbxgeIAEoAjoBMBIgChhhdmVyYWdlX2hvbW9ncmFwaHlf",
            "ZXJyb3IYCyABKAISIgoaaG9tb2dyYXBoeV9pbmxpZXJfY292ZXJhZ2UYDCAB",
            "KAISKQohaG9tb2dyYXBoeV9zdHJpY3RfaW5saWVyX2NvdmVyYWdlGBYgASgC",
            "Eh8KF21peHR1cmVfaW5saWVyX2NvdmVyYWdlGA0gAygCEh0KFXJvbGxpbmdf",
            "c2h1dHRlcl9ndWVzcxgOIAEoAhIoChxyb2xsaW5nX3NodXR0ZXJfbW90aW9u",
            "X2luZGV4GBAgASgFOgItMRIXCg9vdmVybGF5X2luZGljZXMYESADKAUSGgoO",
            "b3ZlcmxheV9kb21haW4YEiABKAU6AjEwEjEKBHR5cGUYBiABKA4yHC5tZWRp",
            "YXBpcGUuQ2FtZXJhTW90aW9uLlR5cGU6BVZBTElEEjwKD292ZXJyaWRkZW5f",
            "dHlwZRgPIAEoDjIcLm1lZGlhcGlwZS5DYW1lcmFNb3Rpb24uVHlwZToFVkFM",
            "SUQSEAoFZmxhZ3MYEyABKAU6ATASEgoKYmx1cl9zY29yZRgUIAEoAhIUCgli",
            "bHVyaW5lc3MYFSABKAI6ATASIwobZnJhY19sb25nX2ZlYXR1cmVzX3JlamVj",
            "dGVkGBogASgCEhkKDnRpbWVzdGFtcF91c2VjGBsgASgDOgEwEhYKC21hdGNo",
            "X2ZyYW1lGBwgASgFOgEwIlIKBFR5cGUSCQoFVkFMSUQQABISCg5VTlNUQUJM",
            "RV9IT01PRxABEhAKDFVOU1RBQkxFX1NJTRACEgwKCFVOU1RBQkxFEAMSCwoH",
            "SU5WQUxJRBAEIsMBCgVGbGFncxIWChJGTEFHX1NIT1RfQk9VTkRBUlkQARIV",
            "ChFGTEFHX0JMVVJSWV9GUkFNRRACEhYKEkZMQUdfTUFKT1JfT1ZFUkxBWRAE",
            "EhQKEEZMQUdfU0hBUlBfRlJBTUUQCBIcChhGTEFHX1NJTkdVTEFSX0VTVElN",
            "QVRJT04QEBISCg5GTEFHX1NIT1RfRkFERRAgEhMKD0ZMQUdfRFVQTElDQVRF",
            "RBBAEhYKEUZMQUdfQ0VOVEVSX0ZSQU1FEIABKgQICRAK"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.MotionModelsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.CameraMotion), global::Mediapipe.CameraMotion.Parser, new[]{ "Translation", "Similarity", "LinearSimilarity", "Affine", "Homography", "MixtureHomography", "FrameWidth", "FrameHeight", "MixtureHomographySpectrum", "MixtureRowSigma", "AverageMagnitude", "TranslationVariance", "SimilarityInlierRatio", "SimilarityStrictInlierRatio", "AverageHomographyError", "HomographyInlierCoverage", "HomographyStrictInlierCoverage", "MixtureInlierCoverage", "RollingShutterGuess", "RollingShutterMotionIndex", "OverlayIndices", "OverlayDomain", "Type", "OverriddenType", "Flags", "BlurScore", "Bluriness", "FracLongFeaturesRejected", "TimestampUsec", "MatchFrame" }, null, new[]{ typeof(global::Mediapipe.CameraMotion.Types.Type), typeof(global::Mediapipe.CameraMotion.Types.Flags) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Next tag: 33
  /// </summary>
  public sealed partial class CameraMotion : pb::IExtendableMessage<CameraMotion>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CameraMotion> _parser = new pb::MessageParser<CameraMotion>(() => new CameraMotion());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<CameraMotion> _extensions;
    private pb::ExtensionSet<CameraMotion> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CameraMotion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CameraMotionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CameraMotion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CameraMotion(CameraMotion other) : this() {
      _hasBits0 = other._hasBits0;
      translation_ = other.translation_ != null ? other.translation_.Clone() : null;
      similarity_ = other.similarity_ != null ? other.similarity_.Clone() : null;
      linearSimilarity_ = other.linearSimilarity_ != null ? other.linearSimilarity_.Clone() : null;
      affine_ = other.affine_ != null ? other.affine_.Clone() : null;
      homography_ = other.homography_ != null ? other.homography_.Clone() : null;
      mixtureHomography_ = other.mixtureHomography_ != null ? other.mixtureHomography_.Clone() : null;
      frameWidth_ = other.frameWidth_;
      frameHeight_ = other.frameHeight_;
      mixtureHomographySpectrum_ = other.mixtureHomographySpectrum_.Clone();
      mixtureRowSigma_ = other.mixtureRowSigma_;
      averageMagnitude_ = other.averageMagnitude_;
      translationVariance_ = other.translationVariance_;
      similarityInlierRatio_ = other.similarityInlierRatio_;
      similarityStrictInlierRatio_ = other.similarityStrictInlierRatio_;
      averageHomographyError_ = other.averageHomographyError_;
      homographyInlierCoverage_ = other.homographyInlierCoverage_;
      homographyStrictInlierCoverage_ = other.homographyStrictInlierCoverage_;
      mixtureInlierCoverage_ = other.mixtureInlierCoverage_.Clone();
      rollingShutterGuess_ = other.rollingShutterGuess_;
      rollingShutterMotionIndex_ = other.rollingShutterMotionIndex_;
      overlayIndices_ = other.overlayIndices_.Clone();
      overlayDomain_ = other.overlayDomain_;
      type_ = other.type_;
      overriddenType_ = other.overriddenType_;
      flags_ = other.flags_;
      blurScore_ = other.blurScore_;
      bluriness_ = other.bluriness_;
      fracLongFeaturesRejected_ = other.fracLongFeaturesRejected_;
      timestampUsec_ = other.timestampUsec_;
      matchFrame_ = other.matchFrame_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CameraMotion Clone() {
      return new CameraMotion(this);
    }

    /// <summary>Field number for the "translation" field.</summary>
    public const int TranslationFieldNumber = 1;
    private global::Mediapipe.TranslationModel translation_;
    /// <summary>
    /// Background motion expressed in various models.
    /// These are per-frame pair motions (from current to previous frame).
    /// Models are expressed in the un-normalized domain frame_width x frame_height
    /// that is passed to MotionEstimation (storred below).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.TranslationModel Translation {
      get { return translation_; }
      set {
        translation_ = value;
      }
    }

    /// <summary>Field number for the "similarity" field.</summary>
    public const int SimilarityFieldNumber = 2;
    private global::Mediapipe.SimilarityModel similarity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.SimilarityModel Similarity {
      get { return similarity_; }
      set {
        similarity_ = value;
      }
    }

    /// <summary>Field number for the "linear_similarity" field.</summary>
    public const int LinearSimilarityFieldNumber = 3;
    private global::Mediapipe.LinearSimilarityModel linearSimilarity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.LinearSimilarityModel LinearSimilarity {
      get { return linearSimilarity_; }
      set {
        linearSimilarity_ = value;
      }
    }

    /// <summary>Field number for the "affine" field.</summary>
    public const int AffineFieldNumber = 4;
    private global::Mediapipe.AffineModel affine_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.AffineModel Affine {
      get { return affine_; }
      set {
        affine_ = value;
      }
    }

    /// <summary>Field number for the "homography" field.</summary>
    public const int HomographyFieldNumber = 5;
    private global::Mediapipe.Homography homography_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.Homography Homography {
      get { return homography_; }
      set {
        homography_ = value;
      }
    }

    /// <summary>Field number for the "mixture_homography" field.</summary>
    public const int MixtureHomographyFieldNumber = 8;
    private global::Mediapipe.MixtureHomography mixtureHomography_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MixtureHomography MixtureHomography {
      get { return mixtureHomography_; }
      set {
        mixtureHomography_ = value;
      }
    }

    /// <summary>Field number for the "frame_width" field.</summary>
    public const int FrameWidthFieldNumber = 31;
    private readonly static float FrameWidthDefaultValue = 0F;

    private float frameWidth_;
    /// <summary>
    /// Frame dimensions camera motion was computed over.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FrameWidth {
      get { if ((_hasBits0 & 524288) != 0) { return frameWidth_; } else { return FrameWidthDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        frameWidth_ = value;
      }
    }
    /// <summary>Gets whether the "frame_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFrameWidth {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "frame_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFrameWidth() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "frame_height" field.</summary>
    public const int FrameHeightFieldNumber = 32;
    private readonly static float FrameHeightDefaultValue = 0F;

    private float frameHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FrameHeight {
      get { if ((_hasBits0 & 1048576) != 0) { return frameHeight_; } else { return FrameHeightDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        frameHeight_ = value;
      }
    }
    /// <summary>Gets whether the "frame_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFrameHeight {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "frame_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFrameHeight() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "mixture_homography_spectrum" field.</summary>
    public const int MixtureHomographySpectrumFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Mediapipe.MixtureHomography> _repeated_mixtureHomographySpectrum_codec
        = pb::FieldCodec.ForMessage(186, global::Mediapipe.MixtureHomography.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.MixtureHomography> mixtureHomographySpectrum_ = new pbc::RepeatedField<global::Mediapipe.MixtureHomography>();
    /// <summary>
    /// Mixture homographies computed w.r.t. exponentially increasing
    /// regularizers. Above mixture_homography member is selected from spectrum
    /// based on amount of rolling shutter present in the video.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.MixtureHomography> MixtureHomographySpectrum {
      get { return mixtureHomographySpectrum_; }
    }

    /// <summary>Field number for the "mixture_row_sigma" field.</summary>
    public const int MixtureRowSigmaFieldNumber = 10;
    private readonly static float MixtureRowSigmaDefaultValue = 0F;

    private float mixtureRowSigma_;
    /// <summary>
    /// Relative row sigma w.r.t. frame_height for mixture models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MixtureRowSigma {
      get { if ((_hasBits0 & 2) != 0) { return mixtureRowSigma_; } else { return MixtureRowSigmaDefaultValue; } }
      set {
        _hasBits0 |= 2;
        mixtureRowSigma_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_row_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRowSigma {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "mixture_row_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRowSigma() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "average_magnitude" field.</summary>
    public const int AverageMagnitudeFieldNumber = 24;
    private readonly static float AverageMagnitudeDefaultValue = 0F;

    private float averageMagnitude_;
    /// <summary>
    /// Average of all motion vector magnitudes (without accounting for any motion
    /// model), within 10th to 90th percentile (to remove outliers).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AverageMagnitude {
      get { if ((_hasBits0 & 4096) != 0) { return averageMagnitude_; } else { return AverageMagnitudeDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        averageMagnitude_ = value;
      }
    }
    /// <summary>Gets whether the "average_magnitude" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAverageMagnitude {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "average_magnitude" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAverageMagnitude() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "translation_variance" field.</summary>
    public const int TranslationVarianceFieldNumber = 25;
    private readonly static float TranslationVarianceDefaultValue = 0F;

    private float translationVariance_;
    /// <summary>
    /// Inlier-weighted variance of the translation model.
    /// Specified, w.r.t. unnormalized video domain that motion models
    /// are computed for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float TranslationVariance {
      get { if ((_hasBits0 & 8192) != 0) { return translationVariance_; } else { return TranslationVarianceDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        translationVariance_ = value;
      }
    }
    /// <summary>Gets whether the "translation_variance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTranslationVariance {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "translation_variance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTranslationVariance() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "similarity_inlier_ratio" field.</summary>
    public const int SimilarityInlierRatioFieldNumber = 29;
    private readonly static float SimilarityInlierRatioDefaultValue = 0F;

    private float similarityInlierRatio_;
    /// <summary>
    /// Ratio of inliers w.r.t. regular and stricter thresholds. In [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SimilarityInlierRatio {
      get { if ((_hasBits0 & 131072) != 0) { return similarityInlierRatio_; } else { return SimilarityInlierRatioDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        similarityInlierRatio_ = value;
      }
    }
    /// <summary>Gets whether the "similarity_inlier_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSimilarityInlierRatio {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "similarity_inlier_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSimilarityInlierRatio() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "similarity_strict_inlier_ratio" field.</summary>
    public const int SimilarityStrictInlierRatioFieldNumber = 30;
    private readonly static float SimilarityStrictInlierRatioDefaultValue = 0F;

    private float similarityStrictInlierRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SimilarityStrictInlierRatio {
      get { if ((_hasBits0 & 262144) != 0) { return similarityStrictInlierRatio_; } else { return SimilarityStrictInlierRatioDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        similarityStrictInlierRatio_ = value;
      }
    }
    /// <summary>Gets whether the "similarity_strict_inlier_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSimilarityStrictInlierRatio {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "similarity_strict_inlier_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSimilarityStrictInlierRatio() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "average_homography_error" field.</summary>
    public const int AverageHomographyErrorFieldNumber = 11;
    private readonly static float AverageHomographyErrorDefaultValue = 0F;

    private float averageHomographyError_;
    /// <summary>
    /// Average registration error of homography in pixels.
    /// Note: These two parameters default to zero in-case homographies have not
    /// been estimated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AverageHomographyError {
      get { if ((_hasBits0 & 4) != 0) { return averageHomographyError_; } else { return AverageHomographyErrorDefaultValue; } }
      set {
        _hasBits0 |= 4;
        averageHomographyError_ = value;
      }
    }
    /// <summary>Gets whether the "average_homography_error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAverageHomographyError {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "average_homography_error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAverageHomographyError() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "homography_inlier_coverage" field.</summary>
    public const int HomographyInlierCoverageFieldNumber = 12;
    private readonly static float HomographyInlierCoverageDefaultValue = 0F;

    private float homographyInlierCoverage_;
    /// <summary>
    /// Fraction, in [0,1], of homography inliers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float HomographyInlierCoverage {
      get { if ((_hasBits0 & 8) != 0) { return homographyInlierCoverage_; } else { return HomographyInlierCoverageDefaultValue; } }
      set {
        _hasBits0 |= 8;
        homographyInlierCoverage_ = value;
      }
    }
    /// <summary>Gets whether the "homography_inlier_coverage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyInlierCoverage {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "homography_inlier_coverage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyInlierCoverage() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "homography_strict_inlier_coverage" field.</summary>
    public const int HomographyStrictInlierCoverageFieldNumber = 22;
    private readonly static float HomographyStrictInlierCoverageDefaultValue = 0F;

    private float homographyStrictInlierCoverage_;
    /// <summary>
    /// Same as above but with stricter threshold.
    /// (For details, see: MotionEstimationOptions::strict_coverage_scale).
    /// Coverage is designed to measure the amount of significant outliers,
    /// which can affect the validity of the estimated homography.
    /// However, it does not discount small outliers, which occur in case
    /// of small rolling shutter wobbles. For this a stricter version of coverage
    /// is needed, which is essential for computing the rolling_shutter_guess,
    /// i.e. the increase in coverage by using mixtures vs. homographies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float HomographyStrictInlierCoverage {
      get { if ((_hasBits0 & 2048) != 0) { return homographyStrictInlierCoverage_; } else { return HomographyStrictInlierCoverageDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        homographyStrictInlierCoverage_ = value;
      }
    }
    /// <summary>Gets whether the "homography_strict_inlier_coverage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyStrictInlierCoverage {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "homography_strict_inlier_coverage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyStrictInlierCoverage() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "mixture_inlier_coverage" field.</summary>
    public const int MixtureInlierCoverageFieldNumber = 13;
    private static readonly pb::FieldCodec<float> _repeated_mixtureInlierCoverage_codec
        = pb::FieldCodec.ForFloat(109);
    private readonly pbc::RepeatedField<float> mixtureInlierCoverage_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Per-block inlier fraction for mixtures.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> MixtureInlierCoverage {
      get { return mixtureInlierCoverage_; }
    }

    /// <summary>Field number for the "rolling_shutter_guess" field.</summary>
    public const int RollingShutterGuessFieldNumber = 14;
    private readonly static float RollingShutterGuessDefaultValue = 0F;

    private float rollingShutterGuess_;
    /// <summary>
    /// Set based on stability analysis indicating if frame is likely to originate
    /// from a rolling shutter camera. (-1 is used to indicate frame was not
    /// tested, e.g. due to mixture deemed unstable for analysis).
    /// Guess is a scaler indicating by how much the mixture models (suitable for
    /// rolling shutter distortions) increased inlier coverage compared to a single
    /// homography. For example a value, of 1.3 indicates, that the mixture models
    /// increased inlier coverage by 30%.
    /// If not -1, range is in [0, inf] (values slightly smaller than 1 are
    /// possible due to suppression of noisy feature tracks during estimation).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RollingShutterGuess {
      get { if ((_hasBits0 & 16) != 0) { return rollingShutterGuess_; } else { return RollingShutterGuessDefaultValue; } }
      set {
        _hasBits0 |= 16;
        rollingShutterGuess_ = value;
      }
    }
    /// <summary>Gets whether the "rolling_shutter_guess" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRollingShutterGuess {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "rolling_shutter_guess" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRollingShutterGuess() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "rolling_shutter_motion_index" field.</summary>
    public const int RollingShutterMotionIndexFieldNumber = 16;
    private readonly static int RollingShutterMotionIndexDefaultValue = -1;

    private int rollingShutterMotionIndex_;
    /// <summary>
    /// Indicating if CameraMotion is deemed to originate from rolling
    /// shutter camera (index >= 0), and if so, denotes the index in the
    /// mixture_homography_spectrum, where higher indices correspond to heavier
    /// regularized motions. If motion is not deemed to originate from a rolling
    /// shutter camera, index is set to -1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RollingShutterMotionIndex {
      get { if ((_hasBits0 & 64) != 0) { return rollingShutterMotionIndex_; } else { return RollingShutterMotionIndexDefaultValue; } }
      set {
        _hasBits0 |= 64;
        rollingShutterMotionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "rolling_shutter_motion_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRollingShutterMotionIndex {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "rolling_shutter_motion_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRollingShutterMotionIndex() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "overlay_indices" field.</summary>
    public const int OverlayIndicesFieldNumber = 17;
    private static readonly pb::FieldCodec<int> _repeated_overlayIndices_codec
        = pb::FieldCodec.ForInt32(136);
    private readonly pbc::RepeatedField<int> overlayIndices_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// List of overlay indices (cell locations in column major format) over domain
    /// of size overlay_domain x overlay_domain, where
    /// overlay_domain is set by MotionEstimation to
    /// MotionEstimationOptions::OverlayDetectionOptions::analysis_mask_size.
    /// Overlay analysis is performed over chunk of frames, as specified by
    /// MotionEstimationOptions::overlay_analysis_chunk_size, with the resulting
    /// overlay indices being assigned to each frame of the chunk.
    /// Consequently it suffices to store the result only for the first frame
    /// of every chunk. Subsequent frames store a single negative index relative
    /// to the first chunk frame indicating where to locate the overlay indicies.
    /// Specifically if for frame f, overlay_indices(0) == -2, overlay indices for
    /// corresponding chunk can be found at frame f - 2.
    /// For details about how overlay indices are used to flag a frame to contain
    /// an overlay, see MotionFilterOptions::OverlayOptions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> OverlayIndices {
      get { return overlayIndices_; }
    }

    /// <summary>Field number for the "overlay_domain" field.</summary>
    public const int OverlayDomainFieldNumber = 18;
    private readonly static int OverlayDomainDefaultValue = 10;

    private int overlayDomain_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int OverlayDomain {
      get { if ((_hasBits0 & 128) != 0) { return overlayDomain_; } else { return OverlayDomainDefaultValue; } }
      set {
        _hasBits0 |= 128;
        overlayDomain_ = value;
      }
    }
    /// <summary>Gets whether the "overlay_domain" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverlayDomain {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "overlay_domain" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverlayDomain() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 6;
    private readonly static global::Mediapipe.CameraMotion.Types.Type TypeDefaultValue = global::Mediapipe.CameraMotion.Types.Type.Valid;

    private global::Mediapipe.CameraMotion.Types.Type type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.CameraMotion.Types.Type Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "overridden_type" field.</summary>
    public const int OverriddenTypeFieldNumber = 15;
    private readonly static global::Mediapipe.CameraMotion.Types.Type OverriddenTypeDefaultValue = global::Mediapipe.CameraMotion.Types.Type.Valid;

    private global::Mediapipe.CameraMotion.Types.Type overriddenType_;
    /// <summary>
    /// If set, stores original type in case it was overriden (by filtering
    /// functions, etc.).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.CameraMotion.Types.Type OverriddenType {
      get { if ((_hasBits0 & 32) != 0) { return overriddenType_; } else { return OverriddenTypeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        overriddenType_ = value;
      }
    }
    /// <summary>Gets whether the "overridden_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverriddenType {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "overridden_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverriddenType() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 19;
    private readonly static int FlagsDefaultValue = 0;

    private int flags_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Flags {
      get { if ((_hasBits0 & 256) != 0) { return flags_; } else { return FlagsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        flags_ = value;
      }
    }
    /// <summary>Gets whether the "flags" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFlags {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "flags" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFlags() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "blur_score" field.</summary>
    public const int BlurScoreFieldNumber = 20;
    private readonly static float BlurScoreDefaultValue = 0F;

    private float blurScore_;
    /// <summary>
    /// Same as in RegionFlowFeatureList (from region_flow.proto), measures blur
    /// as average cornerness over textured areas. As it depends on the image
    /// content, should only be used relative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BlurScore {
      get { if ((_hasBits0 & 512) != 0) { return blurScore_; } else { return BlurScoreDefaultValue; } }
      set {
        _hasBits0 |= 512;
        blurScore_ = value;
      }
    }
    /// <summary>Gets whether the "blur_score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBlurScore {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "blur_score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBlurScore() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "bluriness" field.</summary>
    public const int BlurinessFieldNumber = 21;
    private readonly static float BlurinessDefaultValue = 0F;

    private float bluriness_;
    /// <summary>
    /// Quanitifies amount of blur. Specified as ratio w.r.t. sharpest matching
    /// frame, i.e. 1 indicates no blur, values > 1 amount of blur w.r.t. sharpest
    /// frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Bluriness {
      get { if ((_hasBits0 & 1024) != 0) { return bluriness_; } else { return BlurinessDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        bluriness_ = value;
      }
    }
    /// <summary>Gets whether the "bluriness" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBluriness {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "bluriness" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBluriness() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "frac_long_features_rejected" field.</summary>
    public const int FracLongFeaturesRejectedFieldNumber = 26;
    private readonly static float FracLongFeaturesRejectedDefaultValue = 0F;

    private float fracLongFeaturesRejected_;
    /// <summary>
    /// Same as in RegionFlowFeatureList (from region_flow.proto). Stores fraction
    /// of long feature tracks that got rejected for this frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FracLongFeaturesRejected {
      get { if ((_hasBits0 & 16384) != 0) { return fracLongFeaturesRejected_; } else { return FracLongFeaturesRejectedDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        fracLongFeaturesRejected_ = value;
      }
    }
    /// <summary>Gets whether the "frac_long_features_rejected" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFracLongFeaturesRejected {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "frac_long_features_rejected" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFracLongFeaturesRejected() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "timestamp_usec" field.</summary>
    public const int TimestampUsecFieldNumber = 27;
    private readonly static long TimestampUsecDefaultValue = 0L;

    private long timestampUsec_;
    /// <summary>
    /// Same as in RegionFlowFeatureList (from region_flow.proto).
    /// Timestamp in micro seconds of the underlying frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TimestampUsec {
      get { if ((_hasBits0 & 32768) != 0) { return timestampUsec_; } else { return TimestampUsecDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        timestampUsec_ = value;
      }
    }
    /// <summary>Gets whether the "timestamp_usec" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestampUsec {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "timestamp_usec" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestampUsec() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "match_frame" field.</summary>
    public const int MatchFrameFieldNumber = 28;
    private readonly static int MatchFrameDefaultValue = 0;

    private int matchFrame_;
    /// <summary>
    /// Same as in RegionFlowFeatureList (from region_flow.proto).
    /// Denotes frame that motion was computed w.r.t. to, locally to the current
    /// frame. Values &lt; 0 indicate backward tracking, while values > 0 indicate
    /// forward tracking. For example, match_frame = -1, indicates tracking is
    /// from current to previous frame.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MatchFrame {
      get { if ((_hasBits0 & 65536) != 0) { return matchFrame_; } else { return MatchFrameDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        matchFrame_ = value;
      }
    }
    /// <summary>Gets whether the "match_frame" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMatchFrame {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "match_frame" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMatchFrame() {
      _hasBits0 &= ~65536;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CameraMotion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CameraMotion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Translation, other.Translation)) return false;
      if (!object.Equals(Similarity, other.Similarity)) return false;
      if (!object.Equals(LinearSimilarity, other.LinearSimilarity)) return false;
      if (!object.Equals(Affine, other.Affine)) return false;
      if (!object.Equals(Homography, other.Homography)) return false;
      if (!object.Equals(MixtureHomography, other.MixtureHomography)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FrameWidth, other.FrameWidth)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FrameHeight, other.FrameHeight)) return false;
      if(!mixtureHomographySpectrum_.Equals(other.mixtureHomographySpectrum_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MixtureRowSigma, other.MixtureRowSigma)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AverageMagnitude, other.AverageMagnitude)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TranslationVariance, other.TranslationVariance)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SimilarityInlierRatio, other.SimilarityInlierRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SimilarityStrictInlierRatio, other.SimilarityStrictInlierRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AverageHomographyError, other.AverageHomographyError)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HomographyInlierCoverage, other.HomographyInlierCoverage)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HomographyStrictInlierCoverage, other.HomographyStrictInlierCoverage)) return false;
      if(!mixtureInlierCoverage_.Equals(other.mixtureInlierCoverage_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RollingShutterGuess, other.RollingShutterGuess)) return false;
      if (RollingShutterMotionIndex != other.RollingShutterMotionIndex) return false;
      if(!overlayIndices_.Equals(other.overlayIndices_)) return false;
      if (OverlayDomain != other.OverlayDomain) return false;
      if (Type != other.Type) return false;
      if (OverriddenType != other.OverriddenType) return false;
      if (Flags != other.Flags) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BlurScore, other.BlurScore)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Bluriness, other.Bluriness)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracLongFeaturesRejected, other.FracLongFeaturesRejected)) return false;
      if (TimestampUsec != other.TimestampUsec) return false;
      if (MatchFrame != other.MatchFrame) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (translation_ != null) hash ^= Translation.GetHashCode();
      if (similarity_ != null) hash ^= Similarity.GetHashCode();
      if (linearSimilarity_ != null) hash ^= LinearSimilarity.GetHashCode();
      if (affine_ != null) hash ^= Affine.GetHashCode();
      if (homography_ != null) hash ^= Homography.GetHashCode();
      if (mixtureHomography_ != null) hash ^= MixtureHomography.GetHashCode();
      if (HasFrameWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FrameWidth);
      if (HasFrameHeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FrameHeight);
      hash ^= mixtureHomographySpectrum_.GetHashCode();
      if (HasMixtureRowSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MixtureRowSigma);
      if (HasAverageMagnitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AverageMagnitude);
      if (HasTranslationVariance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TranslationVariance);
      if (HasSimilarityInlierRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SimilarityInlierRatio);
      if (HasSimilarityStrictInlierRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SimilarityStrictInlierRatio);
      if (HasAverageHomographyError) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AverageHomographyError);
      if (HasHomographyInlierCoverage) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HomographyInlierCoverage);
      if (HasHomographyStrictInlierCoverage) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HomographyStrictInlierCoverage);
      hash ^= mixtureInlierCoverage_.GetHashCode();
      if (HasRollingShutterGuess) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RollingShutterGuess);
      if (HasRollingShutterMotionIndex) hash ^= RollingShutterMotionIndex.GetHashCode();
      hash ^= overlayIndices_.GetHashCode();
      if (HasOverlayDomain) hash ^= OverlayDomain.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasOverriddenType) hash ^= OverriddenType.GetHashCode();
      if (HasFlags) hash ^= Flags.GetHashCode();
      if (HasBlurScore) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BlurScore);
      if (HasBluriness) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Bluriness);
      if (HasFracLongFeaturesRejected) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracLongFeaturesRejected);
      if (HasTimestampUsec) hash ^= TimestampUsec.GetHashCode();
      if (HasMatchFrame) hash ^= MatchFrame.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (translation_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Translation);
      }
      if (similarity_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Similarity);
      }
      if (linearSimilarity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LinearSimilarity);
      }
      if (affine_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Affine);
      }
      if (homography_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Homography);
      }
      if (HasType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Type);
      }
      if (mixtureHomography_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MixtureHomography);
      }
      if (HasMixtureRowSigma) {
        output.WriteRawTag(85);
        output.WriteFloat(MixtureRowSigma);
      }
      if (HasAverageHomographyError) {
        output.WriteRawTag(93);
        output.WriteFloat(AverageHomographyError);
      }
      if (HasHomographyInlierCoverage) {
        output.WriteRawTag(101);
        output.WriteFloat(HomographyInlierCoverage);
      }
      mixtureInlierCoverage_.WriteTo(output, _repeated_mixtureInlierCoverage_codec);
      if (HasRollingShutterGuess) {
        output.WriteRawTag(117);
        output.WriteFloat(RollingShutterGuess);
      }
      if (HasOverriddenType) {
        output.WriteRawTag(120);
        output.WriteEnum((int) OverriddenType);
      }
      if (HasRollingShutterMotionIndex) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(RollingShutterMotionIndex);
      }
      overlayIndices_.WriteTo(output, _repeated_overlayIndices_codec);
      if (HasOverlayDomain) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(OverlayDomain);
      }
      if (HasFlags) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(Flags);
      }
      if (HasBlurScore) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(BlurScore);
      }
      if (HasBluriness) {
        output.WriteRawTag(173, 1);
        output.WriteFloat(Bluriness);
      }
      if (HasHomographyStrictInlierCoverage) {
        output.WriteRawTag(181, 1);
        output.WriteFloat(HomographyStrictInlierCoverage);
      }
      mixtureHomographySpectrum_.WriteTo(output, _repeated_mixtureHomographySpectrum_codec);
      if (HasAverageMagnitude) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(AverageMagnitude);
      }
      if (HasTranslationVariance) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(TranslationVariance);
      }
      if (HasFracLongFeaturesRejected) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(FracLongFeaturesRejected);
      }
      if (HasTimestampUsec) {
        output.WriteRawTag(216, 1);
        output.WriteInt64(TimestampUsec);
      }
      if (HasMatchFrame) {
        output.WriteRawTag(224, 1);
        output.WriteInt32(MatchFrame);
      }
      if (HasSimilarityInlierRatio) {
        output.WriteRawTag(237, 1);
        output.WriteFloat(SimilarityInlierRatio);
      }
      if (HasSimilarityStrictInlierRatio) {
        output.WriteRawTag(245, 1);
        output.WriteFloat(SimilarityStrictInlierRatio);
      }
      if (HasFrameWidth) {
        output.WriteRawTag(253, 1);
        output.WriteFloat(FrameWidth);
      }
      if (HasFrameHeight) {
        output.WriteRawTag(133, 2);
        output.WriteFloat(FrameHeight);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (translation_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Translation);
      }
      if (similarity_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Similarity);
      }
      if (linearSimilarity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LinearSimilarity);
      }
      if (affine_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Affine);
      }
      if (homography_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Homography);
      }
      if (HasType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Type);
      }
      if (mixtureHomography_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MixtureHomography);
      }
      if (HasMixtureRowSigma) {
        output.WriteRawTag(85);
        output.WriteFloat(MixtureRowSigma);
      }
      if (HasAverageHomographyError) {
        output.WriteRawTag(93);
        output.WriteFloat(AverageHomographyError);
      }
      if (HasHomographyInlierCoverage) {
        output.WriteRawTag(101);
        output.WriteFloat(HomographyInlierCoverage);
      }
      mixtureInlierCoverage_.WriteTo(ref output, _repeated_mixtureInlierCoverage_codec);
      if (HasRollingShutterGuess) {
        output.WriteRawTag(117);
        output.WriteFloat(RollingShutterGuess);
      }
      if (HasOverriddenType) {
        output.WriteRawTag(120);
        output.WriteEnum((int) OverriddenType);
      }
      if (HasRollingShutterMotionIndex) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(RollingShutterMotionIndex);
      }
      overlayIndices_.WriteTo(ref output, _repeated_overlayIndices_codec);
      if (HasOverlayDomain) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(OverlayDomain);
      }
      if (HasFlags) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(Flags);
      }
      if (HasBlurScore) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(BlurScore);
      }
      if (HasBluriness) {
        output.WriteRawTag(173, 1);
        output.WriteFloat(Bluriness);
      }
      if (HasHomographyStrictInlierCoverage) {
        output.WriteRawTag(181, 1);
        output.WriteFloat(HomographyStrictInlierCoverage);
      }
      mixtureHomographySpectrum_.WriteTo(ref output, _repeated_mixtureHomographySpectrum_codec);
      if (HasAverageMagnitude) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(AverageMagnitude);
      }
      if (HasTranslationVariance) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(TranslationVariance);
      }
      if (HasFracLongFeaturesRejected) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(FracLongFeaturesRejected);
      }
      if (HasTimestampUsec) {
        output.WriteRawTag(216, 1);
        output.WriteInt64(TimestampUsec);
      }
      if (HasMatchFrame) {
        output.WriteRawTag(224, 1);
        output.WriteInt32(MatchFrame);
      }
      if (HasSimilarityInlierRatio) {
        output.WriteRawTag(237, 1);
        output.WriteFloat(SimilarityInlierRatio);
      }
      if (HasSimilarityStrictInlierRatio) {
        output.WriteRawTag(245, 1);
        output.WriteFloat(SimilarityStrictInlierRatio);
      }
      if (HasFrameWidth) {
        output.WriteRawTag(253, 1);
        output.WriteFloat(FrameWidth);
      }
      if (HasFrameHeight) {
        output.WriteRawTag(133, 2);
        output.WriteFloat(FrameHeight);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (translation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Translation);
      }
      if (similarity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Similarity);
      }
      if (linearSimilarity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LinearSimilarity);
      }
      if (affine_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Affine);
      }
      if (homography_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Homography);
      }
      if (mixtureHomography_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MixtureHomography);
      }
      if (HasFrameWidth) {
        size += 2 + 4;
      }
      if (HasFrameHeight) {
        size += 2 + 4;
      }
      size += mixtureHomographySpectrum_.CalculateSize(_repeated_mixtureHomographySpectrum_codec);
      if (HasMixtureRowSigma) {
        size += 1 + 4;
      }
      if (HasAverageMagnitude) {
        size += 2 + 4;
      }
      if (HasTranslationVariance) {
        size += 2 + 4;
      }
      if (HasSimilarityInlierRatio) {
        size += 2 + 4;
      }
      if (HasSimilarityStrictInlierRatio) {
        size += 2 + 4;
      }
      if (HasAverageHomographyError) {
        size += 1 + 4;
      }
      if (HasHomographyInlierCoverage) {
        size += 1 + 4;
      }
      if (HasHomographyStrictInlierCoverage) {
        size += 2 + 4;
      }
      size += mixtureInlierCoverage_.CalculateSize(_repeated_mixtureInlierCoverage_codec);
      if (HasRollingShutterGuess) {
        size += 1 + 4;
      }
      if (HasRollingShutterMotionIndex) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(RollingShutterMotionIndex);
      }
      size += overlayIndices_.CalculateSize(_repeated_overlayIndices_codec);
      if (HasOverlayDomain) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(OverlayDomain);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasOverriddenType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OverriddenType);
      }
      if (HasFlags) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Flags);
      }
      if (HasBlurScore) {
        size += 2 + 4;
      }
      if (HasBluriness) {
        size += 2 + 4;
      }
      if (HasFracLongFeaturesRejected) {
        size += 2 + 4;
      }
      if (HasTimestampUsec) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(TimestampUsec);
      }
      if (HasMatchFrame) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MatchFrame);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CameraMotion other) {
      if (other == null) {
        return;
      }
      if (other.translation_ != null) {
        if (translation_ == null) {
          Translation = new global::Mediapipe.TranslationModel();
        }
        Translation.MergeFrom(other.Translation);
      }
      if (other.similarity_ != null) {
        if (similarity_ == null) {
          Similarity = new global::Mediapipe.SimilarityModel();
        }
        Similarity.MergeFrom(other.Similarity);
      }
      if (other.linearSimilarity_ != null) {
        if (linearSimilarity_ == null) {
          LinearSimilarity = new global::Mediapipe.LinearSimilarityModel();
        }
        LinearSimilarity.MergeFrom(other.LinearSimilarity);
      }
      if (other.affine_ != null) {
        if (affine_ == null) {
          Affine = new global::Mediapipe.AffineModel();
        }
        Affine.MergeFrom(other.Affine);
      }
      if (other.homography_ != null) {
        if (homography_ == null) {
          Homography = new global::Mediapipe.Homography();
        }
        Homography.MergeFrom(other.Homography);
      }
      if (other.mixtureHomography_ != null) {
        if (mixtureHomography_ == null) {
          MixtureHomography = new global::Mediapipe.MixtureHomography();
        }
        MixtureHomography.MergeFrom(other.MixtureHomography);
      }
      if (other.HasFrameWidth) {
        FrameWidth = other.FrameWidth;
      }
      if (other.HasFrameHeight) {
        FrameHeight = other.FrameHeight;
      }
      mixtureHomographySpectrum_.Add(other.mixtureHomographySpectrum_);
      if (other.HasMixtureRowSigma) {
        MixtureRowSigma = other.MixtureRowSigma;
      }
      if (other.HasAverageMagnitude) {
        AverageMagnitude = other.AverageMagnitude;
      }
      if (other.HasTranslationVariance) {
        TranslationVariance = other.TranslationVariance;
      }
      if (other.HasSimilarityInlierRatio) {
        SimilarityInlierRatio = other.SimilarityInlierRatio;
      }
      if (other.HasSimilarityStrictInlierRatio) {
        SimilarityStrictInlierRatio = other.SimilarityStrictInlierRatio;
      }
      if (other.HasAverageHomographyError) {
        AverageHomographyError = other.AverageHomographyError;
      }
      if (other.HasHomographyInlierCoverage) {
        HomographyInlierCoverage = other.HomographyInlierCoverage;
      }
      if (other.HasHomographyStrictInlierCoverage) {
        HomographyStrictInlierCoverage = other.HomographyStrictInlierCoverage;
      }
      mixtureInlierCoverage_.Add(other.mixtureInlierCoverage_);
      if (other.HasRollingShutterGuess) {
        RollingShutterGuess = other.RollingShutterGuess;
      }
      if (other.HasRollingShutterMotionIndex) {
        RollingShutterMotionIndex = other.RollingShutterMotionIndex;
      }
      overlayIndices_.Add(other.overlayIndices_);
      if (other.HasOverlayDomain) {
        OverlayDomain = other.OverlayDomain;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasOverriddenType) {
        OverriddenType = other.OverriddenType;
      }
      if (other.HasFlags) {
        Flags = other.Flags;
      }
      if (other.HasBlurScore) {
        BlurScore = other.BlurScore;
      }
      if (other.HasBluriness) {
        Bluriness = other.Bluriness;
      }
      if (other.HasFracLongFeaturesRejected) {
        FracLongFeaturesRejected = other.FracLongFeaturesRejected;
      }
      if (other.HasTimestampUsec) {
        TimestampUsec = other.TimestampUsec;
      }
      if (other.HasMatchFrame) {
        MatchFrame = other.MatchFrame;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (translation_ == null) {
              Translation = new global::Mediapipe.TranslationModel();
            }
            input.ReadMessage(Translation);
            break;
          }
          case 18: {
            if (similarity_ == null) {
              Similarity = new global::Mediapipe.SimilarityModel();
            }
            input.ReadMessage(Similarity);
            break;
          }
          case 26: {
            if (linearSimilarity_ == null) {
              LinearSimilarity = new global::Mediapipe.LinearSimilarityModel();
            }
            input.ReadMessage(LinearSimilarity);
            break;
          }
          case 34: {
            if (affine_ == null) {
              Affine = new global::Mediapipe.AffineModel();
            }
            input.ReadMessage(Affine);
            break;
          }
          case 42: {
            if (homography_ == null) {
              Homography = new global::Mediapipe.Homography();
            }
            input.ReadMessage(Homography);
            break;
          }
          case 48: {
            Type = (global::Mediapipe.CameraMotion.Types.Type) input.ReadEnum();
            break;
          }
          case 66: {
            if (mixtureHomography_ == null) {
              MixtureHomography = new global::Mediapipe.MixtureHomography();
            }
            input.ReadMessage(MixtureHomography);
            break;
          }
          case 85: {
            MixtureRowSigma = input.ReadFloat();
            break;
          }
          case 93: {
            AverageHomographyError = input.ReadFloat();
            break;
          }
          case 101: {
            HomographyInlierCoverage = input.ReadFloat();
            break;
          }
          case 106:
          case 109: {
            mixtureInlierCoverage_.AddEntriesFrom(input, _repeated_mixtureInlierCoverage_codec);
            break;
          }
          case 117: {
            RollingShutterGuess = input.ReadFloat();
            break;
          }
          case 120: {
            OverriddenType = (global::Mediapipe.CameraMotion.Types.Type) input.ReadEnum();
            break;
          }
          case 128: {
            RollingShutterMotionIndex = input.ReadInt32();
            break;
          }
          case 138:
          case 136: {
            overlayIndices_.AddEntriesFrom(input, _repeated_overlayIndices_codec);
            break;
          }
          case 144: {
            OverlayDomain = input.ReadInt32();
            break;
          }
          case 152: {
            Flags = input.ReadInt32();
            break;
          }
          case 165: {
            BlurScore = input.ReadFloat();
            break;
          }
          case 173: {
            Bluriness = input.ReadFloat();
            break;
          }
          case 181: {
            HomographyStrictInlierCoverage = input.ReadFloat();
            break;
          }
          case 186: {
            mixtureHomographySpectrum_.AddEntriesFrom(input, _repeated_mixtureHomographySpectrum_codec);
            break;
          }
          case 197: {
            AverageMagnitude = input.ReadFloat();
            break;
          }
          case 205: {
            TranslationVariance = input.ReadFloat();
            break;
          }
          case 213: {
            FracLongFeaturesRejected = input.ReadFloat();
            break;
          }
          case 216: {
            TimestampUsec = input.ReadInt64();
            break;
          }
          case 224: {
            MatchFrame = input.ReadInt32();
            break;
          }
          case 237: {
            SimilarityInlierRatio = input.ReadFloat();
            break;
          }
          case 245: {
            SimilarityStrictInlierRatio = input.ReadFloat();
            break;
          }
          case 253: {
            FrameWidth = input.ReadFloat();
            break;
          }
          case 261: {
            FrameHeight = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            if (translation_ == null) {
              Translation = new global::Mediapipe.TranslationModel();
            }
            input.ReadMessage(Translation);
            break;
          }
          case 18: {
            if (similarity_ == null) {
              Similarity = new global::Mediapipe.SimilarityModel();
            }
            input.ReadMessage(Similarity);
            break;
          }
          case 26: {
            if (linearSimilarity_ == null) {
              LinearSimilarity = new global::Mediapipe.LinearSimilarityModel();
            }
            input.ReadMessage(LinearSimilarity);
            break;
          }
          case 34: {
            if (affine_ == null) {
              Affine = new global::Mediapipe.AffineModel();
            }
            input.ReadMessage(Affine);
            break;
          }
          case 42: {
            if (homography_ == null) {
              Homography = new global::Mediapipe.Homography();
            }
            input.ReadMessage(Homography);
            break;
          }
          case 48: {
            Type = (global::Mediapipe.CameraMotion.Types.Type) input.ReadEnum();
            break;
          }
          case 66: {
            if (mixtureHomography_ == null) {
              MixtureHomography = new global::Mediapipe.MixtureHomography();
            }
            input.ReadMessage(MixtureHomography);
            break;
          }
          case 85: {
            MixtureRowSigma = input.ReadFloat();
            break;
          }
          case 93: {
            AverageHomographyError = input.ReadFloat();
            break;
          }
          case 101: {
            HomographyInlierCoverage = input.ReadFloat();
            break;
          }
          case 106:
          case 109: {
            mixtureInlierCoverage_.AddEntriesFrom(ref input, _repeated_mixtureInlierCoverage_codec);
            break;
          }
          case 117: {
            RollingShutterGuess = input.ReadFloat();
            break;
          }
          case 120: {
            OverriddenType = (global::Mediapipe.CameraMotion.Types.Type) input.ReadEnum();
            break;
          }
          case 128: {
            RollingShutterMotionIndex = input.ReadInt32();
            break;
          }
          case 138:
          case 136: {
            overlayIndices_.AddEntriesFrom(ref input, _repeated_overlayIndices_codec);
            break;
          }
          case 144: {
            OverlayDomain = input.ReadInt32();
            break;
          }
          case 152: {
            Flags = input.ReadInt32();
            break;
          }
          case 165: {
            BlurScore = input.ReadFloat();
            break;
          }
          case 173: {
            Bluriness = input.ReadFloat();
            break;
          }
          case 181: {
            HomographyStrictInlierCoverage = input.ReadFloat();
            break;
          }
          case 186: {
            mixtureHomographySpectrum_.AddEntriesFrom(ref input, _repeated_mixtureHomographySpectrum_codec);
            break;
          }
          case 197: {
            AverageMagnitude = input.ReadFloat();
            break;
          }
          case 205: {
            TranslationVariance = input.ReadFloat();
            break;
          }
          case 213: {
            FracLongFeaturesRejected = input.ReadFloat();
            break;
          }
          case 216: {
            TimestampUsec = input.ReadInt64();
            break;
          }
          case 224: {
            MatchFrame = input.ReadInt32();
            break;
          }
          case 237: {
            SimilarityInlierRatio = input.ReadFloat();
            break;
          }
          case 245: {
            SimilarityStrictInlierRatio = input.ReadFloat();
            break;
          }
          case 253: {
            FrameWidth = input.ReadFloat();
            break;
          }
          case 261: {
            FrameHeight = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<CameraMotion, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<CameraMotion, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<CameraMotion, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<CameraMotion, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<CameraMotion, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<CameraMotion, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<CameraMotion, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CameraMotion message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// CameraMotion type indicates whether highest degree of freedom (DOF)
      /// model estimation was deemed stable, in which case CameraMotion::Type is set
      /// to VALID.
      /// If a model was deemed not stable (according to *StabilityBounds in
      /// MotionEstimationOptions), it is set to the lower dof type which was deemed
      /// stable.
      /// </summary>
      public enum Type {
        /// <summary>
        /// All requested motion models estimated reliably.
        /// </summary>
        [pbr::OriginalName("VALID")] Valid = 0,
        /// <summary>
        /// Fallback to homographies, mixture unreliable.
        /// </summary>
        [pbr::OriginalName("UNSTABLE_HOMOG")] UnstableHomog = 1,
        /// <summary>
        /// Fallback to similarity model, homography
        /// </summary>
        [pbr::OriginalName("UNSTABLE_SIM")] UnstableSim = 2,
        /// <summary>
        /// unreliable.
        /// </summary>
        [pbr::OriginalName("UNSTABLE")] Unstable = 3,
        /// <summary>
        /// unreliable, legacy naming.
        /// </summary>
        [pbr::OriginalName("INVALID")] Invalid = 4,
      }

      /// <summary>
      /// Set of optional *bit* flags set for various purposes.
      /// </summary>
      public enum Flags {
        /// <summary>
        /// Set to indicate presence of a
        /// </summary>
        [pbr::OriginalName("FLAG_SHOT_BOUNDARY")] HotBoundary = 1,
        /// <summary>
        /// shot boundary.
        /// </summary>
        [pbr::OriginalName("FLAG_BLURRY_FRAME")] FlagBlurryFrame = 2,
        [pbr::OriginalName("FLAG_MAJOR_OVERLAY")] FlagMajorOverlay = 4,
        /// <summary>
        /// Set if frame is considered sharp
        /// </summary>
        [pbr::OriginalName("FLAG_SHARP_FRAME")] HarpFrame = 8,
        /// <summary>
        /// in a neighborhood of frames.
        /// </summary>
        [pbr::OriginalName("FLAG_SINGULAR_ESTIMATION")] IngularEstimation = 16,
        /// <summary>
        /// in singular optimization problem.
        /// Used internally by MotionEstimation.
        /// Indicates if shot boundary is part of a fade. If so, all frames of the
        /// fade will be labeled with the FLAG but only the begin and end of the fade
        /// will have the FLAG_SHOT_BOUNDARY set.
        /// </summary>
        [pbr::OriginalName("FLAG_SHOT_FADE")] HotFade = 32,
        /// <summary>
        /// Set if frame is exact duplicate of
        /// </summary>
        [pbr::OriginalName("FLAG_DUPLICATED")] FlagDuplicated = 64,
        /// <summary>
        /// previous frame.
        /// </summary>
        [pbr::OriginalName("FLAG_CENTER_FRAME")] FlagCenterFrame = 128,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

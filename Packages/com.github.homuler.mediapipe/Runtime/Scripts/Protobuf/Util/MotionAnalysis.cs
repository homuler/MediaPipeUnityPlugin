// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/util/tracking/motion_analysis.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/util/tracking/motion_analysis.proto</summary>
  public static partial class MotionAnalysisReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/util/tracking/motion_analysis.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MotionAnalysisReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci1tZWRpYXBpcGUvdXRpbC90cmFja2luZy9tb3Rpb25fYW5hbHlzaXMucHJv",
            "dG8SCW1lZGlhcGlwZRovbWVkaWFwaXBlL3V0aWwvdHJhY2tpbmcvbW90aW9u",
            "X2VzdGltYXRpb24ucHJvdG8aLW1lZGlhcGlwZS91dGlsL3RyYWNraW5nL21v",
            "dGlvbl9zYWxpZW5jeS5wcm90bxo1bWVkaWFwaXBlL3V0aWwvdHJhY2tpbmcv",
            "cmVnaW9uX2Zsb3dfY29tcHV0YXRpb24ucHJvdG8i+AoKFU1vdGlvbkFuYWx5",
            "c2lzT3B0aW9ucxJgCg9hbmFseXNpc19wb2xpY3kYDiABKA4yLy5tZWRpYXBp",
            "cGUuTW90aW9uQW5hbHlzaXNPcHRpb25zLkFuYWx5c2lzUG9saWN5OhZBTkFM",
            "WVNJU19QT0xJQ1lfTEVHQUNZEj0KDGZsb3dfb3B0aW9ucxgBIAEoCzInLm1l",
            "ZGlhcGlwZS5SZWdpb25GbG93Q29tcHV0YXRpb25PcHRpb25zEjoKDm1vdGlv",
            "bl9vcHRpb25zGAIgASgLMiIubWVkaWFwaXBlLk1vdGlvbkVzdGltYXRpb25P",
            "cHRpb25zEjoKEHNhbGllbmN5X29wdGlvbnMYAyABKAsyIC5tZWRpYXBpcGUu",
            "TW90aW9uU2FsaWVuY3lPcHRpb25zEiAKFGVzdGltYXRpb25fY2xpcF9zaXpl",
            "GAQgASgFOgIxNhIzCiRzdWJ0cmFjdF9jYW1lcmFfbW90aW9uX2Zyb21fZmVh",
            "dHVyZXMYBSABKAg6BWZhbHNlEhYKC3RyYWNrX2luZGV4GAYgASgFOgEwEiYK",
            "F2NvbXB1dGVfbW90aW9uX3NhbGllbmN5GAcgASgIOgVmYWxzZRIlChdzZWxl",
            "Y3Rfc2FsaWVuY3lfaW5saWVycxgIIAEoCDoEdHJ1ZRIdCg9maWx0ZXJfc2Fs",
            "aWVuY3kYCSABKAg6BHRydWUSIgoTcG9zdF9pcmxzX3Ntb290aGluZxgKIAEo",
            "CDoFZmFsc2USKQodcmVqZWN0aW9uX3RyYW5zZm9ybV90aHJlc2hvbGQYDSAB",
            "KAI6AjIwElQKFXZpc3VhbGl6YXRpb25fb3B0aW9ucxgLIAEoCzI1Lm1lZGlh",
            "cGlwZS5Nb3Rpb25BbmFseXNpc09wdGlvbnMuVmlzdWFsaXphdGlvbk9wdGlv",
            "bnMSTgoSZm9yZWdyb3VuZF9vcHRpb25zGAwgASgLMjIubWVkaWFwaXBlLk1v",
            "dGlvbkFuYWx5c2lzT3B0aW9ucy5Gb3JlZ3JvdW5kT3B0aW9ucxrFAgoUVmlz",
            "dWFsaXphdGlvbk9wdGlvbnMSLAoedmlzdWFsaXplX3JlZ2lvbl9mbG93X2Zl",
            "YXR1cmVzGAEgASgIOgR0cnVlEicKGHZpc3VhbGl6ZV9zYWxpZW50X3BvaW50",
            "cxgCIAEoCDoFZmFsc2USGQoObGluZV90aGlja25lc3MYBSABKAU6ATQSJgoX",
            "Zm9yZWdyb3VuZF9qZXRfY29sb3JpbmcYAyABKAg6BWZhbHNlEi0KHnZpc3Vh",
            "bGl6ZV9ibHVyX2FuYWx5c2lzX3JlZ2lvbhgEIAEoCDoFZmFsc2USHQoPdmlz",
            "dWFsaXplX3N0YXRzGAYgASgIOgR0cnVlEiEKFm1pbl9sb25nX2ZlYXR1cmVf",
            "dHJhY2sYByABKAU6ATASIgoXbWF4X2xvbmdfZmVhdHVyZV9wb2ludHMYCCAB",
            "KAU6ATAafQoRRm9yZWdyb3VuZE9wdGlvbnMSIQoUZm9yZWdyb3VuZF90aHJl",
            "c2hvbGQYASABKAI6AzAuNRIbChBmb3JlZ3JvdW5kX2dhbW1hGAIgASgCOgEx",
            "EigKGnRocmVzaG9sZF9jb3ZlcmFnZV9zY2FsaW5nGAMgASgIOgR0cnVlIqwB",
            "Cg5BbmFseXNpc1BvbGljeRIaChZBTkFMWVNJU19QT0xJQ1lfTEVHQUNZEAAS",
            "GQoVQU5BTFlTSVNfUE9MSUNZX1ZJREVPEAESIAocQU5BTFlTSVNfUE9MSUNZ",
            "X1ZJREVPX01PQklMRRACEiEKHUFOQUxZU0lTX1BPTElDWV9DQU1FUkFfTU9C",
            "SUxFEAMSHgoaQU5BTFlTSVNfUE9MSUNZX0hZUEVSTEFQU0UQBA=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.MotionEstimationReflection.Descriptor, global::Mediapipe.MotionSaliencyReflection.Descriptor, global::Mediapipe.RegionFlowComputationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionAnalysisOptions), global::Mediapipe.MotionAnalysisOptions.Parser, new[]{ "AnalysisPolicy", "FlowOptions", "MotionOptions", "SaliencyOptions", "EstimationClipSize", "SubtractCameraMotionFromFeatures", "TrackIndex", "ComputeMotionSaliency", "SelectSaliencyInliers", "FilterSaliency", "PostIrlsSmoothing", "RejectionTransformThreshold", "VisualizationOptions", "ForegroundOptions" }, null, new[]{ typeof(global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions), global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions.Parser, new[]{ "VisualizeRegionFlowFeatures", "VisualizeSalientPoints", "LineThickness", "ForegroundJetColoring", "VisualizeBlurAnalysisRegion", "VisualizeStats", "MinLongFeatureTrack", "MaxLongFeaturePoints" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions), global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions.Parser, new[]{ "ForegroundThreshold", "ForegroundGamma", "ThresholdCoverageScaling" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Settings for MotionAnalysis. This class computes sparse, locally consistent
  /// flow (referred to as region flow), camera motions, and foreground saliency
  /// (i.e. likely foreground objects moving different from the background).
  /// Next tag: 16
  /// </summary>
  public sealed partial class MotionAnalysisOptions : pb::IMessage<MotionAnalysisOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MotionAnalysisOptions> _parser = new pb::MessageParser<MotionAnalysisOptions>(() => new MotionAnalysisOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MotionAnalysisOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.MotionAnalysisReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisOptions(MotionAnalysisOptions other) : this() {
      _hasBits0 = other._hasBits0;
      analysisPolicy_ = other.analysisPolicy_;
      flowOptions_ = other.flowOptions_ != null ? other.flowOptions_.Clone() : null;
      motionOptions_ = other.motionOptions_ != null ? other.motionOptions_.Clone() : null;
      saliencyOptions_ = other.saliencyOptions_ != null ? other.saliencyOptions_.Clone() : null;
      estimationClipSize_ = other.estimationClipSize_;
      subtractCameraMotionFromFeatures_ = other.subtractCameraMotionFromFeatures_;
      trackIndex_ = other.trackIndex_;
      computeMotionSaliency_ = other.computeMotionSaliency_;
      selectSaliencyInliers_ = other.selectSaliencyInliers_;
      filterSaliency_ = other.filterSaliency_;
      postIrlsSmoothing_ = other.postIrlsSmoothing_;
      rejectionTransformThreshold_ = other.rejectionTransformThreshold_;
      visualizationOptions_ = other.visualizationOptions_ != null ? other.visualizationOptions_.Clone() : null;
      foregroundOptions_ = other.foregroundOptions_ != null ? other.foregroundOptions_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionAnalysisOptions Clone() {
      return new MotionAnalysisOptions(this);
    }

    /// <summary>Field number for the "analysis_policy" field.</summary>
    public const int AnalysisPolicyFieldNumber = 14;
    private readonly static global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy AnalysisPolicyDefaultValue = global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy.Legacy;

    private global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy analysisPolicy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy AnalysisPolicy {
      get { if ((_hasBits0 & 256) != 0) { return analysisPolicy_; } else { return AnalysisPolicyDefaultValue; } }
      set {
        _hasBits0 |= 256;
        analysisPolicy_ = value;
      }
    }
    /// <summary>Gets whether the "analysis_policy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnalysisPolicy {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "analysis_policy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnalysisPolicy() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "flow_options" field.</summary>
    public const int FlowOptionsFieldNumber = 1;
    private global::Mediapipe.RegionFlowComputationOptions flowOptions_;
    /// <summary>
    /// Options for the actual motion stabilization
    /// (in order of object usage).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.RegionFlowComputationOptions FlowOptions {
      get { return flowOptions_; }
      set {
        flowOptions_ = value;
      }
    }

    /// <summary>Field number for the "motion_options" field.</summary>
    public const int MotionOptionsFieldNumber = 2;
    private global::Mediapipe.MotionEstimationOptions motionOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions MotionOptions {
      get { return motionOptions_; }
      set {
        motionOptions_ = value;
      }
    }

    /// <summary>Field number for the "saliency_options" field.</summary>
    public const int SaliencyOptionsFieldNumber = 3;
    private global::Mediapipe.MotionSaliencyOptions saliencyOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionSaliencyOptions SaliencyOptions {
      get { return saliencyOptions_; }
      set {
        saliencyOptions_ = value;
      }
    }

    /// <summary>Field number for the "estimation_clip_size" field.</summary>
    public const int EstimationClipSizeFieldNumber = 4;
    private readonly static int EstimationClipSizeDefaultValue = 16;

    private int estimationClipSize_;
    /// <summary>
    /// Clip-size used for (parallelized) motion estimation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int EstimationClipSize {
      get { if ((_hasBits0 & 1) != 0) { return estimationClipSize_; } else { return EstimationClipSizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        estimationClipSize_ = value;
      }
    }
    /// <summary>Gets whether the "estimation_clip_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimationClipSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "estimation_clip_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimationClipSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subtract_camera_motion_from_features" field.</summary>
    public const int SubtractCameraMotionFromFeaturesFieldNumber = 5;
    private readonly static bool SubtractCameraMotionFromFeaturesDefaultValue = false;

    private bool subtractCameraMotionFromFeatures_;
    /// <summary>
    /// If set, camera motion is subtracted from features before output.
    /// Effectively outputs, residual motion w.r.t. background.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SubtractCameraMotionFromFeatures {
      get { if ((_hasBits0 & 2) != 0) { return subtractCameraMotionFromFeatures_; } else { return SubtractCameraMotionFromFeaturesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        subtractCameraMotionFromFeatures_ = value;
      }
    }
    /// <summary>Gets whether the "subtract_camera_motion_from_features" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubtractCameraMotionFromFeatures {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "subtract_camera_motion_from_features" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubtractCameraMotionFromFeatures() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "track_index" field.</summary>
    public const int TrackIndexFieldNumber = 6;
    private readonly static int TrackIndexDefaultValue = 0;

    private int trackIndex_;
    /// <summary>
    /// If flow_options().tracking_options().tracking_policy() equals
    /// POLICY_MULTI_FRAME, this flag indicates which RegionFlowFeatureList to use.
    /// Specifically, for frame C, we use the motion from C to C - 1 - track_index.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TrackIndex {
      get { if ((_hasBits0 & 4) != 0) { return trackIndex_; } else { return TrackIndexDefaultValue; } }
      set {
        _hasBits0 |= 4;
        trackIndex_ = value;
      }
    }
    /// <summary>Gets whether the "track_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrackIndex {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "track_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTrackIndex() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "compute_motion_saliency" field.</summary>
    public const int ComputeMotionSaliencyFieldNumber = 7;
    private readonly static bool ComputeMotionSaliencyDefaultValue = false;

    private bool computeMotionSaliency_;
    /// <summary>
    /// If set, compute motion saliency (regions of moving foreground).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ComputeMotionSaliency {
      get { if ((_hasBits0 & 8) != 0) { return computeMotionSaliency_; } else { return ComputeMotionSaliencyDefaultValue; } }
      set {
        _hasBits0 |= 8;
        computeMotionSaliency_ = value;
      }
    }
    /// <summary>Gets whether the "compute_motion_saliency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasComputeMotionSaliency {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "compute_motion_saliency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearComputeMotionSaliency() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "select_saliency_inliers" field.</summary>
    public const int SelectSaliencyInliersFieldNumber = 8;
    private readonly static bool SelectSaliencyInliersDefaultValue = true;

    private bool selectSaliencyInliers_;
    /// <summary>
    /// Selects saliency inliers (only saliency locations with sufficient
    /// spatial and temporal support are kept).
    /// Only applied when compute_motion_saliency is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SelectSaliencyInliers {
      get { if ((_hasBits0 & 16) != 0) { return selectSaliencyInliers_; } else { return SelectSaliencyInliersDefaultValue; } }
      set {
        _hasBits0 |= 16;
        selectSaliencyInliers_ = value;
      }
    }
    /// <summary>Gets whether the "select_saliency_inliers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSelectSaliencyInliers {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "select_saliency_inliers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelectSaliencyInliers() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "filter_saliency" field.</summary>
    public const int FilterSaliencyFieldNumber = 9;
    private readonly static bool FilterSaliencyDefaultValue = true;

    private bool filterSaliency_;
    /// <summary>
    /// Performs spatio-temporal filtering of extracted foreground saliency. If
    /// used with above selection of saliency inliers, filtering is performed
    /// *after* inlier selection.
    /// Only applied when compute_motion_saliency is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FilterSaliency {
      get { if ((_hasBits0 & 32) != 0) { return filterSaliency_; } else { return FilterSaliencyDefaultValue; } }
      set {
        _hasBits0 |= 32;
        filterSaliency_ = value;
      }
    }
    /// <summary>Gets whether the "filter_saliency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilterSaliency {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "filter_saliency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilterSaliency() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "post_irls_smoothing" field.</summary>
    public const int PostIrlsSmoothingFieldNumber = 10;
    private readonly static bool PostIrlsSmoothingDefaultValue = false;

    private bool postIrlsSmoothing_;
    /// <summary>
    /// If set, irls weights of motion estimation are spatio-temporally smoothed
    /// after model estimation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PostIrlsSmoothing {
      get { if ((_hasBits0 & 64) != 0) { return postIrlsSmoothing_; } else { return PostIrlsSmoothingDefaultValue; } }
      set {
        _hasBits0 |= 64;
        postIrlsSmoothing_ = value;
      }
    }
    /// <summary>Gets whether the "post_irls_smoothing" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPostIrlsSmoothing {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "post_irls_smoothing" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPostIrlsSmoothing() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "rejection_transform_threshold" field.</summary>
    public const int RejectionTransformThresholdFieldNumber = 13;
    private readonly static float RejectionTransformThresholdDefaultValue = 20F;

    private float rejectionTransformThreshold_;
    /// <summary>
    /// If a rejection_transform is passed to AddFrameGeneric, features that
    /// do not agree with the transform within below threshold are removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float RejectionTransformThreshold {
      get { if ((_hasBits0 & 128) != 0) { return rejectionTransformThreshold_; } else { return RejectionTransformThresholdDefaultValue; } }
      set {
        _hasBits0 |= 128;
        rejectionTransformThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "rejection_transform_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRejectionTransformThreshold {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "rejection_transform_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRejectionTransformThreshold() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "visualization_options" field.</summary>
    public const int VisualizationOptionsFieldNumber = 11;
    private global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions visualizationOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions VisualizationOptions {
      get { return visualizationOptions_; }
      set {
        visualizationOptions_ = value;
      }
    }

    /// <summary>Field number for the "foreground_options" field.</summary>
    public const int ForegroundOptionsFieldNumber = 12;
    private global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions foregroundOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions ForegroundOptions {
      get { return foregroundOptions_; }
      set {
        foregroundOptions_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MotionAnalysisOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MotionAnalysisOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnalysisPolicy != other.AnalysisPolicy) return false;
      if (!object.Equals(FlowOptions, other.FlowOptions)) return false;
      if (!object.Equals(MotionOptions, other.MotionOptions)) return false;
      if (!object.Equals(SaliencyOptions, other.SaliencyOptions)) return false;
      if (EstimationClipSize != other.EstimationClipSize) return false;
      if (SubtractCameraMotionFromFeatures != other.SubtractCameraMotionFromFeatures) return false;
      if (TrackIndex != other.TrackIndex) return false;
      if (ComputeMotionSaliency != other.ComputeMotionSaliency) return false;
      if (SelectSaliencyInliers != other.SelectSaliencyInliers) return false;
      if (FilterSaliency != other.FilterSaliency) return false;
      if (PostIrlsSmoothing != other.PostIrlsSmoothing) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RejectionTransformThreshold, other.RejectionTransformThreshold)) return false;
      if (!object.Equals(VisualizationOptions, other.VisualizationOptions)) return false;
      if (!object.Equals(ForegroundOptions, other.ForegroundOptions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAnalysisPolicy) hash ^= AnalysisPolicy.GetHashCode();
      if (flowOptions_ != null) hash ^= FlowOptions.GetHashCode();
      if (motionOptions_ != null) hash ^= MotionOptions.GetHashCode();
      if (saliencyOptions_ != null) hash ^= SaliencyOptions.GetHashCode();
      if (HasEstimationClipSize) hash ^= EstimationClipSize.GetHashCode();
      if (HasSubtractCameraMotionFromFeatures) hash ^= SubtractCameraMotionFromFeatures.GetHashCode();
      if (HasTrackIndex) hash ^= TrackIndex.GetHashCode();
      if (HasComputeMotionSaliency) hash ^= ComputeMotionSaliency.GetHashCode();
      if (HasSelectSaliencyInliers) hash ^= SelectSaliencyInliers.GetHashCode();
      if (HasFilterSaliency) hash ^= FilterSaliency.GetHashCode();
      if (HasPostIrlsSmoothing) hash ^= PostIrlsSmoothing.GetHashCode();
      if (HasRejectionTransformThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RejectionTransformThreshold);
      if (visualizationOptions_ != null) hash ^= VisualizationOptions.GetHashCode();
      if (foregroundOptions_ != null) hash ^= ForegroundOptions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (flowOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FlowOptions);
      }
      if (motionOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(MotionOptions);
      }
      if (saliencyOptions_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SaliencyOptions);
      }
      if (HasEstimationClipSize) {
        output.WriteRawTag(32);
        output.WriteInt32(EstimationClipSize);
      }
      if (HasSubtractCameraMotionFromFeatures) {
        output.WriteRawTag(40);
        output.WriteBool(SubtractCameraMotionFromFeatures);
      }
      if (HasTrackIndex) {
        output.WriteRawTag(48);
        output.WriteInt32(TrackIndex);
      }
      if (HasComputeMotionSaliency) {
        output.WriteRawTag(56);
        output.WriteBool(ComputeMotionSaliency);
      }
      if (HasSelectSaliencyInliers) {
        output.WriteRawTag(64);
        output.WriteBool(SelectSaliencyInliers);
      }
      if (HasFilterSaliency) {
        output.WriteRawTag(72);
        output.WriteBool(FilterSaliency);
      }
      if (HasPostIrlsSmoothing) {
        output.WriteRawTag(80);
        output.WriteBool(PostIrlsSmoothing);
      }
      if (visualizationOptions_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(VisualizationOptions);
      }
      if (foregroundOptions_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(ForegroundOptions);
      }
      if (HasRejectionTransformThreshold) {
        output.WriteRawTag(109);
        output.WriteFloat(RejectionTransformThreshold);
      }
      if (HasAnalysisPolicy) {
        output.WriteRawTag(112);
        output.WriteEnum((int) AnalysisPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (flowOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FlowOptions);
      }
      if (motionOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(MotionOptions);
      }
      if (saliencyOptions_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SaliencyOptions);
      }
      if (HasEstimationClipSize) {
        output.WriteRawTag(32);
        output.WriteInt32(EstimationClipSize);
      }
      if (HasSubtractCameraMotionFromFeatures) {
        output.WriteRawTag(40);
        output.WriteBool(SubtractCameraMotionFromFeatures);
      }
      if (HasTrackIndex) {
        output.WriteRawTag(48);
        output.WriteInt32(TrackIndex);
      }
      if (HasComputeMotionSaliency) {
        output.WriteRawTag(56);
        output.WriteBool(ComputeMotionSaliency);
      }
      if (HasSelectSaliencyInliers) {
        output.WriteRawTag(64);
        output.WriteBool(SelectSaliencyInliers);
      }
      if (HasFilterSaliency) {
        output.WriteRawTag(72);
        output.WriteBool(FilterSaliency);
      }
      if (HasPostIrlsSmoothing) {
        output.WriteRawTag(80);
        output.WriteBool(PostIrlsSmoothing);
      }
      if (visualizationOptions_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(VisualizationOptions);
      }
      if (foregroundOptions_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(ForegroundOptions);
      }
      if (HasRejectionTransformThreshold) {
        output.WriteRawTag(109);
        output.WriteFloat(RejectionTransformThreshold);
      }
      if (HasAnalysisPolicy) {
        output.WriteRawTag(112);
        output.WriteEnum((int) AnalysisPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAnalysisPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AnalysisPolicy);
      }
      if (flowOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlowOptions);
      }
      if (motionOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MotionOptions);
      }
      if (saliencyOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SaliencyOptions);
      }
      if (HasEstimationClipSize) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EstimationClipSize);
      }
      if (HasSubtractCameraMotionFromFeatures) {
        size += 1 + 1;
      }
      if (HasTrackIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TrackIndex);
      }
      if (HasComputeMotionSaliency) {
        size += 1 + 1;
      }
      if (HasSelectSaliencyInliers) {
        size += 1 + 1;
      }
      if (HasFilterSaliency) {
        size += 1 + 1;
      }
      if (HasPostIrlsSmoothing) {
        size += 1 + 1;
      }
      if (HasRejectionTransformThreshold) {
        size += 1 + 4;
      }
      if (visualizationOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VisualizationOptions);
      }
      if (foregroundOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ForegroundOptions);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MotionAnalysisOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasAnalysisPolicy) {
        AnalysisPolicy = other.AnalysisPolicy;
      }
      if (other.flowOptions_ != null) {
        if (flowOptions_ == null) {
          FlowOptions = new global::Mediapipe.RegionFlowComputationOptions();
        }
        FlowOptions.MergeFrom(other.FlowOptions);
      }
      if (other.motionOptions_ != null) {
        if (motionOptions_ == null) {
          MotionOptions = new global::Mediapipe.MotionEstimationOptions();
        }
        MotionOptions.MergeFrom(other.MotionOptions);
      }
      if (other.saliencyOptions_ != null) {
        if (saliencyOptions_ == null) {
          SaliencyOptions = new global::Mediapipe.MotionSaliencyOptions();
        }
        SaliencyOptions.MergeFrom(other.SaliencyOptions);
      }
      if (other.HasEstimationClipSize) {
        EstimationClipSize = other.EstimationClipSize;
      }
      if (other.HasSubtractCameraMotionFromFeatures) {
        SubtractCameraMotionFromFeatures = other.SubtractCameraMotionFromFeatures;
      }
      if (other.HasTrackIndex) {
        TrackIndex = other.TrackIndex;
      }
      if (other.HasComputeMotionSaliency) {
        ComputeMotionSaliency = other.ComputeMotionSaliency;
      }
      if (other.HasSelectSaliencyInliers) {
        SelectSaliencyInliers = other.SelectSaliencyInliers;
      }
      if (other.HasFilterSaliency) {
        FilterSaliency = other.FilterSaliency;
      }
      if (other.HasPostIrlsSmoothing) {
        PostIrlsSmoothing = other.PostIrlsSmoothing;
      }
      if (other.HasRejectionTransformThreshold) {
        RejectionTransformThreshold = other.RejectionTransformThreshold;
      }
      if (other.visualizationOptions_ != null) {
        if (visualizationOptions_ == null) {
          VisualizationOptions = new global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions();
        }
        VisualizationOptions.MergeFrom(other.VisualizationOptions);
      }
      if (other.foregroundOptions_ != null) {
        if (foregroundOptions_ == null) {
          ForegroundOptions = new global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions();
        }
        ForegroundOptions.MergeFrom(other.ForegroundOptions);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (flowOptions_ == null) {
              FlowOptions = new global::Mediapipe.RegionFlowComputationOptions();
            }
            input.ReadMessage(FlowOptions);
            break;
          }
          case 18: {
            if (motionOptions_ == null) {
              MotionOptions = new global::Mediapipe.MotionEstimationOptions();
            }
            input.ReadMessage(MotionOptions);
            break;
          }
          case 26: {
            if (saliencyOptions_ == null) {
              SaliencyOptions = new global::Mediapipe.MotionSaliencyOptions();
            }
            input.ReadMessage(SaliencyOptions);
            break;
          }
          case 32: {
            EstimationClipSize = input.ReadInt32();
            break;
          }
          case 40: {
            SubtractCameraMotionFromFeatures = input.ReadBool();
            break;
          }
          case 48: {
            TrackIndex = input.ReadInt32();
            break;
          }
          case 56: {
            ComputeMotionSaliency = input.ReadBool();
            break;
          }
          case 64: {
            SelectSaliencyInliers = input.ReadBool();
            break;
          }
          case 72: {
            FilterSaliency = input.ReadBool();
            break;
          }
          case 80: {
            PostIrlsSmoothing = input.ReadBool();
            break;
          }
          case 90: {
            if (visualizationOptions_ == null) {
              VisualizationOptions = new global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions();
            }
            input.ReadMessage(VisualizationOptions);
            break;
          }
          case 98: {
            if (foregroundOptions_ == null) {
              ForegroundOptions = new global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions();
            }
            input.ReadMessage(ForegroundOptions);
            break;
          }
          case 109: {
            RejectionTransformThreshold = input.ReadFloat();
            break;
          }
          case 112: {
            AnalysisPolicy = (global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (flowOptions_ == null) {
              FlowOptions = new global::Mediapipe.RegionFlowComputationOptions();
            }
            input.ReadMessage(FlowOptions);
            break;
          }
          case 18: {
            if (motionOptions_ == null) {
              MotionOptions = new global::Mediapipe.MotionEstimationOptions();
            }
            input.ReadMessage(MotionOptions);
            break;
          }
          case 26: {
            if (saliencyOptions_ == null) {
              SaliencyOptions = new global::Mediapipe.MotionSaliencyOptions();
            }
            input.ReadMessage(SaliencyOptions);
            break;
          }
          case 32: {
            EstimationClipSize = input.ReadInt32();
            break;
          }
          case 40: {
            SubtractCameraMotionFromFeatures = input.ReadBool();
            break;
          }
          case 48: {
            TrackIndex = input.ReadInt32();
            break;
          }
          case 56: {
            ComputeMotionSaliency = input.ReadBool();
            break;
          }
          case 64: {
            SelectSaliencyInliers = input.ReadBool();
            break;
          }
          case 72: {
            FilterSaliency = input.ReadBool();
            break;
          }
          case 80: {
            PostIrlsSmoothing = input.ReadBool();
            break;
          }
          case 90: {
            if (visualizationOptions_ == null) {
              VisualizationOptions = new global::Mediapipe.MotionAnalysisOptions.Types.VisualizationOptions();
            }
            input.ReadMessage(VisualizationOptions);
            break;
          }
          case 98: {
            if (foregroundOptions_ == null) {
              ForegroundOptions = new global::Mediapipe.MotionAnalysisOptions.Types.ForegroundOptions();
            }
            input.ReadMessage(ForegroundOptions);
            break;
          }
          case 109: {
            RejectionTransformThreshold = input.ReadFloat();
            break;
          }
          case 112: {
            AnalysisPolicy = (global::Mediapipe.MotionAnalysisOptions.Types.AnalysisPolicy) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the MotionAnalysisOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Pre-configured policies for MotionAnalysis.
      /// For general use, it is recommended to select an appropiate policy
      /// instead of customizing flow and motion options by hand.
      /// Policies are being kept up to date with appropiate settings.
      /// </summary>
      public enum AnalysisPolicy {
        /// <summary>
        /// Default legacy options. Effectivley no op.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_POLICY_LEGACY")] Legacy = 0,
        /// <summary>
        /// Use for video.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_POLICY_VIDEO")] Video = 1,
        /// <summary>
        /// Use for video on mobile.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_POLICY_VIDEO_MOBILE")] VideoMobile = 2,
        /// <summary>
        /// Use if applied to camera stream on mobile, e.g.
        /// low latency and high throughput.
        /// ASSUMES DOWNSAMPLED INPUT, e.g. from GPU.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_POLICY_CAMERA_MOBILE")] CameraMobile = 3,
        /// <summary>
        /// Use for sped up video / hyperlapse when adding frames with seeds
        /// and rejection transforms. Mostly ups temporal consistency weights
        /// and relaxes stability constraints.
        /// Only recommended to be used as second pass after initial MotionAnalysis
        /// and FrameSelection.
        /// </summary>
        [pbr::OriginalName("ANALYSIS_POLICY_HYPERLAPSE")] Hyperlapse = 4,
      }

      /// <summary>
      /// Adapts visualization for rendered_results when passed to GetResults.
      /// </summary>
      public sealed partial class VisualizationOptions : pb::IMessage<VisualizationOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VisualizationOptions> _parser = new pb::MessageParser<VisualizationOptions>(() => new VisualizationOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VisualizationOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionAnalysisOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualizationOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualizationOptions(VisualizationOptions other) : this() {
          _hasBits0 = other._hasBits0;
          visualizeRegionFlowFeatures_ = other.visualizeRegionFlowFeatures_;
          visualizeSalientPoints_ = other.visualizeSalientPoints_;
          lineThickness_ = other.lineThickness_;
          foregroundJetColoring_ = other.foregroundJetColoring_;
          visualizeBlurAnalysisRegion_ = other.visualizeBlurAnalysisRegion_;
          visualizeStats_ = other.visualizeStats_;
          minLongFeatureTrack_ = other.minLongFeatureTrack_;
          maxLongFeaturePoints_ = other.maxLongFeaturePoints_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisualizationOptions Clone() {
          return new VisualizationOptions(this);
        }

        /// <summary>Field number for the "visualize_region_flow_features" field.</summary>
        public const int VisualizeRegionFlowFeaturesFieldNumber = 1;
        private readonly static bool VisualizeRegionFlowFeaturesDefaultValue = true;

        private bool visualizeRegionFlowFeatures_;
        /// <summary>
        /// Visualizes tracked region flow features, colored w.r.t. fitting error.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool VisualizeRegionFlowFeatures {
          get { if ((_hasBits0 & 1) != 0) { return visualizeRegionFlowFeatures_; } else { return VisualizeRegionFlowFeaturesDefaultValue; } }
          set {
            _hasBits0 |= 1;
            visualizeRegionFlowFeatures_ = value;
          }
        }
        /// <summary>Gets whether the "visualize_region_flow_features" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVisualizeRegionFlowFeatures {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "visualize_region_flow_features" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVisualizeRegionFlowFeatures() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "visualize_salient_points" field.</summary>
        public const int VisualizeSalientPointsFieldNumber = 2;
        private readonly static bool VisualizeSalientPointsDefaultValue = false;

        private bool visualizeSalientPoints_;
        /// <summary>
        /// Visualizes salient points. Only applicable is compute_motion_saliency is
        /// set to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool VisualizeSalientPoints {
          get { if ((_hasBits0 & 2) != 0) { return visualizeSalientPoints_; } else { return VisualizeSalientPointsDefaultValue; } }
          set {
            _hasBits0 |= 2;
            visualizeSalientPoints_ = value;
          }
        }
        /// <summary>Gets whether the "visualize_salient_points" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVisualizeSalientPoints {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "visualize_salient_points" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVisualizeSalientPoints() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "line_thickness" field.</summary>
        public const int LineThicknessFieldNumber = 5;
        private readonly static int LineThicknessDefaultValue = 4;

        private int lineThickness_;
        /// <summary>
        /// Line thickness of ellipse when rendering salient points.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int LineThickness {
          get { if ((_hasBits0 & 16) != 0) { return lineThickness_; } else { return LineThicknessDefaultValue; } }
          set {
            _hasBits0 |= 16;
            lineThickness_ = value;
          }
        }
        /// <summary>Gets whether the "line_thickness" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLineThickness {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "line_thickness" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLineThickness() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "foreground_jet_coloring" field.</summary>
        public const int ForegroundJetColoringFieldNumber = 3;
        private readonly static bool ForegroundJetColoringDefaultValue = false;

        private bool foregroundJetColoring_;
        /// <summary>
        /// Instead of green burn in uses jet coloring to indicate magnitude of
        /// foreground motion.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ForegroundJetColoring {
          get { if ((_hasBits0 & 4) != 0) { return foregroundJetColoring_; } else { return ForegroundJetColoringDefaultValue; } }
          set {
            _hasBits0 |= 4;
            foregroundJetColoring_ = value;
          }
        }
        /// <summary>Gets whether the "foreground_jet_coloring" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasForegroundJetColoring {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "foreground_jet_coloring" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearForegroundJetColoring() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "visualize_blur_analysis_region" field.</summary>
        public const int VisualizeBlurAnalysisRegionFieldNumber = 4;
        private readonly static bool VisualizeBlurAnalysisRegionDefaultValue = false;

        private bool visualizeBlurAnalysisRegion_;
        /// <summary>
        /// If set, only keeps masks of pixels that is used for blur analysis, rest
        /// is set to zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool VisualizeBlurAnalysisRegion {
          get { if ((_hasBits0 & 8) != 0) { return visualizeBlurAnalysisRegion_; } else { return VisualizeBlurAnalysisRegionDefaultValue; } }
          set {
            _hasBits0 |= 8;
            visualizeBlurAnalysisRegion_ = value;
          }
        }
        /// <summary>Gets whether the "visualize_blur_analysis_region" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVisualizeBlurAnalysisRegion {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "visualize_blur_analysis_region" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVisualizeBlurAnalysisRegion() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "visualize_stats" field.</summary>
        public const int VisualizeStatsFieldNumber = 6;
        private readonly static bool VisualizeStatsDefaultValue = true;

        private bool visualizeStats_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool VisualizeStats {
          get { if ((_hasBits0 & 32) != 0) { return visualizeStats_; } else { return VisualizeStatsDefaultValue; } }
          set {
            _hasBits0 |= 32;
            visualizeStats_ = value;
          }
        }
        /// <summary>Gets whether the "visualize_stats" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVisualizeStats {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "visualize_stats" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVisualizeStats() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "min_long_feature_track" field.</summary>
        public const int MinLongFeatureTrackFieldNumber = 7;
        private readonly static int MinLongFeatureTrackDefaultValue = 0;

        private int minLongFeatureTrack_;
        /// <summary>
        /// Only long feature tracks with specified minimum length are rendered.
        /// Set to zero to consider all tracks.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MinLongFeatureTrack {
          get { if ((_hasBits0 & 64) != 0) { return minLongFeatureTrack_; } else { return MinLongFeatureTrackDefaultValue; } }
          set {
            _hasBits0 |= 64;
            minLongFeatureTrack_ = value;
          }
        }
        /// <summary>Gets whether the "min_long_feature_track" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinLongFeatureTrack {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "min_long_feature_track" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinLongFeatureTrack() {
          _hasBits0 &= ~64;
        }

        /// <summary>Field number for the "max_long_feature_points" field.</summary>
        public const int MaxLongFeaturePointsFieldNumber = 8;
        private readonly static int MaxLongFeaturePointsDefaultValue = 0;

        private int maxLongFeaturePoints_;
        /// <summary>
        /// Only the last N points of a long feature track are rendered. Set to zero
        /// to render all points.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MaxLongFeaturePoints {
          get { if ((_hasBits0 & 128) != 0) { return maxLongFeaturePoints_; } else { return MaxLongFeaturePointsDefaultValue; } }
          set {
            _hasBits0 |= 128;
            maxLongFeaturePoints_ = value;
          }
        }
        /// <summary>Gets whether the "max_long_feature_points" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxLongFeaturePoints {
          get { return (_hasBits0 & 128) != 0; }
        }
        /// <summary>Clears the value of the "max_long_feature_points" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxLongFeaturePoints() {
          _hasBits0 &= ~128;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VisualizationOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VisualizationOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (VisualizeRegionFlowFeatures != other.VisualizeRegionFlowFeatures) return false;
          if (VisualizeSalientPoints != other.VisualizeSalientPoints) return false;
          if (LineThickness != other.LineThickness) return false;
          if (ForegroundJetColoring != other.ForegroundJetColoring) return false;
          if (VisualizeBlurAnalysisRegion != other.VisualizeBlurAnalysisRegion) return false;
          if (VisualizeStats != other.VisualizeStats) return false;
          if (MinLongFeatureTrack != other.MinLongFeatureTrack) return false;
          if (MaxLongFeaturePoints != other.MaxLongFeaturePoints) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasVisualizeRegionFlowFeatures) hash ^= VisualizeRegionFlowFeatures.GetHashCode();
          if (HasVisualizeSalientPoints) hash ^= VisualizeSalientPoints.GetHashCode();
          if (HasLineThickness) hash ^= LineThickness.GetHashCode();
          if (HasForegroundJetColoring) hash ^= ForegroundJetColoring.GetHashCode();
          if (HasVisualizeBlurAnalysisRegion) hash ^= VisualizeBlurAnalysisRegion.GetHashCode();
          if (HasVisualizeStats) hash ^= VisualizeStats.GetHashCode();
          if (HasMinLongFeatureTrack) hash ^= MinLongFeatureTrack.GetHashCode();
          if (HasMaxLongFeaturePoints) hash ^= MaxLongFeaturePoints.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasVisualizeRegionFlowFeatures) {
            output.WriteRawTag(8);
            output.WriteBool(VisualizeRegionFlowFeatures);
          }
          if (HasVisualizeSalientPoints) {
            output.WriteRawTag(16);
            output.WriteBool(VisualizeSalientPoints);
          }
          if (HasForegroundJetColoring) {
            output.WriteRawTag(24);
            output.WriteBool(ForegroundJetColoring);
          }
          if (HasVisualizeBlurAnalysisRegion) {
            output.WriteRawTag(32);
            output.WriteBool(VisualizeBlurAnalysisRegion);
          }
          if (HasLineThickness) {
            output.WriteRawTag(40);
            output.WriteInt32(LineThickness);
          }
          if (HasVisualizeStats) {
            output.WriteRawTag(48);
            output.WriteBool(VisualizeStats);
          }
          if (HasMinLongFeatureTrack) {
            output.WriteRawTag(56);
            output.WriteInt32(MinLongFeatureTrack);
          }
          if (HasMaxLongFeaturePoints) {
            output.WriteRawTag(64);
            output.WriteInt32(MaxLongFeaturePoints);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasVisualizeRegionFlowFeatures) {
            output.WriteRawTag(8);
            output.WriteBool(VisualizeRegionFlowFeatures);
          }
          if (HasVisualizeSalientPoints) {
            output.WriteRawTag(16);
            output.WriteBool(VisualizeSalientPoints);
          }
          if (HasForegroundJetColoring) {
            output.WriteRawTag(24);
            output.WriteBool(ForegroundJetColoring);
          }
          if (HasVisualizeBlurAnalysisRegion) {
            output.WriteRawTag(32);
            output.WriteBool(VisualizeBlurAnalysisRegion);
          }
          if (HasLineThickness) {
            output.WriteRawTag(40);
            output.WriteInt32(LineThickness);
          }
          if (HasVisualizeStats) {
            output.WriteRawTag(48);
            output.WriteBool(VisualizeStats);
          }
          if (HasMinLongFeatureTrack) {
            output.WriteRawTag(56);
            output.WriteInt32(MinLongFeatureTrack);
          }
          if (HasMaxLongFeaturePoints) {
            output.WriteRawTag(64);
            output.WriteInt32(MaxLongFeaturePoints);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasVisualizeRegionFlowFeatures) {
            size += 1 + 1;
          }
          if (HasVisualizeSalientPoints) {
            size += 1 + 1;
          }
          if (HasLineThickness) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(LineThickness);
          }
          if (HasForegroundJetColoring) {
            size += 1 + 1;
          }
          if (HasVisualizeBlurAnalysisRegion) {
            size += 1 + 1;
          }
          if (HasVisualizeStats) {
            size += 1 + 1;
          }
          if (HasMinLongFeatureTrack) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinLongFeatureTrack);
          }
          if (HasMaxLongFeaturePoints) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLongFeaturePoints);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VisualizationOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasVisualizeRegionFlowFeatures) {
            VisualizeRegionFlowFeatures = other.VisualizeRegionFlowFeatures;
          }
          if (other.HasVisualizeSalientPoints) {
            VisualizeSalientPoints = other.VisualizeSalientPoints;
          }
          if (other.HasLineThickness) {
            LineThickness = other.LineThickness;
          }
          if (other.HasForegroundJetColoring) {
            ForegroundJetColoring = other.ForegroundJetColoring;
          }
          if (other.HasVisualizeBlurAnalysisRegion) {
            VisualizeBlurAnalysisRegion = other.VisualizeBlurAnalysisRegion;
          }
          if (other.HasVisualizeStats) {
            VisualizeStats = other.VisualizeStats;
          }
          if (other.HasMinLongFeatureTrack) {
            MinLongFeatureTrack = other.MinLongFeatureTrack;
          }
          if (other.HasMaxLongFeaturePoints) {
            MaxLongFeaturePoints = other.MaxLongFeaturePoints;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                VisualizeRegionFlowFeatures = input.ReadBool();
                break;
              }
              case 16: {
                VisualizeSalientPoints = input.ReadBool();
                break;
              }
              case 24: {
                ForegroundJetColoring = input.ReadBool();
                break;
              }
              case 32: {
                VisualizeBlurAnalysisRegion = input.ReadBool();
                break;
              }
              case 40: {
                LineThickness = input.ReadInt32();
                break;
              }
              case 48: {
                VisualizeStats = input.ReadBool();
                break;
              }
              case 56: {
                MinLongFeatureTrack = input.ReadInt32();
                break;
              }
              case 64: {
                MaxLongFeaturePoints = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                VisualizeRegionFlowFeatures = input.ReadBool();
                break;
              }
              case 16: {
                VisualizeSalientPoints = input.ReadBool();
                break;
              }
              case 24: {
                ForegroundJetColoring = input.ReadBool();
                break;
              }
              case 32: {
                VisualizeBlurAnalysisRegion = input.ReadBool();
                break;
              }
              case 40: {
                LineThickness = input.ReadInt32();
                break;
              }
              case 48: {
                VisualizeStats = input.ReadBool();
                break;
              }
              case 56: {
                MinLongFeatureTrack = input.ReadInt32();
                break;
              }
              case 64: {
                MaxLongFeaturePoints = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Describes how to compute foreground from features.
      /// </summary>
      public sealed partial class ForegroundOptions : pb::IMessage<ForegroundOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ForegroundOptions> _parser = new pb::MessageParser<ForegroundOptions>(() => new ForegroundOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ForegroundOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionAnalysisOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ForegroundOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ForegroundOptions(ForegroundOptions other) : this() {
          _hasBits0 = other._hasBits0;
          foregroundThreshold_ = other.foregroundThreshold_;
          foregroundGamma_ = other.foregroundGamma_;
          thresholdCoverageScaling_ = other.thresholdCoverageScaling_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ForegroundOptions Clone() {
          return new ForegroundOptions(this);
        }

        /// <summary>Field number for the "foreground_threshold" field.</summary>
        public const int ForegroundThresholdFieldNumber = 1;
        private readonly static float ForegroundThresholdDefaultValue = 0.5F;

        private float foregroundThreshold_;
        /// <summary>
        /// Indicates the *inverse* registration error (i.e. the irls weight)
        /// that is deemed a complete inlier.
        /// Weights in the interval [0, foreground_threshold] (corresponding to
        /// pixel errors in the interval [1 / foreground_threshold, inf])
        /// are mappend to 1 - [0, 1], i.e. foreground threshold is mapped to zero
        /// with weights below the threshold being assigned values > 0.
        /// Therefore, larger values will increase amount of detected foreground
        /// as well as noise.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float ForegroundThreshold {
          get { if ((_hasBits0 & 1) != 0) { return foregroundThreshold_; } else { return ForegroundThresholdDefaultValue; } }
          set {
            _hasBits0 |= 1;
            foregroundThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "foreground_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasForegroundThreshold {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "foreground_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearForegroundThreshold() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "foreground_gamma" field.</summary>
        public const int ForegroundGammaFieldNumber = 2;
        private readonly static float ForegroundGammaDefaultValue = 1F;

        private float foregroundGamma_;
        /// <summary>
        /// By using foreground_gamma &lt; 1.0 you can increase resolution of small
        /// foreground motion at the expense of the resolution of large foreground
        /// motions.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float ForegroundGamma {
          get { if ((_hasBits0 & 2) != 0) { return foregroundGamma_; } else { return ForegroundGammaDefaultValue; } }
          set {
            _hasBits0 |= 2;
            foregroundGamma_ = value;
          }
        }
        /// <summary>Gets whether the "foreground_gamma" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasForegroundGamma {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "foreground_gamma" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearForegroundGamma() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "threshold_coverage_scaling" field.</summary>
        public const int ThresholdCoverageScalingFieldNumber = 3;
        private readonly static bool ThresholdCoverageScalingDefaultValue = true;

        private bool thresholdCoverageScaling_;
        /// <summary>
        /// Threshold is scaled by coverage, i.e. for frames with large registration
        /// error less forground is visualized.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ThresholdCoverageScaling {
          get { if ((_hasBits0 & 4) != 0) { return thresholdCoverageScaling_; } else { return ThresholdCoverageScalingDefaultValue; } }
          set {
            _hasBits0 |= 4;
            thresholdCoverageScaling_ = value;
          }
        }
        /// <summary>Gets whether the "threshold_coverage_scaling" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasThresholdCoverageScaling {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "threshold_coverage_scaling" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearThresholdCoverageScaling() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ForegroundOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ForegroundOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ForegroundThreshold, other.ForegroundThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ForegroundGamma, other.ForegroundGamma)) return false;
          if (ThresholdCoverageScaling != other.ThresholdCoverageScaling) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasForegroundThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ForegroundThreshold);
          if (HasForegroundGamma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ForegroundGamma);
          if (HasThresholdCoverageScaling) hash ^= ThresholdCoverageScaling.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasForegroundThreshold) {
            output.WriteRawTag(13);
            output.WriteFloat(ForegroundThreshold);
          }
          if (HasForegroundGamma) {
            output.WriteRawTag(21);
            output.WriteFloat(ForegroundGamma);
          }
          if (HasThresholdCoverageScaling) {
            output.WriteRawTag(24);
            output.WriteBool(ThresholdCoverageScaling);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasForegroundThreshold) {
            output.WriteRawTag(13);
            output.WriteFloat(ForegroundThreshold);
          }
          if (HasForegroundGamma) {
            output.WriteRawTag(21);
            output.WriteFloat(ForegroundGamma);
          }
          if (HasThresholdCoverageScaling) {
            output.WriteRawTag(24);
            output.WriteBool(ThresholdCoverageScaling);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasForegroundThreshold) {
            size += 1 + 4;
          }
          if (HasForegroundGamma) {
            size += 1 + 4;
          }
          if (HasThresholdCoverageScaling) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ForegroundOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasForegroundThreshold) {
            ForegroundThreshold = other.ForegroundThreshold;
          }
          if (other.HasForegroundGamma) {
            ForegroundGamma = other.ForegroundGamma;
          }
          if (other.HasThresholdCoverageScaling) {
            ThresholdCoverageScaling = other.ThresholdCoverageScaling;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                ForegroundThreshold = input.ReadFloat();
                break;
              }
              case 21: {
                ForegroundGamma = input.ReadFloat();
                break;
              }
              case 24: {
                ThresholdCoverageScaling = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                ForegroundThreshold = input.ReadFloat();
                break;
              }
              case 21: {
                ForegroundGamma = input.ReadFloat();
                break;
              }
              case 24: {
                ThresholdCoverageScaling = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

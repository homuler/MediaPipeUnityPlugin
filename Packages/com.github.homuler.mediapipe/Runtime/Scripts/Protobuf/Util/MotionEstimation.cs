// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/util/tracking/motion_estimation.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/util/tracking/motion_estimation.proto</summary>
  public static partial class MotionEstimationReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/util/tracking/motion_estimation.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MotionEstimationReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci9tZWRpYXBpcGUvdXRpbC90cmFja2luZy9tb3Rpb25fZXN0aW1hdGlvbi5w",
            "cm90bxIJbWVkaWFwaXBlIrc1ChdNb3Rpb25Fc3RpbWF0aW9uT3B0aW9ucxIn",
            "Chllc3RpbWF0ZV90cmFuc2xhdGlvbl9pcmxzGAEgASgIOgR0cnVlEncKHGxp",
            "bmVhcl9zaW1pbGFyaXR5X2VzdGltYXRpb24YAyABKA4yPS5tZWRpYXBpcGUu",
            "TW90aW9uRXN0aW1hdGlvbk9wdGlvbnMuTGluZWFyU2ltaWxhcml0eUVzdGlt",
            "YXRpb246EkVTVElNQVRJT05fTFNfSVJMUxJmChFhZmZpbmVfZXN0aW1hdGlv",
            "bhgeIAEoDjIzLm1lZGlhcGlwZS5Nb3Rpb25Fc3RpbWF0aW9uT3B0aW9ucy5B",
            "ZmZpbmVFc3RpbWF0aW9uOhZFU1RJTUFUSU9OX0FGRklORV9OT05FEm0KFWhv",
            "bW9ncmFwaHlfZXN0aW1hdGlvbhgFIAEoDjI3Lm1lZGlhcGlwZS5Nb3Rpb25F",
            "c3RpbWF0aW9uT3B0aW9ucy5Ib21vZ3JhcGh5RXN0aW1hdGlvbjoVRVNUSU1B",
            "VElPTl9IT01PR19JUkxTEjMKJGhvbW9ncmFwaHlfZXhhY3RfZGVub21pbmF0",
            "b3Jfc2NhbGluZxg1IAEoCDoFZmFsc2USLQofdXNlX2V4YWN0X2hvbW9ncmFw",
            "aHlfZXN0aW1hdGlvbhg2IAEoCDoEdHJ1ZRI3Cil1c2VfaGlnaGVzdF9hY2N1",
            "cmFjeV9mb3Jfbm9ybWFsX2VxdWF0aW9ucxg3IAEoCDoEdHJ1ZRItCiJob21v",
            "Z3JhcGh5X3BlcnNwZWN0aXZlX3JlZ3VsYXJpemVyGD0gASgCOgEwEnwKGW1p",
            "eF9ob21vZ3JhcGh5X2VzdGltYXRpb24YDCABKA4yPi5tZWRpYXBpcGUuTW90",
            "aW9uRXN0aW1hdGlvbk9wdGlvbnMuTWl4dHVyZUhvbW9ncmFwaHlFc3RpbWF0",
            "aW9uOhlFU1RJTUFUSU9OX0hPTU9HX01JWF9OT05FEhgKDG51bV9taXh0dXJl",
            "cxgNIAEoBToCMTASHgoRbWl4dHVyZV9yb3dfc2lnbWEYDiABKAI6AzAuMRIj",
            "ChNtaXh0dXJlX3JlZ3VsYXJpemVyGA8gASgCOgYwLjAwMDESJQoabWl4dHVy",
            "ZV9yZWd1bGFyaXplcl9sZXZlbHMYKiABKAI6ATMSJQoYbWl4dHVyZV9yZWd1",
            "bGFyaXplcl9iYXNlGCsgASgCOgMyLjISJAoZbWl4dHVyZV9yc19hbmFseXNp",
            "c19sZXZlbBgsIAEoBToBMhIXCgtpcmxzX3JvdW5kcxgRIAEoBToCMTASHQoQ",
            "aXJsc19wcmlvcl9zY2FsZRgyIAEoAjoDMC4yEiwKHmlybHNfbW90aW9uX21h",
            "Z25pdHVkZV9mcmFjdGlvbhgfIAEoAjoEMC4wOBIoChtpcmxzX21peHR1cmVf",
            "ZnJhY3Rpb25fc2NhbGUYRCABKAI6AzEuNRIqChtpcmxzX3dlaWdodHNfcHJl",
            "aW5pdGlhbGl6ZWQYJyABKAg6BWZhbHNlEi4KH2ZpbHRlcl9pbml0aWFsaXpl",
            "ZF9pcmxzX3dlaWdodHMYQyABKAg6BWZhbHNlElkKE2lybHNfaW5pdGlhbGl6",
            "YXRpb24YOCABKAsyPC5tZWRpYXBpcGUuTW90aW9uRXN0aW1hdGlvbk9wdGlv",
            "bnMuSXJsc091dGxpZXJJbml0aWFsaXphdGlvbhIsCh1mZWF0dXJlX2RlbnNp",
            "dHlfbm9ybWFsaXphdGlvbhg+IAEoCDoFZmFsc2USHQoRZmVhdHVyZV9tYXNr",
            "X3NpemUYPyABKAU6AjEwEmEKG2xvbmdfZmVhdHVyZV9pbml0aWFsaXphdGlv",
            "bhhCIAEoCzI8Lm1lZGlhcGlwZS5Nb3Rpb25Fc3RpbWF0aW9uT3B0aW9ucy5M",
            "b25nRmVhdHVyZUluaXRpYWxpemF0aW9uEk0KEWlybHNfbWFza19vcHRpb25z",
            "GDkgASgLMjIubWVkaWFwaXBlLk1vdGlvbkVzdGltYXRpb25PcHRpb25zLkly",
            "bHNNYXNrT3B0aW9ucxJeChZqb2ludF90cmFja19lc3RpbWF0aW9uGDsgASgL",
            "Mj4ubWVkaWFwaXBlLk1vdGlvbkVzdGltYXRpb25PcHRpb25zLkpvaW50VHJh",
            "Y2tFc3RpbWF0aW9uT3B0aW9ucxJcChlsb25nX2ZlYXR1cmVfYmlhc19vcHRp",
            "b25zGEAgASgLMjkubWVkaWFwaXBlLk1vdGlvbkVzdGltYXRpb25PcHRpb25z",
            "LkxvbmdGZWF0dXJlQmlhc09wdGlvbnMSZAoRZXN0aW1hdGlvbl9wb2xpY3kY",
            "OiABKA4yMy5tZWRpYXBpcGUuTW90aW9uRXN0aW1hdGlvbk9wdGlvbnMuRXN0",
            "aW1hdGlvblBvbGljeToUSU5ERVBFTkRFTlRfUEFSQUxMRUwSHgoSY292ZXJh",
            "Z2VfZ3JpZF9zaXplGDMgASgFOgIxMBJmChJtaXh0dXJlX21vZGVsX21vZGUY",
            "FyABKA4yMy5tZWRpYXBpcGUuTW90aW9uRXN0aW1hdGlvbk9wdGlvbnMuTWl4",
            "dHVyZU1vZGVsTW9kZToVU0tFV19ST1RBVElPTl9NSVhUVVJFEjUKJ3VzZV9v",
            "bmx5X2xpbl9zaW1faW5saWVyc19mb3JfaG9tb2dyYXBoeRgGIAEoCDoEdHJ1",
            "ZRInChhsaW5fc2ltX2lubGllcl90aHJlc2hvbGQYFCABKAI6BTAuMDAzElcK",
            "GXN0YWJsZV90cmFuc2xhdGlvbl9ib3VuZHMYICABKAsyNC5tZWRpYXBpcGUu",
            "TW90aW9uRXN0aW1hdGlvbk9wdGlvbnMuVHJhbnNsYXRpb25Cb3VuZHMSVQoY",
            "c3RhYmxlX3NpbWlsYXJpdHlfYm91bmRzGCEgASgLMjMubWVkaWFwaXBlLk1v",
            "dGlvbkVzdGltYXRpb25PcHRpb25zLlNpbWlsYXJpdHlCb3VuZHMSVQoYc3Rh",
            "YmxlX2hvbW9ncmFwaHlfYm91bmRzGAsgASgLMjMubWVkaWFwaXBlLk1vdGlv",
            "bkVzdGltYXRpb25PcHRpb25zLkhvbW9ncmFwaHlCb3VuZHMSZAogc3RhYmxl",
            "X21peHR1cmVfaG9tb2dyYXBoeV9ib3VuZHMYIiABKAsyOi5tZWRpYXBpcGUu",
            "TW90aW9uRXN0aW1hdGlvbk9wdGlvbnMuTWl4dHVyZUhvbW9ncmFwaHlCb3Vu",
            "ZHMSJAoVc3RyaWN0X2NvdmVyYWdlX3NjYWxlGCkgASgCOgUxLjMzMxIpChts",
            "YWJlbF9lbXB0eV9mcmFtZXNfYXNfdmFsaWQYFiABKAg6BHRydWUSHwoRZmVh",
            "dHVyZV9ncmlkX3NpemUYGCABKAI6BDAuMDUSGwoNc3BhdGlhbF9zaWdtYRgZ",
            "IAEoAjoEMC4wMRIiChZ0ZW1wb3JhbF9pcmxzX2RpYW1ldGVyGBogASgFOgIy",
            "MBIZCg50ZW1wb3JhbF9zaWdtYRgbIAEoAjoBNRIZCg1mZWF0dXJlX3NpZ21h",
            "GBwgASgCOgIzMBIcCg1maWx0ZXJfNV90YXBzGB0gASgIOgVmYWxzZRIoChpm",
            "cmFtZV9jb25maWRlbmNlX3dlaWdodGluZxgwIAEoCDoEdHJ1ZRInChpyZXNl",
            "dF9jb25maWRlbmNlX3RocmVzaG9sZBgxIAEoAjoDMC40EmEKEmlybHNfd2Vp",
            "Z2h0X2ZpbHRlchgjIAEoDjIzLm1lZGlhcGlwZS5Nb3Rpb25Fc3RpbWF0aW9u",
            "T3B0aW9ucy5JUkxTV2VpZ2h0RmlsdGVyOhBJUkxTX0ZJTFRFUl9OT05FEiAK",
            "EW92ZXJsYXlfZGV0ZWN0aW9uGCQgASgIOgVmYWxzZRImChtvdmVybGF5X2Fu",
            "YWx5c2lzX2NodW5rX3NpemUYJSABKAU6ATgSXQoZb3ZlcmxheV9kZXRlY3Rp",
            "b25fb3B0aW9ucxgmIAEoCzI6Lm1lZGlhcGlwZS5Nb3Rpb25Fc3RpbWF0aW9u",
            "T3B0aW9ucy5PdmVybGF5RGV0ZWN0aW9uT3B0aW9ucxJVChVzaG90X2JvdW5k",
            "YXJ5X29wdGlvbnMYPCABKAsyNi5tZWRpYXBpcGUuTW90aW9uRXN0aW1hdGlv",
            "bk9wdGlvbnMuU2hvdEJvdW5kYXJ5T3B0aW9ucxIpChtvdXRwdXRfcmVmaW5l",
            "ZF9pcmxzX3dlaWdodHMYKCABKAg6BHRydWUSlAEKJWhvbW9ncmFwaHlfaXJs",
            "c193ZWlnaHRfaW5pdGlhbGl6YXRpb24YLSABKA4yRS5tZWRpYXBpcGUuTW90",
            "aW9uRXN0aW1hdGlvbk9wdGlvbnMuSG9tb2dyYXBoeUlybHNXZWlnaHRJbml0",
            "aWFsaXphdGlvbjoeSVJMU19XRUlHSFRfUEVSSU1FVEVSX0dBVVNTSUFOEh4K",
            "EGlybHNfdXNlX2wwX25vcm0YLiABKAg6BHRydWUSKgobZG9tYWluX2xpbWl0",
            "ZWRfaXJsc19zY2FsaW5nGEEgASgIOgVmYWxzZRIyCiNkZWFjdGl2YXRlX3N0",
            "YWJsZV9tb3Rpb25fZXN0aW1hdGlvbhgvIAEoCDoFZmFsc2USKQoacHJvamVj",
            "dF92YWxpZF9tb3Rpb25zX2Rvd24YNCABKAg6BWZhbHNlEh8KE2VzdGltYXRl",
            "X3NpbWlsYXJpdHkYAiABKAhCAhgBGmEKGUlybHNPdXRsaWVySW5pdGlhbGl6",
            "YXRpb24SGAoJYWN0aXZhdGVkGAEgASgIOgVmYWxzZRITCgZyb3VuZHMYAiAB",
            "KAU6AzEwMBIVCgZjdXRvZmYYAyABKAI6BTAuMDAzGnoKGUxvbmdGZWF0dXJl",
            "SW5pdGlhbGl6YXRpb24SGAoJYWN0aXZhdGVkGAEgASgIOgVmYWxzZRIjChVt",
            "aW5fbGVuZ3RoX3BlcmNlbnRpbGUYAiABKAI6BDAuOTUSHgoTdXB3ZWlnaHRf",
            "bXVsdGlwbGllchgDIAEoAjoBNRrTAQoPSXJsc01hc2tPcHRpb25zEhIKBWRl",
            "Y2F5GAIgASgCOgMwLjcSGQoMaW5saWVyX3Njb3JlGAMgASgCOgMwLjQSFwoK",
            "YmFzZV9zY29yZRgEIAEoAjoDMC4yEiMKFG1pbl90cmFuc2xhdGlvbl9ub3Jt",
            "GAUgASgCOgUwLjAwMhIkChd0cmFuc2xhdGlvbl9ibGVuZF9hbHBoYRgGIAEo",
            "AjoDMC43EicKGnRyYW5zbGF0aW9uX3ByaW9yX2luY3JlYXNlGAcgASgCOgMw",
            "LjIqBAgBEAIaeQobSm9pbnRUcmFja0VzdGltYXRpb25PcHRpb25zEhwKEW51",
            "bV9tb3Rpb25fbW9kZWxzGAEgASgFOgEzEhkKDW1vdGlvbl9zdHJpZGUYAiAB",
            "KAU6AjE1EiEKEnRlbXBvcmFsX3Ntb290aGluZxgDIAEoCDoFZmFsc2UaygMK",
            "FkxvbmdGZWF0dXJlQmlhc09wdGlvbnMSFwoMdG90YWxfcm91bmRzGA0gASgF",
            "OgExEhkKC2lubGllcl9iaWFzGAEgASgCOgQwLjk4EhkKDG91dGxpZXJfYmlh",
            "cxgCIAEoAjoDMC43EiEKFW51bV9pcmxzX29ic2VydmF0aW9ucxgDIAEoBToC",
            "MTASIQoVbWF4X2lybHNfY2hhbmdlX3JhdGlvGAQgASgCOgIxMBIfChJpbmxp",
            "ZXJfaXJsc193ZWlnaHQYBSABKAI6AzAuMhIVCgpiaWFzX3N0ZGV2GAwgASgC",
            "OgExEh4KEHVzZV9zcGF0aWFsX2JpYXMYBiABKAg6BHRydWUSFwoJZ3JpZF9z",
            "aXplGAcgASgCOgQwLjA0EhsKDXNwYXRpYWxfc2lnbWEYCCABKAI6BDAuMDIS",
            "FwoLY29sb3Jfc2lnbWEYCSABKAI6AjIwEiAKFGxvbmdfdHJhY2tfdGhyZXNo",
            "b2xkGAogASgFOgIzMBIsCh5sb25nX3RyYWNrX2NvbmZpZGVuY2VfZnJhY3Rp",
            "b24YCyABKAI6BDAuMjUSJAoVc2VlZF9wcmlvcnNfZnJvbV9iaWFzGA4gASgI",
            "OgVmYWxzZRq+AQoRVHJhbnNsYXRpb25Cb3VuZHMSFwoMbWluX2ZlYXR1cmVz",
            "GAEgASgFOgEzEicKGWZyYWNfbWF4X21vdGlvbl9tYWduaXR1ZGUYAiABKAI6",
            "BDAuMTUSKAoabWF4X21vdGlvbl9zdGRldl90aHJlc2hvbGQYBCABKAI6BDAu",
            "MDESHwoQbWF4X21vdGlvbl9zdGRldhgDIAEoAjoFMC4wNjUSHAoQbWF4X2Fj",
            "Y2VsZXJhdGlvbhgFIAEoAjoCMjAapgIKEFNpbWlsYXJpdHlCb3VuZHMSHwoR",
            "b25seV9zdGFibGVfaW5wdXQYASABKAg6BHRydWUSIAoTbWluX2lubGllcl9m",
            "cmFjdGlvbhgCIAEoAjoDMC4yEhcKC21pbl9pbmxpZXJzGAMgASgCOgIzMBIY",
            "Cgtsb3dlcl9zY2FsZRgEIAEoAjoDMC44EhkKC3VwcGVyX3NjYWxlGAUgASgC",
            "OgQxLjI1EhwKDmxpbWl0X3JvdGF0aW9uGAYgASgCOgQwLjI1EhsKEGlubGll",
            "cl90aHJlc2hvbGQYByABKAI6ATQSIAoVZnJhY19pbmxpZXJfdGhyZXNob2xk",
            "GAggASgCOgEwEiQKF3N0cmljdF9pbmxpZXJfdGhyZXNob2xkGAkgASgCOgMw",
            "LjUanQIKEEhvbW9ncmFwaHlCb3VuZHMSGAoLbG93ZXJfc2NhbGUYASABKAI6",
            "AzAuOBIZCgt1cHBlcl9zY2FsZRgCIAEoAjoEMS4yNRIcCg5saW1pdF9yb3Rh",
            "dGlvbhgDIAEoAjoEMC4yNRIhChFsaW1pdF9wZXJzcGVjdGl2ZRgEIAEoAjoG",
            "MC4wMDA0EiMKFnJlZ2lzdHJhdGlvbl90aHJlc2hvbGQYBSABKAI6AzAuMRIm",
            "ChtmcmFjX3JlZ2lzdHJhdGlvbl90aHJlc2hvbGQYCCABKAI6ATASIAoTbWlu",
            "X2lubGllcl9jb3ZlcmFnZRgGIAEoAjoDMC4zEiQKFWZyYWNfaW5saWVyX3Ro",
            "cmVzaG9sZBgHIAEoAjoFMC4wMDIasAEKF01peHR1cmVIb21vZ3JhcGh5Qm91",
            "bmRzEiAKE21pbl9pbmxpZXJfY292ZXJhZ2UYASABKAI6AzAuNBImChttYXhf",
            "YWRqYWNlbnRfb3V0bGllcl9ibG9ja3MYAiABKAU6ATUSJAoZbWF4X2FkamFj",
            "ZW50X2VtcHR5X2Jsb2NrcxgDIAEoBToBMxIlChVmcmFjX2lubGllcl90aHJl",
            "c2hvbGQYByABKAI6BjAuMDAyNRqVAgoXT3ZlcmxheURldGVjdGlvbk9wdGlv",
            "bnMSHgoSYW5hbHlzaXNfbWFza19zaXplGAEgASgFOgIxMBIkChdzdHJpY3Rf",
            "bmVhcl96ZXJvX21vdGlvbhgCIAEoAjoDMC4yEikKHHN0cmljdF9tYXhfdHJh",
            "bnNsYXRpb25fcmF0aW8YAyABKAI6AzAuMhIkChdzdHJpY3RfbWluX3RleHR1",
            "cmVkbmVzcxgFIAEoAjoDMC4xEiEKFmxvb3NlX25lYXJfemVyb19tb3Rpb24Y",
            "BCABKAI6ATESHgoRb3ZlcmxheV9taW5fcmF0aW8YBiABKAI6AzAuMxIgChRv",
            "dmVybGF5X21pbl9mZWF0dXJlcxgHIAEoAjoCMTAacgoTU2hvdEJvdW5kYXJ5",
            "T3B0aW9ucxIqChxtb3Rpb25fY29uc2lzdGVuY3lfdGhyZXNob2xkGAEgASgC",
            "OgQwLjAyEi8KIGFwcGVhcmFuY2VfY29uc2lzdGVuY3lfdGhyZXNob2xkGAIg",
            "ASgCOgUwLjA3NSKVAQoaTGluZWFyU2ltaWxhcml0eUVzdGltYXRpb24SFgoS",
            "RVNUSU1BVElPTl9MU19OT05FEAASFAoQRVNUSU1BVElPTl9MU19MMhABEhYK",
            "EkVTVElNQVRJT05fTFNfSVJMUxAEEhsKF0VTVElNQVRJT05fTFNfTDJfUkFO",
            "U0FDEAISFAoQRVNUSU1BVElPTl9MU19MMRADImQKEEFmZmluZUVzdGltYXRp",
            "b24SGgoWRVNUSU1BVElPTl9BRkZJTkVfTk9ORRAAEhgKFEVTVElNQVRJT05f",
            "QUZGSU5FX0wyEAESGgoWRVNUSU1BVElPTl9BRkZJTkVfSVJMUxACImUKFEhv",
            "bW9ncmFwaHlFc3RpbWF0aW9uEhkKFUVTVElNQVRJT05fSE9NT0dfTk9ORRAA",
            "EhcKE0VTVElNQVRJT05fSE9NT0dfTDIQARIZChVFU1RJTUFUSU9OX0hPTU9H",
            "X0lSTFMQAiJ4ChtNaXh0dXJlSG9tb2dyYXBoeUVzdGltYXRpb24SHQoZRVNU",
            "SU1BVElPTl9IT01PR19NSVhfTk9ORRAAEhsKF0VTVElNQVRJT05fSE9NT0df",
            "TUlYX0wyEAESHQoZRVNUSU1BVElPTl9IT01PR19NSVhfSVJMUxACIn0KEEVz",
            "dGltYXRpb25Qb2xpY3kSGAoUSU5ERVBFTkRFTlRfUEFSQUxMRUwQARIWChJU",
            "RU1QT1JBTF9JUkxTX01BU0sQAhIeChpURU1QT1JBTF9MT05HX0ZFQVRVUkVf",
            "QklBUxAEEhcKE0pPSU5UTFlfRlJPTV9UUkFDS1MQAyJYChBNaXh0dXJlTW9k",
            "ZWxNb2RlEhAKDEZVTExfTUlYVFVSRRAAEhcKE1RSQU5TTEFUSU9OX01JWFRV",
            "UkUQARIZChVTS0VXX1JPVEFUSU9OX01JWFRVUkUQAiJiChBJUkxTV2VpZ2h0",
            "RmlsdGVyEhQKEElSTFNfRklMVEVSX05PTkUQABIXChNJUkxTX0ZJTFRFUl9U",
            "RVhUVVJFEAESHwobSVJMU19GSUxURVJfQ09STkVSX1JFU1BPTlNFEAIihwEK",
            "IkhvbW9ncmFwaHlJcmxzV2VpZ2h0SW5pdGlhbGl6YXRpb24SHAoYSVJMU19X",
            "RUlHSFRfQ09OU1RBTlRfT05FEAESHwobSVJMU19XRUlHSFRfQ0VOVEVSX0dB",
            "VVNTSUFOEAISIgoeSVJMU19XRUlHSFRfUEVSSU1FVEVSX0dBVVNTSUFOEAMq",
            "BAgHEAgqBAgIEAkqBAgQEBE="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions), global::Mediapipe.MotionEstimationOptions.Parser, new[]{ "EstimateTranslationIrls", "LinearSimilarityEstimation", "AffineEstimation", "HomographyEstimation", "HomographyExactDenominatorScaling", "UseExactHomographyEstimation", "UseHighestAccuracyForNormalEquations", "HomographyPerspectiveRegularizer", "MixHomographyEstimation", "NumMixtures", "MixtureRowSigma", "MixtureRegularizer", "MixtureRegularizerLevels", "MixtureRegularizerBase", "MixtureRsAnalysisLevel", "IrlsRounds", "IrlsPriorScale", "IrlsMotionMagnitudeFraction", "IrlsMixtureFractionScale", "IrlsWeightsPreinitialized", "FilterInitializedIrlsWeights", "IrlsInitialization", "FeatureDensityNormalization", "FeatureMaskSize", "LongFeatureInitialization", "IrlsMaskOptions", "JointTrackEstimation", "LongFeatureBiasOptions", "EstimationPolicy", "CoverageGridSize", "MixtureModelMode", "UseOnlyLinSimInliersForHomography", "LinSimInlierThreshold", "StableTranslationBounds", "StableSimilarityBounds", "StableHomographyBounds", "StableMixtureHomographyBounds", "StrictCoverageScale", "LabelEmptyFramesAsValid", "FeatureGridSize", "SpatialSigma", "TemporalIrlsDiameter", "TemporalSigma", "FeatureSigma", "Filter5Taps", "FrameConfidenceWeighting", "ResetConfidenceThreshold", "IrlsWeightFilter", "OverlayDetection", "OverlayAnalysisChunkSize", "OverlayDetectionOptions", "ShotBoundaryOptions", "OutputRefinedIrlsWeights", "HomographyIrlsWeightInitialization", "IrlsUseL0Norm", "DomainLimitedIrlsScaling", "DeactivateStableMotionEstimation", "ProjectValidMotionsDown", "EstimateSimilarity" }, null, new[]{ typeof(global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation), typeof(global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation), typeof(global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation), typeof(global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation), typeof(global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy), typeof(global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode), typeof(global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter), typeof(global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization), global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization.Parser, new[]{ "Activated", "Rounds", "Cutoff" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization), global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization.Parser, new[]{ "Activated", "MinLengthPercentile", "UpweightMultiplier" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions), global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions.Parser, new[]{ "Decay", "InlierScore", "BaseScore", "MinTranslationNorm", "TranslationBlendAlpha", "TranslationPriorIncrease" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions), global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions.Parser, new[]{ "NumMotionModels", "MotionStride", "TemporalSmoothing" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions), global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions.Parser, new[]{ "TotalRounds", "InlierBias", "OutlierBias", "NumIrlsObservations", "MaxIrlsChangeRatio", "InlierIrlsWeight", "BiasStdev", "UseSpatialBias", "GridSize", "SpatialSigma", "ColorSigma", "LongTrackThreshold", "LongTrackConfidenceFraction", "SeedPriorsFromBias" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds), global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds.Parser, new[]{ "MinFeatures", "FracMaxMotionMagnitude", "MaxMotionStdevThreshold", "MaxMotionStdev", "MaxAcceleration" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds), global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds.Parser, new[]{ "OnlyStableInput", "MinInlierFraction", "MinInliers", "LowerScale", "UpperScale", "LimitRotation", "InlierThreshold", "FracInlierThreshold", "StrictInlierThreshold" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds), global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds.Parser, new[]{ "LowerScale", "UpperScale", "LimitRotation", "LimitPerspective", "RegistrationThreshold", "FracRegistrationThreshold", "MinInlierCoverage", "FracInlierThreshold" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds), global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds.Parser, new[]{ "MinInlierCoverage", "MaxAdjacentOutlierBlocks", "MaxAdjacentEmptyBlocks", "FracInlierThreshold" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions), global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions.Parser, new[]{ "AnalysisMaskSize", "StrictNearZeroMotion", "StrictMaxTranslationRatio", "StrictMinTexturedness", "LooseNearZeroMotion", "OverlayMinRatio", "OverlayMinFeatures" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions), global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions.Parser, new[]{ "MotionConsistencyThreshold", "AppearanceConsistencyThreshold" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Note: In general for Estimation modes, the prefix are used as follows:
  /// L2:        minimize squared norm of error
  /// IRLS:      iterative reweighted least square, L2 minimization using multiple
  ///            iterations, downweighting outliers.
  /// Next tag: 69
  /// </summary>
  public sealed partial class MotionEstimationOptions : pb::IExtendableMessage<MotionEstimationOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MotionEstimationOptions> _parser = new pb::MessageParser<MotionEstimationOptions>(() => new MotionEstimationOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<MotionEstimationOptions> _extensions;
    private pb::ExtensionSet<MotionEstimationOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    private int _hasBits1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MotionEstimationOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.MotionEstimationReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionEstimationOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionEstimationOptions(MotionEstimationOptions other) : this() {
      _hasBits0 = other._hasBits0;
      _hasBits1 = other._hasBits1;
      estimateTranslationIrls_ = other.estimateTranslationIrls_;
      linearSimilarityEstimation_ = other.linearSimilarityEstimation_;
      affineEstimation_ = other.affineEstimation_;
      homographyEstimation_ = other.homographyEstimation_;
      homographyExactDenominatorScaling_ = other.homographyExactDenominatorScaling_;
      useExactHomographyEstimation_ = other.useExactHomographyEstimation_;
      useHighestAccuracyForNormalEquations_ = other.useHighestAccuracyForNormalEquations_;
      homographyPerspectiveRegularizer_ = other.homographyPerspectiveRegularizer_;
      mixHomographyEstimation_ = other.mixHomographyEstimation_;
      numMixtures_ = other.numMixtures_;
      mixtureRowSigma_ = other.mixtureRowSigma_;
      mixtureRegularizer_ = other.mixtureRegularizer_;
      mixtureRegularizerLevels_ = other.mixtureRegularizerLevels_;
      mixtureRegularizerBase_ = other.mixtureRegularizerBase_;
      mixtureRsAnalysisLevel_ = other.mixtureRsAnalysisLevel_;
      irlsRounds_ = other.irlsRounds_;
      irlsPriorScale_ = other.irlsPriorScale_;
      irlsMotionMagnitudeFraction_ = other.irlsMotionMagnitudeFraction_;
      irlsMixtureFractionScale_ = other.irlsMixtureFractionScale_;
      irlsWeightsPreinitialized_ = other.irlsWeightsPreinitialized_;
      filterInitializedIrlsWeights_ = other.filterInitializedIrlsWeights_;
      irlsInitialization_ = other.irlsInitialization_ != null ? other.irlsInitialization_.Clone() : null;
      featureDensityNormalization_ = other.featureDensityNormalization_;
      featureMaskSize_ = other.featureMaskSize_;
      longFeatureInitialization_ = other.longFeatureInitialization_ != null ? other.longFeatureInitialization_.Clone() : null;
      irlsMaskOptions_ = other.irlsMaskOptions_ != null ? other.irlsMaskOptions_.Clone() : null;
      jointTrackEstimation_ = other.jointTrackEstimation_ != null ? other.jointTrackEstimation_.Clone() : null;
      longFeatureBiasOptions_ = other.longFeatureBiasOptions_ != null ? other.longFeatureBiasOptions_.Clone() : null;
      estimationPolicy_ = other.estimationPolicy_;
      coverageGridSize_ = other.coverageGridSize_;
      mixtureModelMode_ = other.mixtureModelMode_;
      useOnlyLinSimInliersForHomography_ = other.useOnlyLinSimInliersForHomography_;
      linSimInlierThreshold_ = other.linSimInlierThreshold_;
      stableTranslationBounds_ = other.stableTranslationBounds_ != null ? other.stableTranslationBounds_.Clone() : null;
      stableSimilarityBounds_ = other.stableSimilarityBounds_ != null ? other.stableSimilarityBounds_.Clone() : null;
      stableHomographyBounds_ = other.stableHomographyBounds_ != null ? other.stableHomographyBounds_.Clone() : null;
      stableMixtureHomographyBounds_ = other.stableMixtureHomographyBounds_ != null ? other.stableMixtureHomographyBounds_.Clone() : null;
      strictCoverageScale_ = other.strictCoverageScale_;
      labelEmptyFramesAsValid_ = other.labelEmptyFramesAsValid_;
      featureGridSize_ = other.featureGridSize_;
      spatialSigma_ = other.spatialSigma_;
      temporalIrlsDiameter_ = other.temporalIrlsDiameter_;
      temporalSigma_ = other.temporalSigma_;
      featureSigma_ = other.featureSigma_;
      filter5Taps_ = other.filter5Taps_;
      frameConfidenceWeighting_ = other.frameConfidenceWeighting_;
      resetConfidenceThreshold_ = other.resetConfidenceThreshold_;
      irlsWeightFilter_ = other.irlsWeightFilter_;
      overlayDetection_ = other.overlayDetection_;
      overlayAnalysisChunkSize_ = other.overlayAnalysisChunkSize_;
      overlayDetectionOptions_ = other.overlayDetectionOptions_ != null ? other.overlayDetectionOptions_.Clone() : null;
      shotBoundaryOptions_ = other.shotBoundaryOptions_ != null ? other.shotBoundaryOptions_.Clone() : null;
      outputRefinedIrlsWeights_ = other.outputRefinedIrlsWeights_;
      homographyIrlsWeightInitialization_ = other.homographyIrlsWeightInitialization_;
      irlsUseL0Norm_ = other.irlsUseL0Norm_;
      domainLimitedIrlsScaling_ = other.domainLimitedIrlsScaling_;
      deactivateStableMotionEstimation_ = other.deactivateStableMotionEstimation_;
      projectValidMotionsDown_ = other.projectValidMotionsDown_;
      estimateSimilarity_ = other.estimateSimilarity_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MotionEstimationOptions Clone() {
      return new MotionEstimationOptions(this);
    }

    /// <summary>Field number for the "estimate_translation_irls" field.</summary>
    public const int EstimateTranslationIrlsFieldNumber = 1;
    private readonly static bool EstimateTranslationIrlsDefaultValue = true;

    private bool estimateTranslationIrls_;
    /// <summary>
    /// Specifies which camera models should be estimated, translation is always
    /// estimated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EstimateTranslationIrls {
      get { if ((_hasBits0 & 1) != 0) { return estimateTranslationIrls_; } else { return EstimateTranslationIrlsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        estimateTranslationIrls_ = value;
      }
    }
    /// <summary>Gets whether the "estimate_translation_irls" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimateTranslationIrls {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "estimate_translation_irls" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimateTranslationIrls() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "linear_similarity_estimation" field.</summary>
    public const int LinearSimilarityEstimationFieldNumber = 3;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation LinearSimilarityEstimationDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation.EstimationLsIrls;

    private global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation linearSimilarityEstimation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation LinearSimilarityEstimation {
      get { if ((_hasBits0 & 4) != 0) { return linearSimilarityEstimation_; } else { return LinearSimilarityEstimationDefaultValue; } }
      set {
        _hasBits0 |= 4;
        linearSimilarityEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "linear_similarity_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLinearSimilarityEstimation {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "linear_similarity_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLinearSimilarityEstimation() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "affine_estimation" field.</summary>
    public const int AffineEstimationFieldNumber = 30;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation AffineEstimationDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation.EstimationAffineNone;

    private global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation affineEstimation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation AffineEstimation {
      get { if ((_hasBits0 & 524288) != 0) { return affineEstimation_; } else { return AffineEstimationDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        affineEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "affine_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAffineEstimation {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "affine_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAffineEstimation() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "homography_estimation" field.</summary>
    public const int HomographyEstimationFieldNumber = 5;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation HomographyEstimationDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation.EstimationHomogIrls;

    private global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation homographyEstimation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation HomographyEstimation {
      get { if ((_hasBits0 & 8) != 0) { return homographyEstimation_; } else { return HomographyEstimationDefaultValue; } }
      set {
        _hasBits0 |= 8;
        homographyEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "homography_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyEstimation {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "homography_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyEstimation() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "homography_exact_denominator_scaling" field.</summary>
    public const int HomographyExactDenominatorScalingFieldNumber = 53;
    private readonly static bool HomographyExactDenominatorScalingDefaultValue = false;

    private bool homographyExactDenominatorScaling_;
    /// <summary>
    /// By default, homography estimation minimizes an objective that is not
    /// strictly the L2 distance between matched points. If the flag is set, each
    /// row of the linear system is scaled with the exact denominator which results
    /// in an objective that minimizes the L2 distance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HomographyExactDenominatorScaling {
      get { if ((_hasBits1 & 64) != 0) { return homographyExactDenominatorScaling_; } else { return HomographyExactDenominatorScalingDefaultValue; } }
      set {
        _hasBits1 |= 64;
        homographyExactDenominatorScaling_ = value;
      }
    }
    /// <summary>Gets whether the "homography_exact_denominator_scaling" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyExactDenominatorScaling {
      get { return (_hasBits1 & 64) != 0; }
    }
    /// <summary>Clears the value of the "homography_exact_denominator_scaling" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyExactDenominatorScaling() {
      _hasBits1 &= ~64;
    }

    /// <summary>Field number for the "use_exact_homography_estimation" field.</summary>
    public const int UseExactHomographyEstimationFieldNumber = 54;
    private readonly static bool UseExactHomographyEstimationDefaultValue = true;

    private bool useExactHomographyEstimation_;
    /// <summary>
    /// Per default, we use exact solver for over-determined system using
    /// well-conditioned QR decomposition. For better speed, set value to false to
    /// use estimation via normal equations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseExactHomographyEstimation {
      get { if ((_hasBits1 & 128) != 0) { return useExactHomographyEstimation_; } else { return UseExactHomographyEstimationDefaultValue; } }
      set {
        _hasBits1 |= 128;
        useExactHomographyEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "use_exact_homography_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseExactHomographyEstimation {
      get { return (_hasBits1 & 128) != 0; }
    }
    /// <summary>Clears the value of the "use_exact_homography_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseExactHomographyEstimation() {
      _hasBits1 &= ~128;
    }

    /// <summary>Field number for the "use_highest_accuracy_for_normal_equations" field.</summary>
    public const int UseHighestAccuracyForNormalEquationsFieldNumber = 55;
    private readonly static bool UseHighestAccuracyForNormalEquationsDefaultValue = true;

    private bool useHighestAccuracyForNormalEquations_;
    /// <summary>
    /// If set uses double instead of float when computing normal equations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseHighestAccuracyForNormalEquations {
      get { if ((_hasBits1 & 256) != 0) { return useHighestAccuracyForNormalEquations_; } else { return UseHighestAccuracyForNormalEquationsDefaultValue; } }
      set {
        _hasBits1 |= 256;
        useHighestAccuracyForNormalEquations_ = value;
      }
    }
    /// <summary>Gets whether the "use_highest_accuracy_for_normal_equations" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseHighestAccuracyForNormalEquations {
      get { return (_hasBits1 & 256) != 0; }
    }
    /// <summary>Clears the value of the "use_highest_accuracy_for_normal_equations" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseHighestAccuracyForNormalEquations() {
      _hasBits1 &= ~256;
    }

    /// <summary>Field number for the "homography_perspective_regularizer" field.</summary>
    public const int HomographyPerspectiveRegularizerFieldNumber = 61;
    private readonly static float HomographyPerspectiveRegularizerDefaultValue = 0F;

    private float homographyPerspectiveRegularizer_;
    /// <summary>
    /// Regularizer for perspective part of the homography. If zero, no
    /// regularization is performed. Should be >= 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float HomographyPerspectiveRegularizer {
      get { if ((_hasBits1 & 1024) != 0) { return homographyPerspectiveRegularizer_; } else { return HomographyPerspectiveRegularizerDefaultValue; } }
      set {
        _hasBits1 |= 1024;
        homographyPerspectiveRegularizer_ = value;
      }
    }
    /// <summary>Gets whether the "homography_perspective_regularizer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyPerspectiveRegularizer {
      get { return (_hasBits1 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "homography_perspective_regularizer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyPerspectiveRegularizer() {
      _hasBits1 &= ~1024;
    }

    /// <summary>Field number for the "mix_homography_estimation" field.</summary>
    public const int MixHomographyEstimationFieldNumber = 12;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation MixHomographyEstimationDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation.EstimationHomogMixNone;

    private global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation mixHomographyEstimation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation MixHomographyEstimation {
      get { if ((_hasBits0 & 32) != 0) { return mixHomographyEstimation_; } else { return MixHomographyEstimationDefaultValue; } }
      set {
        _hasBits0 |= 32;
        mixHomographyEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "mix_homography_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixHomographyEstimation {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "mix_homography_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixHomographyEstimation() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "num_mixtures" field.</summary>
    public const int NumMixturesFieldNumber = 13;
    private readonly static int NumMixturesDefaultValue = 10;

    private int numMixtures_;
    /// <summary>
    /// If row-wise mixture models are estimated, determines number of them.
    /// Note, changing number of mixtures, interpolation sigma and regularizer
    /// is very likely to impact the stability analysis for mixtures and rolling
    /// shutter scoring. At least MixtureHomographyBounds would need to be adjusted
    /// to the new values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumMixtures {
      get { if ((_hasBits0 & 64) != 0) { return numMixtures_; } else { return NumMixturesDefaultValue; } }
      set {
        _hasBits0 |= 64;
        numMixtures_ = value;
      }
    }
    /// <summary>Gets whether the "num_mixtures" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumMixtures {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "num_mixtures" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumMixtures() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "mixture_row_sigma" field.</summary>
    public const int MixtureRowSigmaFieldNumber = 14;
    private readonly static float MixtureRowSigmaDefaultValue = 0.1F;

    private float mixtureRowSigma_;
    /// <summary>
    /// If row-wise mixture models are estimated, determines how much each point is
    /// influenced by its neigbhoring mixtures. Specified as relative sigma
    /// (standard deviation) w.r.t. frame_height.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MixtureRowSigma {
      get { if ((_hasBits0 & 128) != 0) { return mixtureRowSigma_; } else { return MixtureRowSigmaDefaultValue; } }
      set {
        _hasBits0 |= 128;
        mixtureRowSigma_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_row_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRowSigma {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "mixture_row_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRowSigma() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "mixture_regularizer" field.</summary>
    public const int MixtureRegularizerFieldNumber = 15;
    private readonly static float MixtureRegularizerDefaultValue = 0.0001F;

    private float mixtureRegularizer_;
    /// <summary>
    /// Mixture estimation uses L2 regularizer to assure that adjacent mixture
    /// models are similar.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MixtureRegularizer {
      get { if ((_hasBits0 & 256) != 0) { return mixtureRegularizer_; } else { return MixtureRegularizerDefaultValue; } }
      set {
        _hasBits0 |= 256;
        mixtureRegularizer_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_regularizer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRegularizer {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "mixture_regularizer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRegularizer() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "mixture_regularizer_levels" field.</summary>
    public const int MixtureRegularizerLevelsFieldNumber = 42;
    private readonly static float MixtureRegularizerLevelsDefaultValue = 3F;

    private float mixtureRegularizerLevels_;
    /// <summary>
    /// Mixtures are estimated across a spectrum of exponentially increasingly
    /// regularizers. In particular the regularizer at level L is given as
    /// mixture_regularizer * mixture_regularizer_base^L.
    /// A maximum of 10 levels are supported (checked!).
    /// Note: When changing the number of levels you probably want to adapt the
    ///       MotionStabilizationOptions::rolling_shutter_increment value as well,
    ///       as the number of levels directly controls the highest threshold for
    ///       the rolling shutter index analysis.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MixtureRegularizerLevels {
      get { if ((_hasBits0 & 134217728) != 0) { return mixtureRegularizerLevels_; } else { return MixtureRegularizerLevelsDefaultValue; } }
      set {
        _hasBits0 |= 134217728;
        mixtureRegularizerLevels_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_regularizer_levels" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRegularizerLevels {
      get { return (_hasBits0 & 134217728) != 0; }
    }
    /// <summary>Clears the value of the "mixture_regularizer_levels" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRegularizerLevels() {
      _hasBits0 &= ~134217728;
    }

    /// <summary>Field number for the "mixture_regularizer_base" field.</summary>
    public const int MixtureRegularizerBaseFieldNumber = 43;
    private readonly static float MixtureRegularizerBaseDefaultValue = 2.2F;

    private float mixtureRegularizerBase_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MixtureRegularizerBase {
      get { if ((_hasBits0 & 268435456) != 0) { return mixtureRegularizerBase_; } else { return MixtureRegularizerBaseDefaultValue; } }
      set {
        _hasBits0 |= 268435456;
        mixtureRegularizerBase_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_regularizer_base" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRegularizerBase {
      get { return (_hasBits0 & 268435456) != 0; }
    }
    /// <summary>Clears the value of the "mixture_regularizer_base" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRegularizerBase() {
      _hasBits0 &= ~268435456;
    }

    /// <summary>Field number for the "mixture_rs_analysis_level" field.</summary>
    public const int MixtureRsAnalysisLevelFieldNumber = 44;
    private readonly static int MixtureRsAnalysisLevelDefaultValue = 2;

    private int mixtureRsAnalysisLevel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MixtureRsAnalysisLevel {
      get { if ((_hasBits0 & 536870912) != 0) { return mixtureRsAnalysisLevel_; } else { return MixtureRsAnalysisLevelDefaultValue; } }
      set {
        _hasBits0 |= 536870912;
        mixtureRsAnalysisLevel_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_rs_analysis_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureRsAnalysisLevel {
      get { return (_hasBits0 & 536870912) != 0; }
    }
    /// <summary>Clears the value of the "mixture_rs_analysis_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureRsAnalysisLevel() {
      _hasBits0 &= ~536870912;
    }

    /// <summary>Field number for the "irls_rounds" field.</summary>
    public const int IrlsRoundsFieldNumber = 17;
    private readonly static int IrlsRoundsDefaultValue = 10;

    private int irlsRounds_;
    /// <summary>
    /// IRLS rounds to down-weight outliers (default across all models).
    /// Note: IRLS in combination with full mixture models (as opposed to the
    /// default reduced ones) is somewhat expensive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int IrlsRounds {
      get { if ((_hasBits0 & 512) != 0) { return irlsRounds_; } else { return IrlsRoundsDefaultValue; } }
      set {
        _hasBits0 |= 512;
        irlsRounds_ = value;
      }
    }
    /// <summary>Gets whether the "irls_rounds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsRounds {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "irls_rounds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsRounds() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "irls_prior_scale" field.</summary>
    public const int IrlsPriorScaleFieldNumber = 50;
    private readonly static float IrlsPriorScaleDefaultValue = 0.2F;

    private float irlsPriorScale_;
    /// <summary>
    /// If set to > 0 (always needs be less than 1.0), influence of supplied prior
    /// irls weights is linearlly decreased from the specified prior scale (weight
    /// 1.0) to prior_scale. Effectively, biases the solution to the
    /// supplied prior features.
    /// Note: Without irls_weights_preinitialized set to true, this option is
    /// effectively a no op.
    /// TODO: Retire this option.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float IrlsPriorScale {
      get { if ((_hasBits1 & 8) != 0) { return irlsPriorScale_; } else { return IrlsPriorScaleDefaultValue; } }
      set {
        _hasBits1 |= 8;
        irlsPriorScale_ = value;
      }
    }
    /// <summary>Gets whether the "irls_prior_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsPriorScale {
      get { return (_hasBits1 & 8) != 0; }
    }
    /// <summary>Clears the value of the "irls_prior_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsPriorScale() {
      _hasBits1 &= ~8;
    }

    /// <summary>Field number for the "irls_motion_magnitude_fraction" field.</summary>
    public const int IrlsMotionMagnitudeFractionFieldNumber = 31;
    private readonly static float IrlsMotionMagnitudeFractionDefaultValue = 0.08F;

    private float irlsMotionMagnitudeFraction_;
    /// <summary>
    /// Determine how to normalize irls weights w.r.t. average motion magnitude.
    /// In general a residual of 1 pixel is assigned an IRLS weight of 1.
    /// However as larger motions in general are affected by a larger error, we
    /// normalize irls weights, such that a residual
    /// of distance of irls_motion_magnitude_fraction times
    /// &lt;average translation magnitude> equals an IRLS weight of 1.
    /// Must be larger than zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float IrlsMotionMagnitudeFraction {
      get { if ((_hasBits0 & 1048576) != 0) { return irlsMotionMagnitudeFraction_; } else { return IrlsMotionMagnitudeFractionDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        irlsMotionMagnitudeFraction_ = value;
      }
    }
    /// <summary>Gets whether the "irls_motion_magnitude_fraction" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsMotionMagnitudeFraction {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "irls_motion_magnitude_fraction" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsMotionMagnitudeFraction() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "irls_mixture_fraction_scale" field.</summary>
    public const int IrlsMixtureFractionScaleFieldNumber = 68;
    private readonly static float IrlsMixtureFractionScaleDefaultValue = 1.5F;

    private float irlsMixtureFractionScale_;
    /// <summary>
    /// Scale that is applied for mixture (where error is expected to be bigger).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float IrlsMixtureFractionScale {
      get { if ((_hasBits1 & 32768) != 0) { return irlsMixtureFractionScale_; } else { return IrlsMixtureFractionScaleDefaultValue; } }
      set {
        _hasBits1 |= 32768;
        irlsMixtureFractionScale_ = value;
      }
    }
    /// <summary>Gets whether the "irls_mixture_fraction_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsMixtureFractionScale {
      get { return (_hasBits1 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "irls_mixture_fraction_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsMixtureFractionScale() {
      _hasBits1 &= ~32768;
    }

    /// <summary>Field number for the "irls_weights_preinitialized" field.</summary>
    public const int IrlsWeightsPreinitializedFieldNumber = 39;
    private readonly static bool IrlsWeightsPreinitializedDefaultValue = false;

    private bool irlsWeightsPreinitialized_;
    /// <summary>
    /// By default, irls weight of all features are set uniformly to one before
    /// estimating EACH model, refining them in subsequent irls iterations.
    /// If flag below is set, input irls weights are used instead for each motion
    /// model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IrlsWeightsPreinitialized {
      get { if ((_hasBits0 & 16777216) != 0) { return irlsWeightsPreinitialized_; } else { return IrlsWeightsPreinitializedDefaultValue; } }
      set {
        _hasBits0 |= 16777216;
        irlsWeightsPreinitialized_ = value;
      }
    }
    /// <summary>Gets whether the "irls_weights_preinitialized" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsWeightsPreinitialized {
      get { return (_hasBits0 & 16777216) != 0; }
    }
    /// <summary>Clears the value of the "irls_weights_preinitialized" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsWeightsPreinitialized() {
      _hasBits0 &= ~16777216;
    }

    /// <summary>Field number for the "filter_initialized_irls_weights" field.</summary>
    public const int FilterInitializedIrlsWeightsFieldNumber = 67;
    private readonly static bool FilterInitializedIrlsWeightsDefaultValue = false;

    private bool filterInitializedIrlsWeights_;
    /// <summary>
    /// If weights are pre-initialized optionally min filter weights along track
    /// ids when long tracks are used. This can be used to consistently label
    /// outliers in time before estimation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FilterInitializedIrlsWeights {
      get { if ((_hasBits1 & 16384) != 0) { return filterInitializedIrlsWeights_; } else { return FilterInitializedIrlsWeightsDefaultValue; } }
      set {
        _hasBits1 |= 16384;
        filterInitializedIrlsWeights_ = value;
      }
    }
    /// <summary>Gets whether the "filter_initialized_irls_weights" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilterInitializedIrlsWeights {
      get { return (_hasBits1 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "filter_initialized_irls_weights" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilterInitializedIrlsWeights() {
      _hasBits1 &= ~16384;
    }

    /// <summary>Field number for the "irls_initialization" field.</summary>
    public const int IrlsInitializationFieldNumber = 56;
    private global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization irlsInitialization_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization IrlsInitialization {
      get { return irlsInitialization_; }
      set {
        irlsInitialization_ = value;
      }
    }

    /// <summary>Field number for the "feature_density_normalization" field.</summary>
    public const int FeatureDensityNormalizationFieldNumber = 62;
    private readonly static bool FeatureDensityNormalizationDefaultValue = false;

    private bool featureDensityNormalization_;
    /// <summary>
    /// Normalizes feature's irls weights prior to estimation such that
    /// feature in high density areas are downweighted. Multiplicative in case
    /// irls_weights_preinitialized is set to true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FeatureDensityNormalization {
      get { if ((_hasBits1 & 2048) != 0) { return featureDensityNormalization_; } else { return FeatureDensityNormalizationDefaultValue; } }
      set {
        _hasBits1 |= 2048;
        featureDensityNormalization_ = value;
      }
    }
    /// <summary>Gets whether the "feature_density_normalization" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFeatureDensityNormalization {
      get { return (_hasBits1 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "feature_density_normalization" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFeatureDensityNormalization() {
      _hasBits1 &= ~2048;
    }

    /// <summary>Field number for the "feature_mask_size" field.</summary>
    public const int FeatureMaskSizeFieldNumber = 63;
    private readonly static int FeatureMaskSizeDefaultValue = 10;

    private int featureMaskSize_;
    /// <summary>
    /// A regular grid of size feature_mask_size x feature_mask_size
    /// is used to normalize features w.r.t. their density.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FeatureMaskSize {
      get { if ((_hasBits1 & 4096) != 0) { return featureMaskSize_; } else { return FeatureMaskSizeDefaultValue; } }
      set {
        _hasBits1 |= 4096;
        featureMaskSize_ = value;
      }
    }
    /// <summary>Gets whether the "feature_mask_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFeatureMaskSize {
      get { return (_hasBits1 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "feature_mask_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFeatureMaskSize() {
      _hasBits1 &= ~4096;
    }

    /// <summary>Field number for the "long_feature_initialization" field.</summary>
    public const int LongFeatureInitializationFieldNumber = 66;
    private global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization longFeatureInitialization_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization LongFeatureInitialization {
      get { return longFeatureInitialization_; }
      set {
        longFeatureInitialization_ = value;
      }
    }

    /// <summary>Field number for the "irls_mask_options" field.</summary>
    public const int IrlsMaskOptionsFieldNumber = 57;
    private global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions irlsMaskOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions IrlsMaskOptions {
      get { return irlsMaskOptions_; }
      set {
        irlsMaskOptions_ = value;
      }
    }

    /// <summary>Field number for the "joint_track_estimation" field.</summary>
    public const int JointTrackEstimationFieldNumber = 59;
    private global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions jointTrackEstimation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions JointTrackEstimation {
      get { return jointTrackEstimation_; }
      set {
        jointTrackEstimation_ = value;
      }
    }

    /// <summary>Field number for the "long_feature_bias_options" field.</summary>
    public const int LongFeatureBiasOptionsFieldNumber = 64;
    private global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions longFeatureBiasOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions LongFeatureBiasOptions {
      get { return longFeatureBiasOptions_; }
      set {
        longFeatureBiasOptions_ = value;
      }
    }

    /// <summary>Field number for the "estimation_policy" field.</summary>
    public const int EstimationPolicyFieldNumber = 58;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy EstimationPolicyDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy.IndependentParallel;

    private global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy estimationPolicy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy EstimationPolicy {
      get { if ((_hasBits1 & 512) != 0) { return estimationPolicy_; } else { return EstimationPolicyDefaultValue; } }
      set {
        _hasBits1 |= 512;
        estimationPolicy_ = value;
      }
    }
    /// <summary>Gets whether the "estimation_policy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimationPolicy {
      get { return (_hasBits1 & 512) != 0; }
    }
    /// <summary>Clears the value of the "estimation_policy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimationPolicy() {
      _hasBits1 &= ~512;
    }

    /// <summary>Field number for the "coverage_grid_size" field.</summary>
    public const int CoverageGridSizeFieldNumber = 51;
    private readonly static int CoverageGridSizeDefaultValue = 10;

    private int coverageGridSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CoverageGridSize {
      get { if ((_hasBits1 & 16) != 0) { return coverageGridSize_; } else { return CoverageGridSizeDefaultValue; } }
      set {
        _hasBits1 |= 16;
        coverageGridSize_ = value;
      }
    }
    /// <summary>Gets whether the "coverage_grid_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCoverageGridSize {
      get { return (_hasBits1 & 16) != 0; }
    }
    /// <summary>Clears the value of the "coverage_grid_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCoverageGridSize() {
      _hasBits1 &= ~16;
    }

    /// <summary>Field number for the "mixture_model_mode" field.</summary>
    public const int MixtureModelModeFieldNumber = 23;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode MixtureModelModeDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode.SkewRotationMixture;

    private global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode mixtureModelMode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode MixtureModelMode {
      get { if ((_hasBits0 & 4096) != 0) { return mixtureModelMode_; } else { return MixtureModelModeDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        mixtureModelMode_ = value;
      }
    }
    /// <summary>Gets whether the "mixture_model_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMixtureModelMode {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "mixture_model_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMixtureModelMode() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "use_only_lin_sim_inliers_for_homography" field.</summary>
    public const int UseOnlyLinSimInliersForHomographyFieldNumber = 6;
    private readonly static bool UseOnlyLinSimInliersForHomographyDefaultValue = true;

    private bool useOnlyLinSimInliersForHomography_;
    /// <summary>
    /// If specified, only features that agree with the estimated linear similarity
    /// will be used to estimate the homography.
    /// If set, linear_similarity_estimation can not be ESTIMATION_NONE! (checked)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseOnlyLinSimInliersForHomography {
      get { if ((_hasBits0 & 16) != 0) { return useOnlyLinSimInliersForHomography_; } else { return UseOnlyLinSimInliersForHomographyDefaultValue; } }
      set {
        _hasBits0 |= 16;
        useOnlyLinSimInliersForHomography_ = value;
      }
    }
    /// <summary>Gets whether the "use_only_lin_sim_inliers_for_homography" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUseOnlyLinSimInliersForHomography {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "use_only_lin_sim_inliers_for_homography" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUseOnlyLinSimInliersForHomography() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "lin_sim_inlier_threshold" field.</summary>
    public const int LinSimInlierThresholdFieldNumber = 20;
    private readonly static float LinSimInlierThresholdDefaultValue = 0.003F;

    private float linSimInlierThreshold_;
    /// <summary>
    /// Max. deviation to be considered an inlier w.r.t. estimated similarity for
    /// above flag. This value is set w.r.t. normalized frame diameter.
    /// TODO: Should take GetIRLSResidualScale into account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float LinSimInlierThreshold {
      get { if ((_hasBits0 & 1024) != 0) { return linSimInlierThreshold_; } else { return LinSimInlierThresholdDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        linSimInlierThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "lin_sim_inlier_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLinSimInlierThreshold {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "lin_sim_inlier_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLinSimInlierThreshold() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "stable_translation_bounds" field.</summary>
    public const int StableTranslationBoundsFieldNumber = 32;
    private global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds stableTranslationBounds_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds StableTranslationBounds {
      get { return stableTranslationBounds_; }
      set {
        stableTranslationBounds_ = value;
      }
    }

    /// <summary>Field number for the "stable_similarity_bounds" field.</summary>
    public const int StableSimilarityBoundsFieldNumber = 33;
    private global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds stableSimilarityBounds_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds StableSimilarityBounds {
      get { return stableSimilarityBounds_; }
      set {
        stableSimilarityBounds_ = value;
      }
    }

    /// <summary>Field number for the "stable_homography_bounds" field.</summary>
    public const int StableHomographyBoundsFieldNumber = 11;
    private global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds stableHomographyBounds_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds StableHomographyBounds {
      get { return stableHomographyBounds_; }
      set {
        stableHomographyBounds_ = value;
      }
    }

    /// <summary>Field number for the "stable_mixture_homography_bounds" field.</summary>
    public const int StableMixtureHomographyBoundsFieldNumber = 34;
    private global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds stableMixtureHomographyBounds_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds StableMixtureHomographyBounds {
      get { return stableMixtureHomographyBounds_; }
      set {
        stableMixtureHomographyBounds_ = value;
      }
    }

    /// <summary>Field number for the "strict_coverage_scale" field.</summary>
    public const int StrictCoverageScaleFieldNumber = 41;
    private readonly static float StrictCoverageScaleDefaultValue = 1.333F;

    private float strictCoverageScale_;
    /// <summary>
    /// Scale for stricter coverage evaluation. Used for rolling shutter guess
    /// computation, by only using high quality inliers. Larger values reflect
    /// stricter coverage.
    /// Specifically, when computing coverage via GridCoverage call,
    /// frac_inlier_threshold is reduced (divided) by specified scale below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float StrictCoverageScale {
      get { if ((_hasBits0 & 67108864) != 0) { return strictCoverageScale_; } else { return StrictCoverageScaleDefaultValue; } }
      set {
        _hasBits0 |= 67108864;
        strictCoverageScale_ = value;
      }
    }
    /// <summary>Gets whether the "strict_coverage_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStrictCoverageScale {
      get { return (_hasBits0 & 67108864) != 0; }
    }
    /// <summary>Clears the value of the "strict_coverage_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStrictCoverageScale() {
      _hasBits0 &= ~67108864;
    }

    /// <summary>Field number for the "label_empty_frames_as_valid" field.</summary>
    public const int LabelEmptyFramesAsValidFieldNumber = 22;
    private readonly static bool LabelEmptyFramesAsValidDefaultValue = true;

    private bool labelEmptyFramesAsValid_;
    /// <summary>
    /// By default frames with zero trackable features (e.g. at the beginning,
    /// empty frame or shot boundary) are set identity model but still labeled as
    /// valid. If set to false, these frames are flagged as invalid, which can be
    /// useful to locate shot boundaries, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool LabelEmptyFramesAsValid {
      get { if ((_hasBits0 & 2048) != 0) { return labelEmptyFramesAsValid_; } else { return LabelEmptyFramesAsValidDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        labelEmptyFramesAsValid_ = value;
      }
    }
    /// <summary>Gets whether the "label_empty_frames_as_valid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLabelEmptyFramesAsValid {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "label_empty_frames_as_valid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLabelEmptyFramesAsValid() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "feature_grid_size" field.</summary>
    public const int FeatureGridSizeFieldNumber = 24;
    private readonly static float FeatureGridSizeDefaultValue = 0.05F;

    private float featureGridSize_;
    /// <summary>
    /// Setting for temporal smoothing of irls weights in optional post-processing
    /// step.
    /// In normalized coordinates w.r.t. frame domain.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FeatureGridSize {
      get { if ((_hasBits0 & 8192) != 0) { return featureGridSize_; } else { return FeatureGridSizeDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        featureGridSize_ = value;
      }
    }
    /// <summary>Gets whether the "feature_grid_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFeatureGridSize {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "feature_grid_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFeatureGridSize() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "spatial_sigma" field.</summary>
    public const int SpatialSigmaFieldNumber = 25;
    private readonly static float SpatialSigmaDefaultValue = 0.01F;

    private float spatialSigma_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float SpatialSigma {
      get { if ((_hasBits0 & 16384) != 0) { return spatialSigma_; } else { return SpatialSigmaDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        spatialSigma_ = value;
      }
    }
    /// <summary>Gets whether the "spatial_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSpatialSigma {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "spatial_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSpatialSigma() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "temporal_irls_diameter" field.</summary>
    public const int TemporalIrlsDiameterFieldNumber = 26;
    private readonly static int TemporalIrlsDiameterDefaultValue = 20;

    private int temporalIrlsDiameter_;
    /// <summary>
    /// Frame diameter across which smoothing is performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TemporalIrlsDiameter {
      get { if ((_hasBits0 & 32768) != 0) { return temporalIrlsDiameter_; } else { return TemporalIrlsDiameterDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        temporalIrlsDiameter_ = value;
      }
    }
    /// <summary>Gets whether the "temporal_irls_diameter" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTemporalIrlsDiameter {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "temporal_irls_diameter" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTemporalIrlsDiameter() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "temporal_sigma" field.</summary>
    public const int TemporalSigmaFieldNumber = 27;
    private readonly static float TemporalSigmaDefaultValue = 5F;

    private float temporalSigma_;
    /// <summary>
    /// in frames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float TemporalSigma {
      get { if ((_hasBits0 & 65536) != 0) { return temporalSigma_; } else { return TemporalSigmaDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        temporalSigma_ = value;
      }
    }
    /// <summary>Gets whether the "temporal_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTemporalSigma {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "temporal_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTemporalSigma() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "feature_sigma" field.</summary>
    public const int FeatureSigmaFieldNumber = 28;
    private readonly static float FeatureSigmaDefaultValue = 30F;

    private float featureSigma_;
    /// <summary>
    /// Bilateral weight (for un-normalized color domain [0, .. 255]).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float FeatureSigma {
      get { if ((_hasBits0 & 131072) != 0) { return featureSigma_; } else { return FeatureSigmaDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        featureSigma_ = value;
      }
    }
    /// <summary>Gets whether the "feature_sigma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFeatureSigma {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "feature_sigma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFeatureSigma() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "filter_5_taps" field.</summary>
    public const int Filter5TapsFieldNumber = 29;
    private readonly static bool Filter5TapsDefaultValue = false;

    private bool filter5Taps_;
    /// <summary>
    /// If set to false 3 taps are used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Filter5Taps {
      get { if ((_hasBits0 & 262144) != 0) { return filter5Taps_; } else { return Filter5TapsDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        filter5Taps_ = value;
      }
    }
    /// <summary>Gets whether the "filter_5_taps" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFilter5Taps {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "filter_5_taps" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFilter5Taps() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "frame_confidence_weighting" field.</summary>
    public const int FrameConfidenceWeightingFieldNumber = 48;
    private readonly static bool FrameConfidenceWeightingDefaultValue = true;

    private bool frameConfidenceWeighting_;
    /// <summary>
    /// If set, during temporal smoothing, each frame is weighted by its
    /// confidence, defined as the square coverage (or square mean mixture
    /// coverage). Therefore, low confidence fits do not errornouesly propagate
    /// over time. In addition, if the confidence is below the specified
    /// confidence_threshold (relative the the maximum coverage observed in the
    /// test interval), irls weights are reset to 1, i.e. biased to be
    /// agree with the (unkown) background motion.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FrameConfidenceWeighting {
      get { if ((_hasBits1 & 2) != 0) { return frameConfidenceWeighting_; } else { return FrameConfidenceWeightingDefaultValue; } }
      set {
        _hasBits1 |= 2;
        frameConfidenceWeighting_ = value;
      }
    }
    /// <summary>Gets whether the "frame_confidence_weighting" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFrameConfidenceWeighting {
      get { return (_hasBits1 & 2) != 0; }
    }
    /// <summary>Clears the value of the "frame_confidence_weighting" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFrameConfidenceWeighting() {
      _hasBits1 &= ~2;
    }

    /// <summary>Field number for the "reset_confidence_threshold" field.</summary>
    public const int ResetConfidenceThresholdFieldNumber = 49;
    private readonly static float ResetConfidenceThresholdDefaultValue = 0.4F;

    private float resetConfidenceThreshold_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float ResetConfidenceThreshold {
      get { if ((_hasBits1 & 4) != 0) { return resetConfidenceThreshold_; } else { return ResetConfidenceThresholdDefaultValue; } }
      set {
        _hasBits1 |= 4;
        resetConfidenceThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "reset_confidence_threshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasResetConfidenceThreshold {
      get { return (_hasBits1 & 4) != 0; }
    }
    /// <summary>Clears the value of the "reset_confidence_threshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearResetConfidenceThreshold() {
      _hasBits1 &= ~4;
    }

    /// <summary>Field number for the "irls_weight_filter" field.</summary>
    public const int IrlsWeightFilterFieldNumber = 35;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter IrlsWeightFilterDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter.IrlsFilterNone;

    private global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter irlsWeightFilter_;
    /// <summary>
    /// Calls TextureFilteredRegionFlowFeatureIRLSWeights on computed irls weights
    /// before smoothing them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter IrlsWeightFilter {
      get { if ((_hasBits0 & 2097152) != 0) { return irlsWeightFilter_; } else { return IrlsWeightFilterDefaultValue; } }
      set {
        _hasBits0 |= 2097152;
        irlsWeightFilter_ = value;
      }
    }
    /// <summary>Gets whether the "irls_weight_filter" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsWeightFilter {
      get { return (_hasBits0 & 2097152) != 0; }
    }
    /// <summary>Clears the value of the "irls_weight_filter" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsWeightFilter() {
      _hasBits0 &= ~2097152;
    }

    /// <summary>Field number for the "overlay_detection" field.</summary>
    public const int OverlayDetectionFieldNumber = 36;
    private readonly static bool OverlayDetectionDefaultValue = false;

    private bool overlayDetection_;
    /// <summary>
    /// Attempts to detect overlays, i.e. static elements burned-into the video
    /// that potentially corrupt motion estimation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OverlayDetection {
      get { if ((_hasBits0 & 4194304) != 0) { return overlayDetection_; } else { return OverlayDetectionDefaultValue; } }
      set {
        _hasBits0 |= 4194304;
        overlayDetection_ = value;
      }
    }
    /// <summary>Gets whether the "overlay_detection" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverlayDetection {
      get { return (_hasBits0 & 4194304) != 0; }
    }
    /// <summary>Clears the value of the "overlay_detection" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverlayDetection() {
      _hasBits0 &= ~4194304;
    }

    /// <summary>Field number for the "overlay_analysis_chunk_size" field.</summary>
    public const int OverlayAnalysisChunkSizeFieldNumber = 37;
    private readonly static int OverlayAnalysisChunkSizeDefaultValue = 8;

    private int overlayAnalysisChunkSize_;
    /// <summary>
    /// Overlay detection is performed over specified number of frames.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int OverlayAnalysisChunkSize {
      get { if ((_hasBits0 & 8388608) != 0) { return overlayAnalysisChunkSize_; } else { return OverlayAnalysisChunkSizeDefaultValue; } }
      set {
        _hasBits0 |= 8388608;
        overlayAnalysisChunkSize_ = value;
      }
    }
    /// <summary>Gets whether the "overlay_analysis_chunk_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOverlayAnalysisChunkSize {
      get { return (_hasBits0 & 8388608) != 0; }
    }
    /// <summary>Clears the value of the "overlay_analysis_chunk_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOverlayAnalysisChunkSize() {
      _hasBits0 &= ~8388608;
    }

    /// <summary>Field number for the "overlay_detection_options" field.</summary>
    public const int OverlayDetectionOptionsFieldNumber = 38;
    private global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions overlayDetectionOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions OverlayDetectionOptions {
      get { return overlayDetectionOptions_; }
      set {
        overlayDetectionOptions_ = value;
      }
    }

    /// <summary>Field number for the "shot_boundary_options" field.</summary>
    public const int ShotBoundaryOptionsFieldNumber = 60;
    private global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions shotBoundaryOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions ShotBoundaryOptions {
      get { return shotBoundaryOptions_; }
      set {
        shotBoundaryOptions_ = value;
      }
    }

    /// <summary>Field number for the "output_refined_irls_weights" field.</summary>
    public const int OutputRefinedIrlsWeightsFieldNumber = 40;
    private readonly static bool OutputRefinedIrlsWeightsDefaultValue = true;

    private bool outputRefinedIrlsWeights_;
    /// <summary>
    /// By default, irls weights of each feature are overwritten with refined irls
    /// weights of the last iteration for the highest degree of freedom model that
    /// was estimated stable. If set to false, original irls weights are retained.
    /// Note: If overlay detection is activated, features to be deemed overlays
    ///       have their irls weight set to zero, regardless of this setting.
    ///       Similarily, an IRLSWeightFilter is applied if requested, regardless
    ///       of this setting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OutputRefinedIrlsWeights {
      get { if ((_hasBits0 & 33554432) != 0) { return outputRefinedIrlsWeights_; } else { return OutputRefinedIrlsWeightsDefaultValue; } }
      set {
        _hasBits0 |= 33554432;
        outputRefinedIrlsWeights_ = value;
      }
    }
    /// <summary>Gets whether the "output_refined_irls_weights" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOutputRefinedIrlsWeights {
      get { return (_hasBits0 & 33554432) != 0; }
    }
    /// <summary>Clears the value of the "output_refined_irls_weights" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOutputRefinedIrlsWeights() {
      _hasBits0 &= ~33554432;
    }

    /// <summary>Field number for the "homography_irls_weight_initialization" field.</summary>
    public const int HomographyIrlsWeightInitializationFieldNumber = 45;
    private readonly static global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization HomographyIrlsWeightInitializationDefaultValue = global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization.IrlsWeightPerimeterGaussian;

    private global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization homographyIrlsWeightInitialization_;
    /// <summary>
    /// IRLS weights for homography estimation are initialized based on the
    /// specified options. If, options irls_weights_preinitialized is set,
    /// weights are multiplied instead of reset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization HomographyIrlsWeightInitialization {
      get { if ((_hasBits0 & 1073741824) != 0) { return homographyIrlsWeightInitialization_; } else { return HomographyIrlsWeightInitializationDefaultValue; } }
      set {
        _hasBits0 |= 1073741824;
        homographyIrlsWeightInitialization_ = value;
      }
    }
    /// <summary>Gets whether the "homography_irls_weight_initialization" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHomographyIrlsWeightInitialization {
      get { return (_hasBits0 & 1073741824) != 0; }
    }
    /// <summary>Clears the value of the "homography_irls_weight_initialization" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHomographyIrlsWeightInitialization() {
      _hasBits0 &= ~1073741824;
    }

    /// <summary>Field number for the "irls_use_l0_norm" field.</summary>
    public const int IrlsUseL0NormFieldNumber = 46;
    private readonly static bool IrlsUseL0NormDefaultValue = true;

    private bool irlsUseL0Norm_;
    /// <summary>
    /// If set to false use L1 norm irls weights instead of L0 norm irls weights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IrlsUseL0Norm {
      get { if ((_hasBits0 & -2147483648) != 0) { return irlsUseL0Norm_; } else { return IrlsUseL0NormDefaultValue; } }
      set {
        _hasBits0 |= -2147483648;
        irlsUseL0Norm_ = value;
      }
    }
    /// <summary>Gets whether the "irls_use_l0_norm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIrlsUseL0Norm {
      get { return (_hasBits0 & -2147483648) != 0; }
    }
    /// <summary>Clears the value of the "irls_use_l0_norm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIrlsUseL0Norm() {
      _hasBits0 &= ~-2147483648;
    }

    /// <summary>Field number for the "domain_limited_irls_scaling" field.</summary>
    public const int DomainLimitedIrlsScalingFieldNumber = 65;
    private readonly static bool DomainLimitedIrlsScalingDefaultValue = false;

    private bool domainLimitedIrlsScaling_;
    /// <summary>
    /// IRLS weights are determined in a limited domain (in particular helpful
    /// for stabilization analysis on HD videos).
    /// TODO: Make this the default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DomainLimitedIrlsScaling {
      get { if ((_hasBits1 & 8192) != 0) { return domainLimitedIrlsScaling_; } else { return DomainLimitedIrlsScalingDefaultValue; } }
      set {
        _hasBits1 |= 8192;
        domainLimitedIrlsScaling_ = value;
      }
    }
    /// <summary>Gets whether the "domain_limited_irls_scaling" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDomainLimitedIrlsScaling {
      get { return (_hasBits1 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "domain_limited_irls_scaling" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDomainLimitedIrlsScaling() {
      _hasBits1 &= ~8192;
    }

    /// <summary>Field number for the "deactivate_stable_motion_estimation" field.</summary>
    public const int DeactivateStableMotionEstimationFieldNumber = 47;
    private readonly static bool DeactivateStableMotionEstimationDefaultValue = false;

    private bool deactivateStableMotionEstimation_;
    /// <summary>
    /// For comparison and debugging purposes. Simply estimates requested models
    /// without checking their stability via the stable_*_bounds parameters.
    /// However, invertibility is still checked to avoid invalid data being passed
    /// to later stages of the stabilizer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeactivateStableMotionEstimation {
      get { if ((_hasBits1 & 1) != 0) { return deactivateStableMotionEstimation_; } else { return DeactivateStableMotionEstimationDefaultValue; } }
      set {
        _hasBits1 |= 1;
        deactivateStableMotionEstimation_ = value;
      }
    }
    /// <summary>Gets whether the "deactivate_stable_motion_estimation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeactivateStableMotionEstimation {
      get { return (_hasBits1 & 1) != 0; }
    }
    /// <summary>Clears the value of the "deactivate_stable_motion_estimation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeactivateStableMotionEstimation() {
      _hasBits1 &= ~1;
    }

    /// <summary>Field number for the "project_valid_motions_down" field.</summary>
    public const int ProjectValidMotionsDownFieldNumber = 52;
    private readonly static bool ProjectValidMotionsDownDefaultValue = false;

    private bool projectValidMotionsDown_;
    /// <summary>
    /// Projects higher order motions if estimated correctly down to lower order
    /// motions, therefore replacing the previously estimated motions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ProjectValidMotionsDown {
      get { if ((_hasBits1 & 32) != 0) { return projectValidMotionsDown_; } else { return ProjectValidMotionsDownDefaultValue; } }
      set {
        _hasBits1 |= 32;
        projectValidMotionsDown_ = value;
      }
    }
    /// <summary>Gets whether the "project_valid_motions_down" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProjectValidMotionsDown {
      get { return (_hasBits1 & 32) != 0; }
    }
    /// <summary>Clears the value of the "project_valid_motions_down" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProjectValidMotionsDown() {
      _hasBits1 &= ~32;
    }

    /// <summary>Field number for the "estimate_similarity" field.</summary>
    public const int EstimateSimilarityFieldNumber = 2;
    private readonly static bool EstimateSimilarityDefaultValue = false;

    private bool estimateSimilarity_;
    /// <summary>
    /// DEPRECATED functionality. Use static functions as indicated instead.
    ///
    /// Non-linear similarity, use MotionEstimation::EstimateSimilarityModelL2.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EstimateSimilarity {
      get { if ((_hasBits0 & 2) != 0) { return estimateSimilarity_; } else { return EstimateSimilarityDefaultValue; } }
      set {
        _hasBits0 |= 2;
        estimateSimilarity_ = value;
      }
    }
    /// <summary>Gets whether the "estimate_similarity" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEstimateSimilarity {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "estimate_similarity" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEstimateSimilarity() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MotionEstimationOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MotionEstimationOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EstimateTranslationIrls != other.EstimateTranslationIrls) return false;
      if (LinearSimilarityEstimation != other.LinearSimilarityEstimation) return false;
      if (AffineEstimation != other.AffineEstimation) return false;
      if (HomographyEstimation != other.HomographyEstimation) return false;
      if (HomographyExactDenominatorScaling != other.HomographyExactDenominatorScaling) return false;
      if (UseExactHomographyEstimation != other.UseExactHomographyEstimation) return false;
      if (UseHighestAccuracyForNormalEquations != other.UseHighestAccuracyForNormalEquations) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HomographyPerspectiveRegularizer, other.HomographyPerspectiveRegularizer)) return false;
      if (MixHomographyEstimation != other.MixHomographyEstimation) return false;
      if (NumMixtures != other.NumMixtures) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MixtureRowSigma, other.MixtureRowSigma)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MixtureRegularizer, other.MixtureRegularizer)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MixtureRegularizerLevels, other.MixtureRegularizerLevels)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MixtureRegularizerBase, other.MixtureRegularizerBase)) return false;
      if (MixtureRsAnalysisLevel != other.MixtureRsAnalysisLevel) return false;
      if (IrlsRounds != other.IrlsRounds) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IrlsPriorScale, other.IrlsPriorScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IrlsMotionMagnitudeFraction, other.IrlsMotionMagnitudeFraction)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IrlsMixtureFractionScale, other.IrlsMixtureFractionScale)) return false;
      if (IrlsWeightsPreinitialized != other.IrlsWeightsPreinitialized) return false;
      if (FilterInitializedIrlsWeights != other.FilterInitializedIrlsWeights) return false;
      if (!object.Equals(IrlsInitialization, other.IrlsInitialization)) return false;
      if (FeatureDensityNormalization != other.FeatureDensityNormalization) return false;
      if (FeatureMaskSize != other.FeatureMaskSize) return false;
      if (!object.Equals(LongFeatureInitialization, other.LongFeatureInitialization)) return false;
      if (!object.Equals(IrlsMaskOptions, other.IrlsMaskOptions)) return false;
      if (!object.Equals(JointTrackEstimation, other.JointTrackEstimation)) return false;
      if (!object.Equals(LongFeatureBiasOptions, other.LongFeatureBiasOptions)) return false;
      if (EstimationPolicy != other.EstimationPolicy) return false;
      if (CoverageGridSize != other.CoverageGridSize) return false;
      if (MixtureModelMode != other.MixtureModelMode) return false;
      if (UseOnlyLinSimInliersForHomography != other.UseOnlyLinSimInliersForHomography) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LinSimInlierThreshold, other.LinSimInlierThreshold)) return false;
      if (!object.Equals(StableTranslationBounds, other.StableTranslationBounds)) return false;
      if (!object.Equals(StableSimilarityBounds, other.StableSimilarityBounds)) return false;
      if (!object.Equals(StableHomographyBounds, other.StableHomographyBounds)) return false;
      if (!object.Equals(StableMixtureHomographyBounds, other.StableMixtureHomographyBounds)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StrictCoverageScale, other.StrictCoverageScale)) return false;
      if (LabelEmptyFramesAsValid != other.LabelEmptyFramesAsValid) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FeatureGridSize, other.FeatureGridSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SpatialSigma, other.SpatialSigma)) return false;
      if (TemporalIrlsDiameter != other.TemporalIrlsDiameter) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TemporalSigma, other.TemporalSigma)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FeatureSigma, other.FeatureSigma)) return false;
      if (Filter5Taps != other.Filter5Taps) return false;
      if (FrameConfidenceWeighting != other.FrameConfidenceWeighting) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ResetConfidenceThreshold, other.ResetConfidenceThreshold)) return false;
      if (IrlsWeightFilter != other.IrlsWeightFilter) return false;
      if (OverlayDetection != other.OverlayDetection) return false;
      if (OverlayAnalysisChunkSize != other.OverlayAnalysisChunkSize) return false;
      if (!object.Equals(OverlayDetectionOptions, other.OverlayDetectionOptions)) return false;
      if (!object.Equals(ShotBoundaryOptions, other.ShotBoundaryOptions)) return false;
      if (OutputRefinedIrlsWeights != other.OutputRefinedIrlsWeights) return false;
      if (HomographyIrlsWeightInitialization != other.HomographyIrlsWeightInitialization) return false;
      if (IrlsUseL0Norm != other.IrlsUseL0Norm) return false;
      if (DomainLimitedIrlsScaling != other.DomainLimitedIrlsScaling) return false;
      if (DeactivateStableMotionEstimation != other.DeactivateStableMotionEstimation) return false;
      if (ProjectValidMotionsDown != other.ProjectValidMotionsDown) return false;
      if (EstimateSimilarity != other.EstimateSimilarity) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEstimateTranslationIrls) hash ^= EstimateTranslationIrls.GetHashCode();
      if (HasLinearSimilarityEstimation) hash ^= LinearSimilarityEstimation.GetHashCode();
      if (HasAffineEstimation) hash ^= AffineEstimation.GetHashCode();
      if (HasHomographyEstimation) hash ^= HomographyEstimation.GetHashCode();
      if (HasHomographyExactDenominatorScaling) hash ^= HomographyExactDenominatorScaling.GetHashCode();
      if (HasUseExactHomographyEstimation) hash ^= UseExactHomographyEstimation.GetHashCode();
      if (HasUseHighestAccuracyForNormalEquations) hash ^= UseHighestAccuracyForNormalEquations.GetHashCode();
      if (HasHomographyPerspectiveRegularizer) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HomographyPerspectiveRegularizer);
      if (HasMixHomographyEstimation) hash ^= MixHomographyEstimation.GetHashCode();
      if (HasNumMixtures) hash ^= NumMixtures.GetHashCode();
      if (HasMixtureRowSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MixtureRowSigma);
      if (HasMixtureRegularizer) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MixtureRegularizer);
      if (HasMixtureRegularizerLevels) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MixtureRegularizerLevels);
      if (HasMixtureRegularizerBase) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MixtureRegularizerBase);
      if (HasMixtureRsAnalysisLevel) hash ^= MixtureRsAnalysisLevel.GetHashCode();
      if (HasIrlsRounds) hash ^= IrlsRounds.GetHashCode();
      if (HasIrlsPriorScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IrlsPriorScale);
      if (HasIrlsMotionMagnitudeFraction) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IrlsMotionMagnitudeFraction);
      if (HasIrlsMixtureFractionScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IrlsMixtureFractionScale);
      if (HasIrlsWeightsPreinitialized) hash ^= IrlsWeightsPreinitialized.GetHashCode();
      if (HasFilterInitializedIrlsWeights) hash ^= FilterInitializedIrlsWeights.GetHashCode();
      if (irlsInitialization_ != null) hash ^= IrlsInitialization.GetHashCode();
      if (HasFeatureDensityNormalization) hash ^= FeatureDensityNormalization.GetHashCode();
      if (HasFeatureMaskSize) hash ^= FeatureMaskSize.GetHashCode();
      if (longFeatureInitialization_ != null) hash ^= LongFeatureInitialization.GetHashCode();
      if (irlsMaskOptions_ != null) hash ^= IrlsMaskOptions.GetHashCode();
      if (jointTrackEstimation_ != null) hash ^= JointTrackEstimation.GetHashCode();
      if (longFeatureBiasOptions_ != null) hash ^= LongFeatureBiasOptions.GetHashCode();
      if (HasEstimationPolicy) hash ^= EstimationPolicy.GetHashCode();
      if (HasCoverageGridSize) hash ^= CoverageGridSize.GetHashCode();
      if (HasMixtureModelMode) hash ^= MixtureModelMode.GetHashCode();
      if (HasUseOnlyLinSimInliersForHomography) hash ^= UseOnlyLinSimInliersForHomography.GetHashCode();
      if (HasLinSimInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LinSimInlierThreshold);
      if (stableTranslationBounds_ != null) hash ^= StableTranslationBounds.GetHashCode();
      if (stableSimilarityBounds_ != null) hash ^= StableSimilarityBounds.GetHashCode();
      if (stableHomographyBounds_ != null) hash ^= StableHomographyBounds.GetHashCode();
      if (stableMixtureHomographyBounds_ != null) hash ^= StableMixtureHomographyBounds.GetHashCode();
      if (HasStrictCoverageScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StrictCoverageScale);
      if (HasLabelEmptyFramesAsValid) hash ^= LabelEmptyFramesAsValid.GetHashCode();
      if (HasFeatureGridSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FeatureGridSize);
      if (HasSpatialSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SpatialSigma);
      if (HasTemporalIrlsDiameter) hash ^= TemporalIrlsDiameter.GetHashCode();
      if (HasTemporalSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TemporalSigma);
      if (HasFeatureSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FeatureSigma);
      if (HasFilter5Taps) hash ^= Filter5Taps.GetHashCode();
      if (HasFrameConfidenceWeighting) hash ^= FrameConfidenceWeighting.GetHashCode();
      if (HasResetConfidenceThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ResetConfidenceThreshold);
      if (HasIrlsWeightFilter) hash ^= IrlsWeightFilter.GetHashCode();
      if (HasOverlayDetection) hash ^= OverlayDetection.GetHashCode();
      if (HasOverlayAnalysisChunkSize) hash ^= OverlayAnalysisChunkSize.GetHashCode();
      if (overlayDetectionOptions_ != null) hash ^= OverlayDetectionOptions.GetHashCode();
      if (shotBoundaryOptions_ != null) hash ^= ShotBoundaryOptions.GetHashCode();
      if (HasOutputRefinedIrlsWeights) hash ^= OutputRefinedIrlsWeights.GetHashCode();
      if (HasHomographyIrlsWeightInitialization) hash ^= HomographyIrlsWeightInitialization.GetHashCode();
      if (HasIrlsUseL0Norm) hash ^= IrlsUseL0Norm.GetHashCode();
      if (HasDomainLimitedIrlsScaling) hash ^= DomainLimitedIrlsScaling.GetHashCode();
      if (HasDeactivateStableMotionEstimation) hash ^= DeactivateStableMotionEstimation.GetHashCode();
      if (HasProjectValidMotionsDown) hash ^= ProjectValidMotionsDown.GetHashCode();
      if (HasEstimateSimilarity) hash ^= EstimateSimilarity.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEstimateTranslationIrls) {
        output.WriteRawTag(8);
        output.WriteBool(EstimateTranslationIrls);
      }
      if (HasEstimateSimilarity) {
        output.WriteRawTag(16);
        output.WriteBool(EstimateSimilarity);
      }
      if (HasLinearSimilarityEstimation) {
        output.WriteRawTag(24);
        output.WriteEnum((int) LinearSimilarityEstimation);
      }
      if (HasHomographyEstimation) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HomographyEstimation);
      }
      if (HasUseOnlyLinSimInliersForHomography) {
        output.WriteRawTag(48);
        output.WriteBool(UseOnlyLinSimInliersForHomography);
      }
      if (stableHomographyBounds_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(StableHomographyBounds);
      }
      if (HasMixHomographyEstimation) {
        output.WriteRawTag(96);
        output.WriteEnum((int) MixHomographyEstimation);
      }
      if (HasNumMixtures) {
        output.WriteRawTag(104);
        output.WriteInt32(NumMixtures);
      }
      if (HasMixtureRowSigma) {
        output.WriteRawTag(117);
        output.WriteFloat(MixtureRowSigma);
      }
      if (HasMixtureRegularizer) {
        output.WriteRawTag(125);
        output.WriteFloat(MixtureRegularizer);
      }
      if (HasIrlsRounds) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(IrlsRounds);
      }
      if (HasLinSimInlierThreshold) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(LinSimInlierThreshold);
      }
      if (HasLabelEmptyFramesAsValid) {
        output.WriteRawTag(176, 1);
        output.WriteBool(LabelEmptyFramesAsValid);
      }
      if (HasMixtureModelMode) {
        output.WriteRawTag(184, 1);
        output.WriteEnum((int) MixtureModelMode);
      }
      if (HasFeatureGridSize) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(FeatureGridSize);
      }
      if (HasSpatialSigma) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(SpatialSigma);
      }
      if (HasTemporalIrlsDiameter) {
        output.WriteRawTag(208, 1);
        output.WriteInt32(TemporalIrlsDiameter);
      }
      if (HasTemporalSigma) {
        output.WriteRawTag(221, 1);
        output.WriteFloat(TemporalSigma);
      }
      if (HasFeatureSigma) {
        output.WriteRawTag(229, 1);
        output.WriteFloat(FeatureSigma);
      }
      if (HasFilter5Taps) {
        output.WriteRawTag(232, 1);
        output.WriteBool(Filter5Taps);
      }
      if (HasAffineEstimation) {
        output.WriteRawTag(240, 1);
        output.WriteEnum((int) AffineEstimation);
      }
      if (HasIrlsMotionMagnitudeFraction) {
        output.WriteRawTag(253, 1);
        output.WriteFloat(IrlsMotionMagnitudeFraction);
      }
      if (stableTranslationBounds_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(StableTranslationBounds);
      }
      if (stableSimilarityBounds_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(StableSimilarityBounds);
      }
      if (stableMixtureHomographyBounds_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(StableMixtureHomographyBounds);
      }
      if (HasIrlsWeightFilter) {
        output.WriteRawTag(152, 2);
        output.WriteEnum((int) IrlsWeightFilter);
      }
      if (HasOverlayDetection) {
        output.WriteRawTag(160, 2);
        output.WriteBool(OverlayDetection);
      }
      if (HasOverlayAnalysisChunkSize) {
        output.WriteRawTag(168, 2);
        output.WriteInt32(OverlayAnalysisChunkSize);
      }
      if (overlayDetectionOptions_ != null) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(OverlayDetectionOptions);
      }
      if (HasIrlsWeightsPreinitialized) {
        output.WriteRawTag(184, 2);
        output.WriteBool(IrlsWeightsPreinitialized);
      }
      if (HasOutputRefinedIrlsWeights) {
        output.WriteRawTag(192, 2);
        output.WriteBool(OutputRefinedIrlsWeights);
      }
      if (HasStrictCoverageScale) {
        output.WriteRawTag(205, 2);
        output.WriteFloat(StrictCoverageScale);
      }
      if (HasMixtureRegularizerLevels) {
        output.WriteRawTag(213, 2);
        output.WriteFloat(MixtureRegularizerLevels);
      }
      if (HasMixtureRegularizerBase) {
        output.WriteRawTag(221, 2);
        output.WriteFloat(MixtureRegularizerBase);
      }
      if (HasMixtureRsAnalysisLevel) {
        output.WriteRawTag(224, 2);
        output.WriteInt32(MixtureRsAnalysisLevel);
      }
      if (HasHomographyIrlsWeightInitialization) {
        output.WriteRawTag(232, 2);
        output.WriteEnum((int) HomographyIrlsWeightInitialization);
      }
      if (HasIrlsUseL0Norm) {
        output.WriteRawTag(240, 2);
        output.WriteBool(IrlsUseL0Norm);
      }
      if (HasDeactivateStableMotionEstimation) {
        output.WriteRawTag(248, 2);
        output.WriteBool(DeactivateStableMotionEstimation);
      }
      if (HasFrameConfidenceWeighting) {
        output.WriteRawTag(128, 3);
        output.WriteBool(FrameConfidenceWeighting);
      }
      if (HasResetConfidenceThreshold) {
        output.WriteRawTag(141, 3);
        output.WriteFloat(ResetConfidenceThreshold);
      }
      if (HasIrlsPriorScale) {
        output.WriteRawTag(149, 3);
        output.WriteFloat(IrlsPriorScale);
      }
      if (HasCoverageGridSize) {
        output.WriteRawTag(152, 3);
        output.WriteInt32(CoverageGridSize);
      }
      if (HasProjectValidMotionsDown) {
        output.WriteRawTag(160, 3);
        output.WriteBool(ProjectValidMotionsDown);
      }
      if (HasHomographyExactDenominatorScaling) {
        output.WriteRawTag(168, 3);
        output.WriteBool(HomographyExactDenominatorScaling);
      }
      if (HasUseExactHomographyEstimation) {
        output.WriteRawTag(176, 3);
        output.WriteBool(UseExactHomographyEstimation);
      }
      if (HasUseHighestAccuracyForNormalEquations) {
        output.WriteRawTag(184, 3);
        output.WriteBool(UseHighestAccuracyForNormalEquations);
      }
      if (irlsInitialization_ != null) {
        output.WriteRawTag(194, 3);
        output.WriteMessage(IrlsInitialization);
      }
      if (irlsMaskOptions_ != null) {
        output.WriteRawTag(202, 3);
        output.WriteMessage(IrlsMaskOptions);
      }
      if (HasEstimationPolicy) {
        output.WriteRawTag(208, 3);
        output.WriteEnum((int) EstimationPolicy);
      }
      if (jointTrackEstimation_ != null) {
        output.WriteRawTag(218, 3);
        output.WriteMessage(JointTrackEstimation);
      }
      if (shotBoundaryOptions_ != null) {
        output.WriteRawTag(226, 3);
        output.WriteMessage(ShotBoundaryOptions);
      }
      if (HasHomographyPerspectiveRegularizer) {
        output.WriteRawTag(237, 3);
        output.WriteFloat(HomographyPerspectiveRegularizer);
      }
      if (HasFeatureDensityNormalization) {
        output.WriteRawTag(240, 3);
        output.WriteBool(FeatureDensityNormalization);
      }
      if (HasFeatureMaskSize) {
        output.WriteRawTag(248, 3);
        output.WriteInt32(FeatureMaskSize);
      }
      if (longFeatureBiasOptions_ != null) {
        output.WriteRawTag(130, 4);
        output.WriteMessage(LongFeatureBiasOptions);
      }
      if (HasDomainLimitedIrlsScaling) {
        output.WriteRawTag(136, 4);
        output.WriteBool(DomainLimitedIrlsScaling);
      }
      if (longFeatureInitialization_ != null) {
        output.WriteRawTag(146, 4);
        output.WriteMessage(LongFeatureInitialization);
      }
      if (HasFilterInitializedIrlsWeights) {
        output.WriteRawTag(152, 4);
        output.WriteBool(FilterInitializedIrlsWeights);
      }
      if (HasIrlsMixtureFractionScale) {
        output.WriteRawTag(165, 4);
        output.WriteFloat(IrlsMixtureFractionScale);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEstimateTranslationIrls) {
        output.WriteRawTag(8);
        output.WriteBool(EstimateTranslationIrls);
      }
      if (HasEstimateSimilarity) {
        output.WriteRawTag(16);
        output.WriteBool(EstimateSimilarity);
      }
      if (HasLinearSimilarityEstimation) {
        output.WriteRawTag(24);
        output.WriteEnum((int) LinearSimilarityEstimation);
      }
      if (HasHomographyEstimation) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HomographyEstimation);
      }
      if (HasUseOnlyLinSimInliersForHomography) {
        output.WriteRawTag(48);
        output.WriteBool(UseOnlyLinSimInliersForHomography);
      }
      if (stableHomographyBounds_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(StableHomographyBounds);
      }
      if (HasMixHomographyEstimation) {
        output.WriteRawTag(96);
        output.WriteEnum((int) MixHomographyEstimation);
      }
      if (HasNumMixtures) {
        output.WriteRawTag(104);
        output.WriteInt32(NumMixtures);
      }
      if (HasMixtureRowSigma) {
        output.WriteRawTag(117);
        output.WriteFloat(MixtureRowSigma);
      }
      if (HasMixtureRegularizer) {
        output.WriteRawTag(125);
        output.WriteFloat(MixtureRegularizer);
      }
      if (HasIrlsRounds) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(IrlsRounds);
      }
      if (HasLinSimInlierThreshold) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(LinSimInlierThreshold);
      }
      if (HasLabelEmptyFramesAsValid) {
        output.WriteRawTag(176, 1);
        output.WriteBool(LabelEmptyFramesAsValid);
      }
      if (HasMixtureModelMode) {
        output.WriteRawTag(184, 1);
        output.WriteEnum((int) MixtureModelMode);
      }
      if (HasFeatureGridSize) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(FeatureGridSize);
      }
      if (HasSpatialSigma) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(SpatialSigma);
      }
      if (HasTemporalIrlsDiameter) {
        output.WriteRawTag(208, 1);
        output.WriteInt32(TemporalIrlsDiameter);
      }
      if (HasTemporalSigma) {
        output.WriteRawTag(221, 1);
        output.WriteFloat(TemporalSigma);
      }
      if (HasFeatureSigma) {
        output.WriteRawTag(229, 1);
        output.WriteFloat(FeatureSigma);
      }
      if (HasFilter5Taps) {
        output.WriteRawTag(232, 1);
        output.WriteBool(Filter5Taps);
      }
      if (HasAffineEstimation) {
        output.WriteRawTag(240, 1);
        output.WriteEnum((int) AffineEstimation);
      }
      if (HasIrlsMotionMagnitudeFraction) {
        output.WriteRawTag(253, 1);
        output.WriteFloat(IrlsMotionMagnitudeFraction);
      }
      if (stableTranslationBounds_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(StableTranslationBounds);
      }
      if (stableSimilarityBounds_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(StableSimilarityBounds);
      }
      if (stableMixtureHomographyBounds_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(StableMixtureHomographyBounds);
      }
      if (HasIrlsWeightFilter) {
        output.WriteRawTag(152, 2);
        output.WriteEnum((int) IrlsWeightFilter);
      }
      if (HasOverlayDetection) {
        output.WriteRawTag(160, 2);
        output.WriteBool(OverlayDetection);
      }
      if (HasOverlayAnalysisChunkSize) {
        output.WriteRawTag(168, 2);
        output.WriteInt32(OverlayAnalysisChunkSize);
      }
      if (overlayDetectionOptions_ != null) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(OverlayDetectionOptions);
      }
      if (HasIrlsWeightsPreinitialized) {
        output.WriteRawTag(184, 2);
        output.WriteBool(IrlsWeightsPreinitialized);
      }
      if (HasOutputRefinedIrlsWeights) {
        output.WriteRawTag(192, 2);
        output.WriteBool(OutputRefinedIrlsWeights);
      }
      if (HasStrictCoverageScale) {
        output.WriteRawTag(205, 2);
        output.WriteFloat(StrictCoverageScale);
      }
      if (HasMixtureRegularizerLevels) {
        output.WriteRawTag(213, 2);
        output.WriteFloat(MixtureRegularizerLevels);
      }
      if (HasMixtureRegularizerBase) {
        output.WriteRawTag(221, 2);
        output.WriteFloat(MixtureRegularizerBase);
      }
      if (HasMixtureRsAnalysisLevel) {
        output.WriteRawTag(224, 2);
        output.WriteInt32(MixtureRsAnalysisLevel);
      }
      if (HasHomographyIrlsWeightInitialization) {
        output.WriteRawTag(232, 2);
        output.WriteEnum((int) HomographyIrlsWeightInitialization);
      }
      if (HasIrlsUseL0Norm) {
        output.WriteRawTag(240, 2);
        output.WriteBool(IrlsUseL0Norm);
      }
      if (HasDeactivateStableMotionEstimation) {
        output.WriteRawTag(248, 2);
        output.WriteBool(DeactivateStableMotionEstimation);
      }
      if (HasFrameConfidenceWeighting) {
        output.WriteRawTag(128, 3);
        output.WriteBool(FrameConfidenceWeighting);
      }
      if (HasResetConfidenceThreshold) {
        output.WriteRawTag(141, 3);
        output.WriteFloat(ResetConfidenceThreshold);
      }
      if (HasIrlsPriorScale) {
        output.WriteRawTag(149, 3);
        output.WriteFloat(IrlsPriorScale);
      }
      if (HasCoverageGridSize) {
        output.WriteRawTag(152, 3);
        output.WriteInt32(CoverageGridSize);
      }
      if (HasProjectValidMotionsDown) {
        output.WriteRawTag(160, 3);
        output.WriteBool(ProjectValidMotionsDown);
      }
      if (HasHomographyExactDenominatorScaling) {
        output.WriteRawTag(168, 3);
        output.WriteBool(HomographyExactDenominatorScaling);
      }
      if (HasUseExactHomographyEstimation) {
        output.WriteRawTag(176, 3);
        output.WriteBool(UseExactHomographyEstimation);
      }
      if (HasUseHighestAccuracyForNormalEquations) {
        output.WriteRawTag(184, 3);
        output.WriteBool(UseHighestAccuracyForNormalEquations);
      }
      if (irlsInitialization_ != null) {
        output.WriteRawTag(194, 3);
        output.WriteMessage(IrlsInitialization);
      }
      if (irlsMaskOptions_ != null) {
        output.WriteRawTag(202, 3);
        output.WriteMessage(IrlsMaskOptions);
      }
      if (HasEstimationPolicy) {
        output.WriteRawTag(208, 3);
        output.WriteEnum((int) EstimationPolicy);
      }
      if (jointTrackEstimation_ != null) {
        output.WriteRawTag(218, 3);
        output.WriteMessage(JointTrackEstimation);
      }
      if (shotBoundaryOptions_ != null) {
        output.WriteRawTag(226, 3);
        output.WriteMessage(ShotBoundaryOptions);
      }
      if (HasHomographyPerspectiveRegularizer) {
        output.WriteRawTag(237, 3);
        output.WriteFloat(HomographyPerspectiveRegularizer);
      }
      if (HasFeatureDensityNormalization) {
        output.WriteRawTag(240, 3);
        output.WriteBool(FeatureDensityNormalization);
      }
      if (HasFeatureMaskSize) {
        output.WriteRawTag(248, 3);
        output.WriteInt32(FeatureMaskSize);
      }
      if (longFeatureBiasOptions_ != null) {
        output.WriteRawTag(130, 4);
        output.WriteMessage(LongFeatureBiasOptions);
      }
      if (HasDomainLimitedIrlsScaling) {
        output.WriteRawTag(136, 4);
        output.WriteBool(DomainLimitedIrlsScaling);
      }
      if (longFeatureInitialization_ != null) {
        output.WriteRawTag(146, 4);
        output.WriteMessage(LongFeatureInitialization);
      }
      if (HasFilterInitializedIrlsWeights) {
        output.WriteRawTag(152, 4);
        output.WriteBool(FilterInitializedIrlsWeights);
      }
      if (HasIrlsMixtureFractionScale) {
        output.WriteRawTag(165, 4);
        output.WriteFloat(IrlsMixtureFractionScale);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEstimateTranslationIrls) {
        size += 1 + 1;
      }
      if (HasLinearSimilarityEstimation) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LinearSimilarityEstimation);
      }
      if (HasAffineEstimation) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AffineEstimation);
      }
      if (HasHomographyEstimation) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HomographyEstimation);
      }
      if (HasHomographyExactDenominatorScaling) {
        size += 2 + 1;
      }
      if (HasUseExactHomographyEstimation) {
        size += 2 + 1;
      }
      if (HasUseHighestAccuracyForNormalEquations) {
        size += 2 + 1;
      }
      if (HasHomographyPerspectiveRegularizer) {
        size += 2 + 4;
      }
      if (HasMixHomographyEstimation) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MixHomographyEstimation);
      }
      if (HasNumMixtures) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumMixtures);
      }
      if (HasMixtureRowSigma) {
        size += 1 + 4;
      }
      if (HasMixtureRegularizer) {
        size += 1 + 4;
      }
      if (HasMixtureRegularizerLevels) {
        size += 2 + 4;
      }
      if (HasMixtureRegularizerBase) {
        size += 2 + 4;
      }
      if (HasMixtureRsAnalysisLevel) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MixtureRsAnalysisLevel);
      }
      if (HasIrlsRounds) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(IrlsRounds);
      }
      if (HasIrlsPriorScale) {
        size += 2 + 4;
      }
      if (HasIrlsMotionMagnitudeFraction) {
        size += 2 + 4;
      }
      if (HasIrlsMixtureFractionScale) {
        size += 2 + 4;
      }
      if (HasIrlsWeightsPreinitialized) {
        size += 2 + 1;
      }
      if (HasFilterInitializedIrlsWeights) {
        size += 2 + 1;
      }
      if (irlsInitialization_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(IrlsInitialization);
      }
      if (HasFeatureDensityNormalization) {
        size += 2 + 1;
      }
      if (HasFeatureMaskSize) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(FeatureMaskSize);
      }
      if (longFeatureInitialization_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LongFeatureInitialization);
      }
      if (irlsMaskOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(IrlsMaskOptions);
      }
      if (jointTrackEstimation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(JointTrackEstimation);
      }
      if (longFeatureBiasOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LongFeatureBiasOptions);
      }
      if (HasEstimationPolicy) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) EstimationPolicy);
      }
      if (HasCoverageGridSize) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(CoverageGridSize);
      }
      if (HasMixtureModelMode) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) MixtureModelMode);
      }
      if (HasUseOnlyLinSimInliersForHomography) {
        size += 1 + 1;
      }
      if (HasLinSimInlierThreshold) {
        size += 2 + 4;
      }
      if (stableTranslationBounds_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StableTranslationBounds);
      }
      if (stableSimilarityBounds_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StableSimilarityBounds);
      }
      if (stableHomographyBounds_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StableHomographyBounds);
      }
      if (stableMixtureHomographyBounds_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StableMixtureHomographyBounds);
      }
      if (HasStrictCoverageScale) {
        size += 2 + 4;
      }
      if (HasLabelEmptyFramesAsValid) {
        size += 2 + 1;
      }
      if (HasFeatureGridSize) {
        size += 2 + 4;
      }
      if (HasSpatialSigma) {
        size += 2 + 4;
      }
      if (HasTemporalIrlsDiameter) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(TemporalIrlsDiameter);
      }
      if (HasTemporalSigma) {
        size += 2 + 4;
      }
      if (HasFeatureSigma) {
        size += 2 + 4;
      }
      if (HasFilter5Taps) {
        size += 2 + 1;
      }
      if (HasFrameConfidenceWeighting) {
        size += 2 + 1;
      }
      if (HasResetConfidenceThreshold) {
        size += 2 + 4;
      }
      if (HasIrlsWeightFilter) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) IrlsWeightFilter);
      }
      if (HasOverlayDetection) {
        size += 2 + 1;
      }
      if (HasOverlayAnalysisChunkSize) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(OverlayAnalysisChunkSize);
      }
      if (overlayDetectionOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OverlayDetectionOptions);
      }
      if (shotBoundaryOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ShotBoundaryOptions);
      }
      if (HasOutputRefinedIrlsWeights) {
        size += 2 + 1;
      }
      if (HasHomographyIrlsWeightInitialization) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) HomographyIrlsWeightInitialization);
      }
      if (HasIrlsUseL0Norm) {
        size += 2 + 1;
      }
      if (HasDomainLimitedIrlsScaling) {
        size += 2 + 1;
      }
      if (HasDeactivateStableMotionEstimation) {
        size += 2 + 1;
      }
      if (HasProjectValidMotionsDown) {
        size += 2 + 1;
      }
      if (HasEstimateSimilarity) {
        size += 1 + 1;
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MotionEstimationOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasEstimateTranslationIrls) {
        EstimateTranslationIrls = other.EstimateTranslationIrls;
      }
      if (other.HasLinearSimilarityEstimation) {
        LinearSimilarityEstimation = other.LinearSimilarityEstimation;
      }
      if (other.HasAffineEstimation) {
        AffineEstimation = other.AffineEstimation;
      }
      if (other.HasHomographyEstimation) {
        HomographyEstimation = other.HomographyEstimation;
      }
      if (other.HasHomographyExactDenominatorScaling) {
        HomographyExactDenominatorScaling = other.HomographyExactDenominatorScaling;
      }
      if (other.HasUseExactHomographyEstimation) {
        UseExactHomographyEstimation = other.UseExactHomographyEstimation;
      }
      if (other.HasUseHighestAccuracyForNormalEquations) {
        UseHighestAccuracyForNormalEquations = other.UseHighestAccuracyForNormalEquations;
      }
      if (other.HasHomographyPerspectiveRegularizer) {
        HomographyPerspectiveRegularizer = other.HomographyPerspectiveRegularizer;
      }
      if (other.HasMixHomographyEstimation) {
        MixHomographyEstimation = other.MixHomographyEstimation;
      }
      if (other.HasNumMixtures) {
        NumMixtures = other.NumMixtures;
      }
      if (other.HasMixtureRowSigma) {
        MixtureRowSigma = other.MixtureRowSigma;
      }
      if (other.HasMixtureRegularizer) {
        MixtureRegularizer = other.MixtureRegularizer;
      }
      if (other.HasMixtureRegularizerLevels) {
        MixtureRegularizerLevels = other.MixtureRegularizerLevels;
      }
      if (other.HasMixtureRegularizerBase) {
        MixtureRegularizerBase = other.MixtureRegularizerBase;
      }
      if (other.HasMixtureRsAnalysisLevel) {
        MixtureRsAnalysisLevel = other.MixtureRsAnalysisLevel;
      }
      if (other.HasIrlsRounds) {
        IrlsRounds = other.IrlsRounds;
      }
      if (other.HasIrlsPriorScale) {
        IrlsPriorScale = other.IrlsPriorScale;
      }
      if (other.HasIrlsMotionMagnitudeFraction) {
        IrlsMotionMagnitudeFraction = other.IrlsMotionMagnitudeFraction;
      }
      if (other.HasIrlsMixtureFractionScale) {
        IrlsMixtureFractionScale = other.IrlsMixtureFractionScale;
      }
      if (other.HasIrlsWeightsPreinitialized) {
        IrlsWeightsPreinitialized = other.IrlsWeightsPreinitialized;
      }
      if (other.HasFilterInitializedIrlsWeights) {
        FilterInitializedIrlsWeights = other.FilterInitializedIrlsWeights;
      }
      if (other.irlsInitialization_ != null) {
        if (irlsInitialization_ == null) {
          IrlsInitialization = new global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization();
        }
        IrlsInitialization.MergeFrom(other.IrlsInitialization);
      }
      if (other.HasFeatureDensityNormalization) {
        FeatureDensityNormalization = other.FeatureDensityNormalization;
      }
      if (other.HasFeatureMaskSize) {
        FeatureMaskSize = other.FeatureMaskSize;
      }
      if (other.longFeatureInitialization_ != null) {
        if (longFeatureInitialization_ == null) {
          LongFeatureInitialization = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization();
        }
        LongFeatureInitialization.MergeFrom(other.LongFeatureInitialization);
      }
      if (other.irlsMaskOptions_ != null) {
        if (irlsMaskOptions_ == null) {
          IrlsMaskOptions = new global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions();
        }
        IrlsMaskOptions.MergeFrom(other.IrlsMaskOptions);
      }
      if (other.jointTrackEstimation_ != null) {
        if (jointTrackEstimation_ == null) {
          JointTrackEstimation = new global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions();
        }
        JointTrackEstimation.MergeFrom(other.JointTrackEstimation);
      }
      if (other.longFeatureBiasOptions_ != null) {
        if (longFeatureBiasOptions_ == null) {
          LongFeatureBiasOptions = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions();
        }
        LongFeatureBiasOptions.MergeFrom(other.LongFeatureBiasOptions);
      }
      if (other.HasEstimationPolicy) {
        EstimationPolicy = other.EstimationPolicy;
      }
      if (other.HasCoverageGridSize) {
        CoverageGridSize = other.CoverageGridSize;
      }
      if (other.HasMixtureModelMode) {
        MixtureModelMode = other.MixtureModelMode;
      }
      if (other.HasUseOnlyLinSimInliersForHomography) {
        UseOnlyLinSimInliersForHomography = other.UseOnlyLinSimInliersForHomography;
      }
      if (other.HasLinSimInlierThreshold) {
        LinSimInlierThreshold = other.LinSimInlierThreshold;
      }
      if (other.stableTranslationBounds_ != null) {
        if (stableTranslationBounds_ == null) {
          StableTranslationBounds = new global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds();
        }
        StableTranslationBounds.MergeFrom(other.StableTranslationBounds);
      }
      if (other.stableSimilarityBounds_ != null) {
        if (stableSimilarityBounds_ == null) {
          StableSimilarityBounds = new global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds();
        }
        StableSimilarityBounds.MergeFrom(other.StableSimilarityBounds);
      }
      if (other.stableHomographyBounds_ != null) {
        if (stableHomographyBounds_ == null) {
          StableHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds();
        }
        StableHomographyBounds.MergeFrom(other.StableHomographyBounds);
      }
      if (other.stableMixtureHomographyBounds_ != null) {
        if (stableMixtureHomographyBounds_ == null) {
          StableMixtureHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds();
        }
        StableMixtureHomographyBounds.MergeFrom(other.StableMixtureHomographyBounds);
      }
      if (other.HasStrictCoverageScale) {
        StrictCoverageScale = other.StrictCoverageScale;
      }
      if (other.HasLabelEmptyFramesAsValid) {
        LabelEmptyFramesAsValid = other.LabelEmptyFramesAsValid;
      }
      if (other.HasFeatureGridSize) {
        FeatureGridSize = other.FeatureGridSize;
      }
      if (other.HasSpatialSigma) {
        SpatialSigma = other.SpatialSigma;
      }
      if (other.HasTemporalIrlsDiameter) {
        TemporalIrlsDiameter = other.TemporalIrlsDiameter;
      }
      if (other.HasTemporalSigma) {
        TemporalSigma = other.TemporalSigma;
      }
      if (other.HasFeatureSigma) {
        FeatureSigma = other.FeatureSigma;
      }
      if (other.HasFilter5Taps) {
        Filter5Taps = other.Filter5Taps;
      }
      if (other.HasFrameConfidenceWeighting) {
        FrameConfidenceWeighting = other.FrameConfidenceWeighting;
      }
      if (other.HasResetConfidenceThreshold) {
        ResetConfidenceThreshold = other.ResetConfidenceThreshold;
      }
      if (other.HasIrlsWeightFilter) {
        IrlsWeightFilter = other.IrlsWeightFilter;
      }
      if (other.HasOverlayDetection) {
        OverlayDetection = other.OverlayDetection;
      }
      if (other.HasOverlayAnalysisChunkSize) {
        OverlayAnalysisChunkSize = other.OverlayAnalysisChunkSize;
      }
      if (other.overlayDetectionOptions_ != null) {
        if (overlayDetectionOptions_ == null) {
          OverlayDetectionOptions = new global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions();
        }
        OverlayDetectionOptions.MergeFrom(other.OverlayDetectionOptions);
      }
      if (other.shotBoundaryOptions_ != null) {
        if (shotBoundaryOptions_ == null) {
          ShotBoundaryOptions = new global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions();
        }
        ShotBoundaryOptions.MergeFrom(other.ShotBoundaryOptions);
      }
      if (other.HasOutputRefinedIrlsWeights) {
        OutputRefinedIrlsWeights = other.OutputRefinedIrlsWeights;
      }
      if (other.HasHomographyIrlsWeightInitialization) {
        HomographyIrlsWeightInitialization = other.HomographyIrlsWeightInitialization;
      }
      if (other.HasIrlsUseL0Norm) {
        IrlsUseL0Norm = other.IrlsUseL0Norm;
      }
      if (other.HasDomainLimitedIrlsScaling) {
        DomainLimitedIrlsScaling = other.DomainLimitedIrlsScaling;
      }
      if (other.HasDeactivateStableMotionEstimation) {
        DeactivateStableMotionEstimation = other.DeactivateStableMotionEstimation;
      }
      if (other.HasProjectValidMotionsDown) {
        ProjectValidMotionsDown = other.ProjectValidMotionsDown;
      }
      if (other.HasEstimateSimilarity) {
        EstimateSimilarity = other.EstimateSimilarity;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            EstimateTranslationIrls = input.ReadBool();
            break;
          }
          case 16: {
            EstimateSimilarity = input.ReadBool();
            break;
          }
          case 24: {
            LinearSimilarityEstimation = (global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation) input.ReadEnum();
            break;
          }
          case 40: {
            HomographyEstimation = (global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation) input.ReadEnum();
            break;
          }
          case 48: {
            UseOnlyLinSimInliersForHomography = input.ReadBool();
            break;
          }
          case 90: {
            if (stableHomographyBounds_ == null) {
              StableHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds();
            }
            input.ReadMessage(StableHomographyBounds);
            break;
          }
          case 96: {
            MixHomographyEstimation = (global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation) input.ReadEnum();
            break;
          }
          case 104: {
            NumMixtures = input.ReadInt32();
            break;
          }
          case 117: {
            MixtureRowSigma = input.ReadFloat();
            break;
          }
          case 125: {
            MixtureRegularizer = input.ReadFloat();
            break;
          }
          case 136: {
            IrlsRounds = input.ReadInt32();
            break;
          }
          case 165: {
            LinSimInlierThreshold = input.ReadFloat();
            break;
          }
          case 176: {
            LabelEmptyFramesAsValid = input.ReadBool();
            break;
          }
          case 184: {
            MixtureModelMode = (global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode) input.ReadEnum();
            break;
          }
          case 197: {
            FeatureGridSize = input.ReadFloat();
            break;
          }
          case 205: {
            SpatialSigma = input.ReadFloat();
            break;
          }
          case 208: {
            TemporalIrlsDiameter = input.ReadInt32();
            break;
          }
          case 221: {
            TemporalSigma = input.ReadFloat();
            break;
          }
          case 229: {
            FeatureSigma = input.ReadFloat();
            break;
          }
          case 232: {
            Filter5Taps = input.ReadBool();
            break;
          }
          case 240: {
            AffineEstimation = (global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation) input.ReadEnum();
            break;
          }
          case 253: {
            IrlsMotionMagnitudeFraction = input.ReadFloat();
            break;
          }
          case 258: {
            if (stableTranslationBounds_ == null) {
              StableTranslationBounds = new global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds();
            }
            input.ReadMessage(StableTranslationBounds);
            break;
          }
          case 266: {
            if (stableSimilarityBounds_ == null) {
              StableSimilarityBounds = new global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds();
            }
            input.ReadMessage(StableSimilarityBounds);
            break;
          }
          case 274: {
            if (stableMixtureHomographyBounds_ == null) {
              StableMixtureHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds();
            }
            input.ReadMessage(StableMixtureHomographyBounds);
            break;
          }
          case 280: {
            IrlsWeightFilter = (global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter) input.ReadEnum();
            break;
          }
          case 288: {
            OverlayDetection = input.ReadBool();
            break;
          }
          case 296: {
            OverlayAnalysisChunkSize = input.ReadInt32();
            break;
          }
          case 306: {
            if (overlayDetectionOptions_ == null) {
              OverlayDetectionOptions = new global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions();
            }
            input.ReadMessage(OverlayDetectionOptions);
            break;
          }
          case 312: {
            IrlsWeightsPreinitialized = input.ReadBool();
            break;
          }
          case 320: {
            OutputRefinedIrlsWeights = input.ReadBool();
            break;
          }
          case 333: {
            StrictCoverageScale = input.ReadFloat();
            break;
          }
          case 341: {
            MixtureRegularizerLevels = input.ReadFloat();
            break;
          }
          case 349: {
            MixtureRegularizerBase = input.ReadFloat();
            break;
          }
          case 352: {
            MixtureRsAnalysisLevel = input.ReadInt32();
            break;
          }
          case 360: {
            HomographyIrlsWeightInitialization = (global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization) input.ReadEnum();
            break;
          }
          case 368: {
            IrlsUseL0Norm = input.ReadBool();
            break;
          }
          case 376: {
            DeactivateStableMotionEstimation = input.ReadBool();
            break;
          }
          case 384: {
            FrameConfidenceWeighting = input.ReadBool();
            break;
          }
          case 397: {
            ResetConfidenceThreshold = input.ReadFloat();
            break;
          }
          case 405: {
            IrlsPriorScale = input.ReadFloat();
            break;
          }
          case 408: {
            CoverageGridSize = input.ReadInt32();
            break;
          }
          case 416: {
            ProjectValidMotionsDown = input.ReadBool();
            break;
          }
          case 424: {
            HomographyExactDenominatorScaling = input.ReadBool();
            break;
          }
          case 432: {
            UseExactHomographyEstimation = input.ReadBool();
            break;
          }
          case 440: {
            UseHighestAccuracyForNormalEquations = input.ReadBool();
            break;
          }
          case 450: {
            if (irlsInitialization_ == null) {
              IrlsInitialization = new global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization();
            }
            input.ReadMessage(IrlsInitialization);
            break;
          }
          case 458: {
            if (irlsMaskOptions_ == null) {
              IrlsMaskOptions = new global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions();
            }
            input.ReadMessage(IrlsMaskOptions);
            break;
          }
          case 464: {
            EstimationPolicy = (global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy) input.ReadEnum();
            break;
          }
          case 474: {
            if (jointTrackEstimation_ == null) {
              JointTrackEstimation = new global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions();
            }
            input.ReadMessage(JointTrackEstimation);
            break;
          }
          case 482: {
            if (shotBoundaryOptions_ == null) {
              ShotBoundaryOptions = new global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions();
            }
            input.ReadMessage(ShotBoundaryOptions);
            break;
          }
          case 493: {
            HomographyPerspectiveRegularizer = input.ReadFloat();
            break;
          }
          case 496: {
            FeatureDensityNormalization = input.ReadBool();
            break;
          }
          case 504: {
            FeatureMaskSize = input.ReadInt32();
            break;
          }
          case 514: {
            if (longFeatureBiasOptions_ == null) {
              LongFeatureBiasOptions = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions();
            }
            input.ReadMessage(LongFeatureBiasOptions);
            break;
          }
          case 520: {
            DomainLimitedIrlsScaling = input.ReadBool();
            break;
          }
          case 530: {
            if (longFeatureInitialization_ == null) {
              LongFeatureInitialization = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization();
            }
            input.ReadMessage(LongFeatureInitialization);
            break;
          }
          case 536: {
            FilterInitializedIrlsWeights = input.ReadBool();
            break;
          }
          case 549: {
            IrlsMixtureFractionScale = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            EstimateTranslationIrls = input.ReadBool();
            break;
          }
          case 16: {
            EstimateSimilarity = input.ReadBool();
            break;
          }
          case 24: {
            LinearSimilarityEstimation = (global::Mediapipe.MotionEstimationOptions.Types.LinearSimilarityEstimation) input.ReadEnum();
            break;
          }
          case 40: {
            HomographyEstimation = (global::Mediapipe.MotionEstimationOptions.Types.HomographyEstimation) input.ReadEnum();
            break;
          }
          case 48: {
            UseOnlyLinSimInliersForHomography = input.ReadBool();
            break;
          }
          case 90: {
            if (stableHomographyBounds_ == null) {
              StableHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.HomographyBounds();
            }
            input.ReadMessage(StableHomographyBounds);
            break;
          }
          case 96: {
            MixHomographyEstimation = (global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyEstimation) input.ReadEnum();
            break;
          }
          case 104: {
            NumMixtures = input.ReadInt32();
            break;
          }
          case 117: {
            MixtureRowSigma = input.ReadFloat();
            break;
          }
          case 125: {
            MixtureRegularizer = input.ReadFloat();
            break;
          }
          case 136: {
            IrlsRounds = input.ReadInt32();
            break;
          }
          case 165: {
            LinSimInlierThreshold = input.ReadFloat();
            break;
          }
          case 176: {
            LabelEmptyFramesAsValid = input.ReadBool();
            break;
          }
          case 184: {
            MixtureModelMode = (global::Mediapipe.MotionEstimationOptions.Types.MixtureModelMode) input.ReadEnum();
            break;
          }
          case 197: {
            FeatureGridSize = input.ReadFloat();
            break;
          }
          case 205: {
            SpatialSigma = input.ReadFloat();
            break;
          }
          case 208: {
            TemporalIrlsDiameter = input.ReadInt32();
            break;
          }
          case 221: {
            TemporalSigma = input.ReadFloat();
            break;
          }
          case 229: {
            FeatureSigma = input.ReadFloat();
            break;
          }
          case 232: {
            Filter5Taps = input.ReadBool();
            break;
          }
          case 240: {
            AffineEstimation = (global::Mediapipe.MotionEstimationOptions.Types.AffineEstimation) input.ReadEnum();
            break;
          }
          case 253: {
            IrlsMotionMagnitudeFraction = input.ReadFloat();
            break;
          }
          case 258: {
            if (stableTranslationBounds_ == null) {
              StableTranslationBounds = new global::Mediapipe.MotionEstimationOptions.Types.TranslationBounds();
            }
            input.ReadMessage(StableTranslationBounds);
            break;
          }
          case 266: {
            if (stableSimilarityBounds_ == null) {
              StableSimilarityBounds = new global::Mediapipe.MotionEstimationOptions.Types.SimilarityBounds();
            }
            input.ReadMessage(StableSimilarityBounds);
            break;
          }
          case 274: {
            if (stableMixtureHomographyBounds_ == null) {
              StableMixtureHomographyBounds = new global::Mediapipe.MotionEstimationOptions.Types.MixtureHomographyBounds();
            }
            input.ReadMessage(StableMixtureHomographyBounds);
            break;
          }
          case 280: {
            IrlsWeightFilter = (global::Mediapipe.MotionEstimationOptions.Types.IRLSWeightFilter) input.ReadEnum();
            break;
          }
          case 288: {
            OverlayDetection = input.ReadBool();
            break;
          }
          case 296: {
            OverlayAnalysisChunkSize = input.ReadInt32();
            break;
          }
          case 306: {
            if (overlayDetectionOptions_ == null) {
              OverlayDetectionOptions = new global::Mediapipe.MotionEstimationOptions.Types.OverlayDetectionOptions();
            }
            input.ReadMessage(OverlayDetectionOptions);
            break;
          }
          case 312: {
            IrlsWeightsPreinitialized = input.ReadBool();
            break;
          }
          case 320: {
            OutputRefinedIrlsWeights = input.ReadBool();
            break;
          }
          case 333: {
            StrictCoverageScale = input.ReadFloat();
            break;
          }
          case 341: {
            MixtureRegularizerLevels = input.ReadFloat();
            break;
          }
          case 349: {
            MixtureRegularizerBase = input.ReadFloat();
            break;
          }
          case 352: {
            MixtureRsAnalysisLevel = input.ReadInt32();
            break;
          }
          case 360: {
            HomographyIrlsWeightInitialization = (global::Mediapipe.MotionEstimationOptions.Types.HomographyIrlsWeightInitialization) input.ReadEnum();
            break;
          }
          case 368: {
            IrlsUseL0Norm = input.ReadBool();
            break;
          }
          case 376: {
            DeactivateStableMotionEstimation = input.ReadBool();
            break;
          }
          case 384: {
            FrameConfidenceWeighting = input.ReadBool();
            break;
          }
          case 397: {
            ResetConfidenceThreshold = input.ReadFloat();
            break;
          }
          case 405: {
            IrlsPriorScale = input.ReadFloat();
            break;
          }
          case 408: {
            CoverageGridSize = input.ReadInt32();
            break;
          }
          case 416: {
            ProjectValidMotionsDown = input.ReadBool();
            break;
          }
          case 424: {
            HomographyExactDenominatorScaling = input.ReadBool();
            break;
          }
          case 432: {
            UseExactHomographyEstimation = input.ReadBool();
            break;
          }
          case 440: {
            UseHighestAccuracyForNormalEquations = input.ReadBool();
            break;
          }
          case 450: {
            if (irlsInitialization_ == null) {
              IrlsInitialization = new global::Mediapipe.MotionEstimationOptions.Types.IrlsOutlierInitialization();
            }
            input.ReadMessage(IrlsInitialization);
            break;
          }
          case 458: {
            if (irlsMaskOptions_ == null) {
              IrlsMaskOptions = new global::Mediapipe.MotionEstimationOptions.Types.IrlsMaskOptions();
            }
            input.ReadMessage(IrlsMaskOptions);
            break;
          }
          case 464: {
            EstimationPolicy = (global::Mediapipe.MotionEstimationOptions.Types.EstimationPolicy) input.ReadEnum();
            break;
          }
          case 474: {
            if (jointTrackEstimation_ == null) {
              JointTrackEstimation = new global::Mediapipe.MotionEstimationOptions.Types.JointTrackEstimationOptions();
            }
            input.ReadMessage(JointTrackEstimation);
            break;
          }
          case 482: {
            if (shotBoundaryOptions_ == null) {
              ShotBoundaryOptions = new global::Mediapipe.MotionEstimationOptions.Types.ShotBoundaryOptions();
            }
            input.ReadMessage(ShotBoundaryOptions);
            break;
          }
          case 493: {
            HomographyPerspectiveRegularizer = input.ReadFloat();
            break;
          }
          case 496: {
            FeatureDensityNormalization = input.ReadBool();
            break;
          }
          case 504: {
            FeatureMaskSize = input.ReadInt32();
            break;
          }
          case 514: {
            if (longFeatureBiasOptions_ == null) {
              LongFeatureBiasOptions = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureBiasOptions();
            }
            input.ReadMessage(LongFeatureBiasOptions);
            break;
          }
          case 520: {
            DomainLimitedIrlsScaling = input.ReadBool();
            break;
          }
          case 530: {
            if (longFeatureInitialization_ == null) {
              LongFeatureInitialization = new global::Mediapipe.MotionEstimationOptions.Types.LongFeatureInitialization();
            }
            input.ReadMessage(LongFeatureInitialization);
            break;
          }
          case 536: {
            FilterInitializedIrlsWeights = input.ReadBool();
            break;
          }
          case 549: {
            IrlsMixtureFractionScale = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<MotionEstimationOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<MotionEstimationOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<MotionEstimationOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<MotionEstimationOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<MotionEstimationOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<MotionEstimationOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<MotionEstimationOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MotionEstimationOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum LinearSimilarityEstimation {
        [pbr::OriginalName("ESTIMATION_LS_NONE")] EstimationLsNone = 0,
        /// <summary>
        /// L2 estimation
        /// </summary>
        [pbr::OriginalName("ESTIMATION_LS_L2")] EstimationLsL2 = 1,
        /// <summary>
        /// good performance, robust to outliers.
        /// </summary>
        [pbr::OriginalName("ESTIMATION_LS_IRLS")] EstimationLsIrls = 4,
        /// <summary>
        /// DEPRECATED modes.
        /// </summary>
        [pbr::OriginalName("ESTIMATION_LS_L2_RANSAC")] EstimationLsL2Ransac = 2,
        /// <summary>
        /// DEPRECATED, use IRLS instead, or static
        /// </summary>
        [pbr::OriginalName("ESTIMATION_LS_L1")] EstimationLsL1 = 3,
      }

      public enum AffineEstimation {
        [pbr::OriginalName("ESTIMATION_AFFINE_NONE")] EstimationAffineNone = 0,
        [pbr::OriginalName("ESTIMATION_AFFINE_L2")] EstimationAffineL2 = 1,
        [pbr::OriginalName("ESTIMATION_AFFINE_IRLS")] EstimationAffineIrls = 2,
      }

      public enum HomographyEstimation {
        [pbr::OriginalName("ESTIMATION_HOMOG_NONE")] EstimationHomogNone = 0,
        [pbr::OriginalName("ESTIMATION_HOMOG_L2")] EstimationHomogL2 = 1,
        [pbr::OriginalName("ESTIMATION_HOMOG_IRLS")] EstimationHomogIrls = 2,
      }

      /// <summary>
      /// Note: Mixture models have high DOF are much more affected by outliers
      /// than models above. It is recommended that if IRLS estimation is NOT used,
      /// that mixture_regularizer is increased by a factor >=3.
      /// </summary>
      public enum MixtureHomographyEstimation {
        [pbr::OriginalName("ESTIMATION_HOMOG_MIX_NONE")] EstimationHomogMixNone = 0,
        [pbr::OriginalName("ESTIMATION_HOMOG_MIX_L2")] EstimationHomogMixL2 = 1,
        /// <summary>
        /// robust to outliers.
        /// </summary>
        [pbr::OriginalName("ESTIMATION_HOMOG_MIX_IRLS")] EstimationHomogMixIrls = 2,
      }

      /// <summary>
      /// Controls how multiple models via EstimateMotionsParallel are estimated.
      /// </summary>
      public enum EstimationPolicy {
        /// <summary>
        /// Models are estimated independently across
        /// </summary>
        [pbr::OriginalName("INDEPENDENT_PARALLEL")] IndependentParallel = 1,
        /// <summary>
        /// frames in parallel.
        /// </summary>
        [pbr::OriginalName("TEMPORAL_IRLS_MASK")] TemporalIrlsMask = 2,
        /// <summary>
        /// current one, controlled via above
        /// IrlsMaskOptions.
        /// </summary>
        [pbr::OriginalName("TEMPORAL_LONG_FEATURE_BIAS")] TemporalLongFeatureBias = 4,
        /// <summary>
        /// long features, controlled via above
        /// LongFeatureBiasOptions.
        /// </summary>
        [pbr::OriginalName("JOINTLY_FROM_TRACKS")] JointlyFromTracks = 3,
      }

      /// <summary>
      /// Degree of freedom of estimated homography mixtures. If desired, specific
      /// parts of the homography can be held constant across the mixture.
      /// For fast draft TRANSLATION_MIXTURE is recommended, for high quality
      /// SKEW_ROTATION_MIXTURE.
      /// </summary>
      public enum MixtureModelMode {
        /// <summary>
        /// 8 dof * num_mixtures
        /// </summary>
        [pbr::OriginalName("FULL_MIXTURE")] FullMixture = 0,
        /// <summary>
        /// 6 dof + 2 dof * num_mixtures
        /// </summary>
        [pbr::OriginalName("TRANSLATION_MIXTURE")] TranslationMixture = 1,
        /// <summary>
        /// 4 dof + 4 dof * num_mixtures
        /// </summary>
        [pbr::OriginalName("SKEW_ROTATION_MIXTURE")] SkewRotationMixture = 2,
      }

      /// <summary>
      /// Filters irls weights before smoothing them according to specified
      /// operation.
      /// </summary>
      public enum IRLSWeightFilter {
        [pbr::OriginalName("IRLS_FILTER_NONE")] IrlsFilterNone = 0,
        [pbr::OriginalName("IRLS_FILTER_TEXTURE")] IrlsFilterTexture = 1,
        [pbr::OriginalName("IRLS_FILTER_CORNER_RESPONSE")] IrlsFilterCornerResponse = 2,
      }

      /// <summary>
      /// Weight initialization for homography estimation. This is to bias homography
      /// estimation either to foreground or background.
      /// </summary>
      public enum HomographyIrlsWeightInitialization {
        /// <summary>
        /// Constant, treat all features equally.
        /// </summary>
        [pbr::OriginalName("IRLS_WEIGHT_CONSTANT_ONE")] IrlsWeightConstantOne = 1,
        /// <summary>
        /// Weight features in the center higher.
        /// </summary>
        [pbr::OriginalName("IRLS_WEIGHT_CENTER_GAUSSIAN")] IrlsWeightCenterGaussian = 2,
        /// <summary>
        /// Tends to lock onto foreground.
        /// </summary>
        [pbr::OriginalName("IRLS_WEIGHT_PERIMETER_GAUSSIAN")] IrlsWeightPerimeterGaussian = 3,
      }

      /// <summary>
      /// If activated, irls weight of outlier features are reset. Outliers are
      /// defined as those features, for which the best model fit after #rounds
      /// iterations of RANSAC did NOT yield an error lower than cutoff.
      /// Only applies to translation and similarity estimation.
      /// </summary>
      public sealed partial class IrlsOutlierInitialization : pb::IMessage<IrlsOutlierInitialization>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<IrlsOutlierInitialization> _parser = new pb::MessageParser<IrlsOutlierInitialization>(() => new IrlsOutlierInitialization());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<IrlsOutlierInitialization> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsOutlierInitialization() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsOutlierInitialization(IrlsOutlierInitialization other) : this() {
          _hasBits0 = other._hasBits0;
          activated_ = other.activated_;
          rounds_ = other.rounds_;
          cutoff_ = other.cutoff_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsOutlierInitialization Clone() {
          return new IrlsOutlierInitialization(this);
        }

        /// <summary>Field number for the "activated" field.</summary>
        public const int ActivatedFieldNumber = 1;
        private readonly static bool ActivatedDefaultValue = false;

        private bool activated_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Activated {
          get { if ((_hasBits0 & 1) != 0) { return activated_; } else { return ActivatedDefaultValue; } }
          set {
            _hasBits0 |= 1;
            activated_ = value;
          }
        }
        /// <summary>Gets whether the "activated" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasActivated {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "activated" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearActivated() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "rounds" field.</summary>
        public const int RoundsFieldNumber = 2;
        private readonly static int RoundsDefaultValue = 100;

        private int rounds_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Rounds {
          get { if ((_hasBits0 & 2) != 0) { return rounds_; } else { return RoundsDefaultValue; } }
          set {
            _hasBits0 |= 2;
            rounds_ = value;
          }
        }
        /// <summary>Gets whether the "rounds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRounds {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "rounds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRounds() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "cutoff" field.</summary>
        public const int CutoffFieldNumber = 3;
        private readonly static float CutoffDefaultValue = 0.003F;

        private float cutoff_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Cutoff {
          get { if ((_hasBits0 & 4) != 0) { return cutoff_; } else { return CutoffDefaultValue; } }
          set {
            _hasBits0 |= 4;
            cutoff_ = value;
          }
        }
        /// <summary>Gets whether the "cutoff" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCutoff {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "cutoff" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCutoff() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as IrlsOutlierInitialization);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(IrlsOutlierInitialization other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Activated != other.Activated) return false;
          if (Rounds != other.Rounds) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Cutoff, other.Cutoff)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasActivated) hash ^= Activated.GetHashCode();
          if (HasRounds) hash ^= Rounds.GetHashCode();
          if (HasCutoff) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Cutoff);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasActivated) {
            output.WriteRawTag(8);
            output.WriteBool(Activated);
          }
          if (HasRounds) {
            output.WriteRawTag(16);
            output.WriteInt32(Rounds);
          }
          if (HasCutoff) {
            output.WriteRawTag(29);
            output.WriteFloat(Cutoff);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasActivated) {
            output.WriteRawTag(8);
            output.WriteBool(Activated);
          }
          if (HasRounds) {
            output.WriteRawTag(16);
            output.WriteInt32(Rounds);
          }
          if (HasCutoff) {
            output.WriteRawTag(29);
            output.WriteFloat(Cutoff);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasActivated) {
            size += 1 + 1;
          }
          if (HasRounds) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Rounds);
          }
          if (HasCutoff) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(IrlsOutlierInitialization other) {
          if (other == null) {
            return;
          }
          if (other.HasActivated) {
            Activated = other.Activated;
          }
          if (other.HasRounds) {
            Rounds = other.Rounds;
          }
          if (other.HasCutoff) {
            Cutoff = other.Cutoff;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Activated = input.ReadBool();
                break;
              }
              case 16: {
                Rounds = input.ReadInt32();
                break;
              }
              case 29: {
                Cutoff = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Activated = input.ReadBool();
                break;
              }
              case 16: {
                Rounds = input.ReadInt32();
                break;
              }
              case 29: {
                Cutoff = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// In addition to above outlier and density initialization, long features
      /// that are present for a specified ratio of the analysis interval can be
      /// upweighted. This greatly improves temporal consistency.
      /// </summary>
      public sealed partial class LongFeatureInitialization : pb::IMessage<LongFeatureInitialization>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LongFeatureInitialization> _parser = new pb::MessageParser<LongFeatureInitialization>(() => new LongFeatureInitialization());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LongFeatureInitialization> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureInitialization() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureInitialization(LongFeatureInitialization other) : this() {
          _hasBits0 = other._hasBits0;
          activated_ = other.activated_;
          minLengthPercentile_ = other.minLengthPercentile_;
          upweightMultiplier_ = other.upweightMultiplier_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureInitialization Clone() {
          return new LongFeatureInitialization(this);
        }

        /// <summary>Field number for the "activated" field.</summary>
        public const int ActivatedFieldNumber = 1;
        private readonly static bool ActivatedDefaultValue = false;

        private bool activated_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Activated {
          get { if ((_hasBits0 & 1) != 0) { return activated_; } else { return ActivatedDefaultValue; } }
          set {
            _hasBits0 |= 1;
            activated_ = value;
          }
        }
        /// <summary>Gets whether the "activated" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasActivated {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "activated" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearActivated() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "min_length_percentile" field.</summary>
        public const int MinLengthPercentileFieldNumber = 2;
        private readonly static float MinLengthPercentileDefaultValue = 0.95F;

        private float minLengthPercentile_;
        /// <summary>
        /// Tracks with a length greater of equal to the specified percentile
        /// are upweighted by the specified upweight_multiplier.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinLengthPercentile {
          get { if ((_hasBits0 & 2) != 0) { return minLengthPercentile_; } else { return MinLengthPercentileDefaultValue; } }
          set {
            _hasBits0 |= 2;
            minLengthPercentile_ = value;
          }
        }
        /// <summary>Gets whether the "min_length_percentile" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinLengthPercentile {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "min_length_percentile" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinLengthPercentile() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "upweight_multiplier" field.</summary>
        public const int UpweightMultiplierFieldNumber = 3;
        private readonly static float UpweightMultiplierDefaultValue = 5F;

        private float upweightMultiplier_;
        /// <summary>
        /// Features passing above test have their irls weight increased by the
        /// specified multiplier prior to estimation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float UpweightMultiplier {
          get { if ((_hasBits0 & 4) != 0) { return upweightMultiplier_; } else { return UpweightMultiplierDefaultValue; } }
          set {
            _hasBits0 |= 4;
            upweightMultiplier_ = value;
          }
        }
        /// <summary>Gets whether the "upweight_multiplier" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUpweightMultiplier {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "upweight_multiplier" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUpweightMultiplier() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LongFeatureInitialization);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LongFeatureInitialization other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Activated != other.Activated) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinLengthPercentile, other.MinLengthPercentile)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(UpweightMultiplier, other.UpweightMultiplier)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasActivated) hash ^= Activated.GetHashCode();
          if (HasMinLengthPercentile) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinLengthPercentile);
          if (HasUpweightMultiplier) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(UpweightMultiplier);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasActivated) {
            output.WriteRawTag(8);
            output.WriteBool(Activated);
          }
          if (HasMinLengthPercentile) {
            output.WriteRawTag(21);
            output.WriteFloat(MinLengthPercentile);
          }
          if (HasUpweightMultiplier) {
            output.WriteRawTag(29);
            output.WriteFloat(UpweightMultiplier);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasActivated) {
            output.WriteRawTag(8);
            output.WriteBool(Activated);
          }
          if (HasMinLengthPercentile) {
            output.WriteRawTag(21);
            output.WriteFloat(MinLengthPercentile);
          }
          if (HasUpweightMultiplier) {
            output.WriteRawTag(29);
            output.WriteFloat(UpweightMultiplier);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasActivated) {
            size += 1 + 1;
          }
          if (HasMinLengthPercentile) {
            size += 1 + 4;
          }
          if (HasUpweightMultiplier) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LongFeatureInitialization other) {
          if (other == null) {
            return;
          }
          if (other.HasActivated) {
            Activated = other.Activated;
          }
          if (other.HasMinLengthPercentile) {
            MinLengthPercentile = other.MinLengthPercentile;
          }
          if (other.HasUpweightMultiplier) {
            UpweightMultiplier = other.UpweightMultiplier;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Activated = input.ReadBool();
                break;
              }
              case 21: {
                MinLengthPercentile = input.ReadFloat();
                break;
              }
              case 29: {
                UpweightMultiplier = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Activated = input.ReadBool();
                break;
              }
              case 21: {
                MinLengthPercentile = input.ReadFloat();
                break;
              }
              case 29: {
                UpweightMultiplier = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Irls initialization can be performed in a temporal depdent manner,
      /// (if estimation_policy() == TEMPORALLY_DEPENDENT), where
      /// the previous frame's motion estimation biases the IrlsInitialization of the
      /// currently processed frame. In particular the location and magnitude of
      /// inliers is used during the RANSAC selection stage, to favor those features
      /// that agree with the prior, represented as confidence mask of inliers
      /// (using same dimension as above feature_mask_size).
      /// After estimation, the prior is updated.
      /// </summary>
      public sealed partial class IrlsMaskOptions : pb::IExtendableMessage<IrlsMaskOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<IrlsMaskOptions> _parser = new pb::MessageParser<IrlsMaskOptions>(() => new IrlsMaskOptions());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<IrlsMaskOptions> _extensions;
        private pb::ExtensionSet<IrlsMaskOptions> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<IrlsMaskOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsMaskOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsMaskOptions(IrlsMaskOptions other) : this() {
          _hasBits0 = other._hasBits0;
          decay_ = other.decay_;
          inlierScore_ = other.inlierScore_;
          baseScore_ = other.baseScore_;
          minTranslationNorm_ = other.minTranslationNorm_;
          translationBlendAlpha_ = other.translationBlendAlpha_;
          translationPriorIncrease_ = other.translationPriorIncrease_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IrlsMaskOptions Clone() {
          return new IrlsMaskOptions(this);
        }

        /// <summary>Field number for the "decay" field.</summary>
        public const int DecayFieldNumber = 2;
        private readonly static float DecayDefaultValue = 0.7F;

        private float decay_;
        /// <summary>
        /// Amount prior is decayed after each iteration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float Decay {
          get { if ((_hasBits0 & 1) != 0) { return decay_; } else { return DecayDefaultValue; } }
          set {
            _hasBits0 |= 1;
            decay_ = value;
          }
        }
        /// <summary>Gets whether the "decay" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDecay {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "decay" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDecay() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "inlier_score" field.</summary>
        public const int InlierScoreFieldNumber = 3;
        private readonly static float InlierScoreDefaultValue = 0.4F;

        private float inlierScore_;
        /// <summary>
        /// Score that each inlier adds to the current prior. Specified w.r.t. total
        /// number of features, i.e. each feature increases a bins score by
        /// inlier_score.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float InlierScore {
          get { if ((_hasBits0 & 2) != 0) { return inlierScore_; } else { return InlierScoreDefaultValue; } }
          set {
            _hasBits0 |= 2;
            inlierScore_ = value;
          }
        }
        /// <summary>Gets whether the "inlier_score" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInlierScore {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "inlier_score" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInlierScore() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "base_score" field.</summary>
        public const int BaseScoreFieldNumber = 4;
        private readonly static float BaseScoreDefaultValue = 0.2F;

        private float baseScore_;
        /// <summary>
        /// Each inlier scores at least this value regardless of the inlier mask
        /// (additive).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float BaseScore {
          get { if ((_hasBits0 & 4) != 0) { return baseScore_; } else { return BaseScoreDefaultValue; } }
          set {
            _hasBits0 |= 4;
            baseScore_ = value;
          }
        }
        /// <summary>Gets whether the "base_score" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBaseScore {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "base_score" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBaseScore() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "min_translation_norm" field.</summary>
        public const int MinTranslationNormFieldNumber = 5;
        private readonly static float MinTranslationNormDefaultValue = 0.002F;

        private float minTranslationNorm_;
        /// <summary>
        /// Motions are scored relative to previous motion. Threshold denotes
        /// absolute minimum of denominator.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinTranslationNorm {
          get { if ((_hasBits0 & 8) != 0) { return minTranslationNorm_; } else { return MinTranslationNormDefaultValue; } }
          set {
            _hasBits0 |= 8;
            minTranslationNorm_ = value;
          }
        }
        /// <summary>Gets whether the "min_translation_norm" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinTranslationNorm {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "min_translation_norm" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinTranslationNorm() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "translation_blend_alpha" field.</summary>
        public const int TranslationBlendAlphaFieldNumber = 6;
        private readonly static float TranslationBlendAlphaDefaultValue = 0.7F;

        private float translationBlendAlpha_;
        /// <summary>
        /// Translation is updated in every step by blending it with the previous
        /// estimated translation. (alpha is within 0 to 1, where 0 indicates to use
        /// only measured translation, i.e. no blending).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float TranslationBlendAlpha {
          get { if ((_hasBits0 & 16) != 0) { return translationBlendAlpha_; } else { return TranslationBlendAlphaDefaultValue; } }
          set {
            _hasBits0 |= 16;
            translationBlendAlpha_ = value;
          }
        }
        /// <summary>Gets whether the "translation_blend_alpha" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTranslationBlendAlpha {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "translation_blend_alpha" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTranslationBlendAlpha() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "translation_prior_increase" field.</summary>
        public const int TranslationPriorIncreaseFieldNumber = 7;
        private readonly static float TranslationPriorIncreaseDefaultValue = 0.2F;

        private float translationPriorIncrease_;
        /// <summary>
        /// Every time translation is updated, prior (in [0, 1]) is increased by the
        /// specified amount.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float TranslationPriorIncrease {
          get { if ((_hasBits0 & 32) != 0) { return translationPriorIncrease_; } else { return TranslationPriorIncreaseDefaultValue; } }
          set {
            _hasBits0 |= 32;
            translationPriorIncrease_ = value;
          }
        }
        /// <summary>Gets whether the "translation_prior_increase" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTranslationPriorIncrease {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "translation_prior_increase" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTranslationPriorIncrease() {
          _hasBits0 &= ~32;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as IrlsMaskOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(IrlsMaskOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Decay, other.Decay)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InlierScore, other.InlierScore)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BaseScore, other.BaseScore)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinTranslationNorm, other.MinTranslationNorm)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TranslationBlendAlpha, other.TranslationBlendAlpha)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TranslationPriorIncrease, other.TranslationPriorIncrease)) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasDecay) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Decay);
          if (HasInlierScore) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InlierScore);
          if (HasBaseScore) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BaseScore);
          if (HasMinTranslationNorm) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinTranslationNorm);
          if (HasTranslationBlendAlpha) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TranslationBlendAlpha);
          if (HasTranslationPriorIncrease) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TranslationPriorIncrease);
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasDecay) {
            output.WriteRawTag(21);
            output.WriteFloat(Decay);
          }
          if (HasInlierScore) {
            output.WriteRawTag(29);
            output.WriteFloat(InlierScore);
          }
          if (HasBaseScore) {
            output.WriteRawTag(37);
            output.WriteFloat(BaseScore);
          }
          if (HasMinTranslationNorm) {
            output.WriteRawTag(45);
            output.WriteFloat(MinTranslationNorm);
          }
          if (HasTranslationBlendAlpha) {
            output.WriteRawTag(53);
            output.WriteFloat(TranslationBlendAlpha);
          }
          if (HasTranslationPriorIncrease) {
            output.WriteRawTag(61);
            output.WriteFloat(TranslationPriorIncrease);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasDecay) {
            output.WriteRawTag(21);
            output.WriteFloat(Decay);
          }
          if (HasInlierScore) {
            output.WriteRawTag(29);
            output.WriteFloat(InlierScore);
          }
          if (HasBaseScore) {
            output.WriteRawTag(37);
            output.WriteFloat(BaseScore);
          }
          if (HasMinTranslationNorm) {
            output.WriteRawTag(45);
            output.WriteFloat(MinTranslationNorm);
          }
          if (HasTranslationBlendAlpha) {
            output.WriteRawTag(53);
            output.WriteFloat(TranslationBlendAlpha);
          }
          if (HasTranslationPriorIncrease) {
            output.WriteRawTag(61);
            output.WriteFloat(TranslationPriorIncrease);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasDecay) {
            size += 1 + 4;
          }
          if (HasInlierScore) {
            size += 1 + 4;
          }
          if (HasBaseScore) {
            size += 1 + 4;
          }
          if (HasMinTranslationNorm) {
            size += 1 + 4;
          }
          if (HasTranslationBlendAlpha) {
            size += 1 + 4;
          }
          if (HasTranslationPriorIncrease) {
            size += 1 + 4;
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(IrlsMaskOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasDecay) {
            Decay = other.Decay;
          }
          if (other.HasInlierScore) {
            InlierScore = other.InlierScore;
          }
          if (other.HasBaseScore) {
            BaseScore = other.BaseScore;
          }
          if (other.HasMinTranslationNorm) {
            MinTranslationNorm = other.MinTranslationNorm;
          }
          if (other.HasTranslationBlendAlpha) {
            TranslationBlendAlpha = other.TranslationBlendAlpha;
          }
          if (other.HasTranslationPriorIncrease) {
            TranslationPriorIncrease = other.TranslationPriorIncrease;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 21: {
                Decay = input.ReadFloat();
                break;
              }
              case 29: {
                InlierScore = input.ReadFloat();
                break;
              }
              case 37: {
                BaseScore = input.ReadFloat();
                break;
              }
              case 45: {
                MinTranslationNorm = input.ReadFloat();
                break;
              }
              case 53: {
                TranslationBlendAlpha = input.ReadFloat();
                break;
              }
              case 61: {
                TranslationPriorIncrease = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 21: {
                Decay = input.ReadFloat();
                break;
              }
              case 29: {
                InlierScore = input.ReadFloat();
                break;
              }
              case 37: {
                BaseScore = input.ReadFloat();
                break;
              }
              case 45: {
                MinTranslationNorm = input.ReadFloat();
                break;
              }
              case 53: {
                TranslationBlendAlpha = input.ReadFloat();
                break;
              }
              case 61: {
                TranslationPriorIncrease = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<IrlsMaskOptions, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<IrlsMaskOptions, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<IrlsMaskOptions, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<IrlsMaskOptions, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<IrlsMaskOptions, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<IrlsMaskOptions, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<IrlsMaskOptions, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

      /// <summary>
      /// Describes how long feature tracks are leveraged for joint estimation across
      /// many frames.
      /// </summary>
      public sealed partial class JointTrackEstimationOptions : pb::IMessage<JointTrackEstimationOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<JointTrackEstimationOptions> _parser = new pb::MessageParser<JointTrackEstimationOptions>(() => new JointTrackEstimationOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<JointTrackEstimationOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public JointTrackEstimationOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public JointTrackEstimationOptions(JointTrackEstimationOptions other) : this() {
          _hasBits0 = other._hasBits0;
          numMotionModels_ = other.numMotionModels_;
          motionStride_ = other.motionStride_;
          temporalSmoothing_ = other.temporalSmoothing_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public JointTrackEstimationOptions Clone() {
          return new JointTrackEstimationOptions(this);
        }

        /// <summary>Field number for the "num_motion_models" field.</summary>
        public const int NumMotionModelsFieldNumber = 1;
        private readonly static int NumMotionModelsDefaultValue = 3;

        private int numMotionModels_;
        /// <summary>
        /// For each frame-pair motion model, describing the motion between frame
        /// I and I - 1, estimate in addition several additional motion
        /// models along long feature tracks describing the motion between frame
        /// I and I - k * motion_stride (additional models are not output,
        /// but help to filter irls weights).
        /// Specifies total number of estimated motion models per frame-pair. Must be
        /// greater than zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int NumMotionModels {
          get { if ((_hasBits0 & 1) != 0) { return numMotionModels_; } else { return NumMotionModelsDefaultValue; } }
          set {
            _hasBits0 |= 1;
            numMotionModels_ = value;
          }
        }
        /// <summary>Gets whether the "num_motion_models" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasNumMotionModels {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "num_motion_models" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearNumMotionModels() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "motion_stride" field.</summary>
        public const int MotionStrideFieldNumber = 2;
        private readonly static int MotionStrideDefaultValue = 15;

        private int motionStride_;
        /// <summary>
        /// Spacing in frames for additional motion models.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MotionStride {
          get { if ((_hasBits0 & 2) != 0) { return motionStride_; } else { return MotionStrideDefaultValue; } }
          set {
            _hasBits0 |= 2;
            motionStride_ = value;
          }
        }
        /// <summary>Gets whether the "motion_stride" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMotionStride {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "motion_stride" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMotionStride() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "temporal_smoothing" field.</summary>
        public const int TemporalSmoothingFieldNumber = 3;
        private readonly static bool TemporalSmoothingDefaultValue = false;

        private bool temporalSmoothing_;
        /// <summary>
        /// If set, performs temporal smoothing across frames of the obtained irls
        /// weights.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool TemporalSmoothing {
          get { if ((_hasBits0 & 4) != 0) { return temporalSmoothing_; } else { return TemporalSmoothingDefaultValue; } }
          set {
            _hasBits0 |= 4;
            temporalSmoothing_ = value;
          }
        }
        /// <summary>Gets whether the "temporal_smoothing" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTemporalSmoothing {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "temporal_smoothing" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTemporalSmoothing() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as JointTrackEstimationOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(JointTrackEstimationOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (NumMotionModels != other.NumMotionModels) return false;
          if (MotionStride != other.MotionStride) return false;
          if (TemporalSmoothing != other.TemporalSmoothing) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasNumMotionModels) hash ^= NumMotionModels.GetHashCode();
          if (HasMotionStride) hash ^= MotionStride.GetHashCode();
          if (HasTemporalSmoothing) hash ^= TemporalSmoothing.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasNumMotionModels) {
            output.WriteRawTag(8);
            output.WriteInt32(NumMotionModels);
          }
          if (HasMotionStride) {
            output.WriteRawTag(16);
            output.WriteInt32(MotionStride);
          }
          if (HasTemporalSmoothing) {
            output.WriteRawTag(24);
            output.WriteBool(TemporalSmoothing);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasNumMotionModels) {
            output.WriteRawTag(8);
            output.WriteInt32(NumMotionModels);
          }
          if (HasMotionStride) {
            output.WriteRawTag(16);
            output.WriteInt32(MotionStride);
          }
          if (HasTemporalSmoothing) {
            output.WriteRawTag(24);
            output.WriteBool(TemporalSmoothing);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasNumMotionModels) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumMotionModels);
          }
          if (HasMotionStride) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MotionStride);
          }
          if (HasTemporalSmoothing) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(JointTrackEstimationOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasNumMotionModels) {
            NumMotionModels = other.NumMotionModels;
          }
          if (other.HasMotionStride) {
            MotionStride = other.MotionStride;
          }
          if (other.HasTemporalSmoothing) {
            TemporalSmoothing = other.TemporalSmoothing;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                NumMotionModels = input.ReadInt32();
                break;
              }
              case 16: {
                MotionStride = input.ReadInt32();
                break;
              }
              case 24: {
                TemporalSmoothing = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                NumMotionModels = input.ReadInt32();
                break;
              }
              case 16: {
                MotionStride = input.ReadInt32();
                break;
              }
              case 24: {
                TemporalSmoothing = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Options being used to bias IRLS features if estimation mode
      /// TEMPORAL_LONG_FEATURE_BIAS is being used.
      /// Next Tag: 15
      /// </summary>
      public sealed partial class LongFeatureBiasOptions : pb::IMessage<LongFeatureBiasOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LongFeatureBiasOptions> _parser = new pb::MessageParser<LongFeatureBiasOptions>(() => new LongFeatureBiasOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LongFeatureBiasOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureBiasOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureBiasOptions(LongFeatureBiasOptions other) : this() {
          _hasBits0 = other._hasBits0;
          totalRounds_ = other.totalRounds_;
          inlierBias_ = other.inlierBias_;
          outlierBias_ = other.outlierBias_;
          numIrlsObservations_ = other.numIrlsObservations_;
          maxIrlsChangeRatio_ = other.maxIrlsChangeRatio_;
          inlierIrlsWeight_ = other.inlierIrlsWeight_;
          biasStdev_ = other.biasStdev_;
          useSpatialBias_ = other.useSpatialBias_;
          gridSize_ = other.gridSize_;
          spatialSigma_ = other.spatialSigma_;
          colorSigma_ = other.colorSigma_;
          longTrackThreshold_ = other.longTrackThreshold_;
          longTrackConfidenceFraction_ = other.longTrackConfidenceFraction_;
          seedPriorsFromBias_ = other.seedPriorsFromBias_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LongFeatureBiasOptions Clone() {
          return new LongFeatureBiasOptions(this);
        }

        /// <summary>Field number for the "total_rounds" field.</summary>
        public const int TotalRoundsFieldNumber = 13;
        private readonly static int TotalRoundsDefaultValue = 1;

        private int totalRounds_;
        /// <summary>
        /// Estimation is performed multiple times, alternating between model
        /// estimation and smooth temporal feature biasing for the specified number
        /// of rounds.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int TotalRounds {
          get { if ((_hasBits0 & 4096) != 0) { return totalRounds_; } else { return TotalRoundsDefaultValue; } }
          set {
            _hasBits0 |= 4096;
            totalRounds_ = value;
          }
        }
        /// <summary>Gets whether the "total_rounds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTotalRounds {
          get { return (_hasBits0 & 4096) != 0; }
        }
        /// <summary>Clears the value of the "total_rounds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTotalRounds() {
          _hasBits0 &= ~4096;
        }

        /// <summary>Field number for the "inlier_bias" field.</summary>
        public const int InlierBiasFieldNumber = 1;
        private readonly static float InlierBiasDefaultValue = 0.98F;

        private float inlierBias_;
        /// <summary>
        /// Controls how fast the bias for a track gets updated, in case feature is
        /// an inlier. Use higher values for less decay of background motion over
        /// time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float InlierBias {
          get { if ((_hasBits0 & 1) != 0) { return inlierBias_; } else { return InlierBiasDefaultValue; } }
          set {
            _hasBits0 |= 1;
            inlierBias_ = value;
          }
        }
        /// <summary>Gets whether the "inlier_bias" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInlierBias {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "inlier_bias" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInlierBias() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "outlier_bias" field.</summary>
        public const int OutlierBiasFieldNumber = 2;
        private readonly static float OutlierBiasDefaultValue = 0.7F;

        private float outlierBias_;
        /// <summary>
        /// Same as above for outliers (or features with low prior), i.e those that
        /// got recently seeded.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float OutlierBias {
          get { if ((_hasBits0 & 2) != 0) { return outlierBias_; } else { return OutlierBiasDefaultValue; } }
          set {
            _hasBits0 |= 2;
            outlierBias_ = value;
          }
        }
        /// <summary>Gets whether the "outlier_bias" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOutlierBias {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "outlier_bias" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOutlierBias() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "num_irls_observations" field.</summary>
        public const int NumIrlsObservationsFieldNumber = 3;
        private readonly static int NumIrlsObservationsDefaultValue = 10;

        private int numIrlsObservations_;
        /// <summary>
        /// Number of elements after which we deem estimation to be stable.
        /// Used to control weight of bias if fewer than the specified number have
        /// been observed. Also used as maximum ring buffer size (only most recent
        /// number of observations are kept). Must be > 0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int NumIrlsObservations {
          get { if ((_hasBits0 & 4) != 0) { return numIrlsObservations_; } else { return NumIrlsObservationsDefaultValue; } }
          set {
            _hasBits0 |= 4;
            numIrlsObservations_ = value;
          }
        }
        /// <summary>Gets whether the "num_irls_observations" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasNumIrlsObservations {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "num_irls_observations" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearNumIrlsObservations() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "max_irls_change_ratio" field.</summary>
        public const int MaxIrlsChangeRatioFieldNumber = 4;
        private readonly static float MaxIrlsChangeRatioDefaultValue = 10F;

        private float maxIrlsChangeRatio_;
        /// <summary>
        /// Change in irls weight magnitude (from outlier to inlier) above which we
        /// reset the current bias.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MaxIrlsChangeRatio {
          get { if ((_hasBits0 & 8) != 0) { return maxIrlsChangeRatio_; } else { return MaxIrlsChangeRatioDefaultValue; } }
          set {
            _hasBits0 |= 8;
            maxIrlsChangeRatio_ = value;
          }
        }
        /// <summary>Gets whether the "max_irls_change_ratio" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxIrlsChangeRatio {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "max_irls_change_ratio" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxIrlsChangeRatio() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "inlier_irls_weight" field.</summary>
        public const int InlierIrlsWeightFieldNumber = 5;
        private readonly static float InlierIrlsWeightDefaultValue = 0.2F;

        private float inlierIrlsWeight_;
        /// <summary>
        /// Irls weight above which we consider it to be an inlier for bias update
        /// purposes (see above inlier and outlier bias). By default, outliers are
        /// allowed to update their bias faster than inliers. Must be > 0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float InlierIrlsWeight {
          get { if ((_hasBits0 & 16) != 0) { return inlierIrlsWeight_; } else { return InlierIrlsWeightDefaultValue; } }
          set {
            _hasBits0 |= 16;
            inlierIrlsWeight_ = value;
          }
        }
        /// <summary>Gets whether the "inlier_irls_weight" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInlierIrlsWeight {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "inlier_irls_weight" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInlierIrlsWeight() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "bias_stdev" field.</summary>
        public const int BiasStdevFieldNumber = 12;
        private readonly static float BiasStdevDefaultValue = 1F;

        private float biasStdev_;
        /// <summary>
        /// Standard deviation used during feature initialization. Current bias of a
        /// track is used to pre-weight features via gaussian weighting with
        /// specified standard deviation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float BiasStdev {
          get { if ((_hasBits0 & 2048) != 0) { return biasStdev_; } else { return BiasStdevDefaultValue; } }
          set {
            _hasBits0 |= 2048;
            biasStdev_ = value;
          }
        }
        /// <summary>Gets whether the "bias_stdev" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasBiasStdev {
          get { return (_hasBits0 & 2048) != 0; }
        }
        /// <summary>Clears the value of the "bias_stdev" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearBiasStdev() {
          _hasBits0 &= ~2048;
        }

        /// <summary>Field number for the "use_spatial_bias" field.</summary>
        public const int UseSpatialBiasFieldNumber = 6;
        private readonly static bool UseSpatialBiasDefaultValue = true;

        private bool useSpatialBias_;
        /// <summary>
        /// When seeding new tracks (on the first frame), we bilaterally pool
        /// neighboring feature biases as seed. Details are controlled by options
        /// below. If false, the feature's estimation error is used instead
        /// (faster, but less spatially smooth).
        /// If activated it is advised to use a patch descriptor radius of at least
        /// 20 pixels.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UseSpatialBias {
          get { if ((_hasBits0 & 32) != 0) { return useSpatialBias_; } else { return UseSpatialBiasDefaultValue; } }
          set {
            _hasBits0 |= 32;
            useSpatialBias_ = value;
          }
        }
        /// <summary>Gets whether the "use_spatial_bias" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUseSpatialBias {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "use_spatial_bias" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUseSpatialBias() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "grid_size" field.</summary>
        public const int GridSizeFieldNumber = 7;
        private readonly static float GridSizeDefaultValue = 0.04F;

        private float gridSize_;
        /// <summary>
        /// Newly observered tracks's biases are seeded by similar looking features
        /// in close spatial proximity. For efficieny a grid is used to determine
        /// proximity.
        /// Grid size in normalized coordinates w.r.t. frame domain.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float GridSize {
          get { if ((_hasBits0 & 64) != 0) { return gridSize_; } else { return GridSizeDefaultValue; } }
          set {
            _hasBits0 |= 64;
            gridSize_ = value;
          }
        }
        /// <summary>Gets whether the "grid_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasGridSize {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "grid_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearGridSize() {
          _hasBits0 &= ~64;
        }

        /// <summary>Field number for the "spatial_sigma" field.</summary>
        public const int SpatialSigmaFieldNumber = 8;
        private readonly static float SpatialSigmaDefaultValue = 0.02F;

        private float spatialSigma_;
        /// <summary>
        /// Sigma's for combining feature biases.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float SpatialSigma {
          get { if ((_hasBits0 & 128) != 0) { return spatialSigma_; } else { return SpatialSigmaDefaultValue; } }
          set {
            _hasBits0 |= 128;
            spatialSigma_ = value;
          }
        }
        /// <summary>Gets whether the "spatial_sigma" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSpatialSigma {
          get { return (_hasBits0 & 128) != 0; }
        }
        /// <summary>Clears the value of the "spatial_sigma" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSpatialSigma() {
          _hasBits0 &= ~128;
        }

        /// <summary>Field number for the "color_sigma" field.</summary>
        public const int ColorSigmaFieldNumber = 9;
        private readonly static float ColorSigmaDefaultValue = 20F;

        private float colorSigma_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float ColorSigma {
          get { if ((_hasBits0 & 256) != 0) { return colorSigma_; } else { return ColorSigmaDefaultValue; } }
          set {
            _hasBits0 |= 256;
            colorSigma_ = value;
          }
        }
        /// <summary>Gets whether the "color_sigma" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasColorSigma {
          get { return (_hasBits0 & 256) != 0; }
        }
        /// <summary>Clears the value of the "color_sigma" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearColorSigma() {
          _hasBits0 &= ~256;
        }

        /// <summary>Field number for the "long_track_threshold" field.</summary>
        public const int LongTrackThresholdFieldNumber = 10;
        private readonly static int LongTrackThresholdDefaultValue = 30;

        private int longTrackThreshold_;
        /// <summary>
        /// Defines what we consider to be a long track. Features spawned around
        /// locations of similar looking long tracks are considered to have
        /// high prior, e.g. their initilization is given more weight.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int LongTrackThreshold {
          get { if ((_hasBits0 & 512) != 0) { return longTrackThreshold_; } else { return LongTrackThresholdDefaultValue; } }
          set {
            _hasBits0 |= 512;
            longTrackThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "long_track_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLongTrackThreshold {
          get { return (_hasBits0 & 512) != 0; }
        }
        /// <summary>Clears the value of the "long_track_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLongTrackThreshold() {
          _hasBits0 &= ~512;
        }

        /// <summary>Field number for the "long_track_confidence_fraction" field.</summary>
        public const int LongTrackConfidenceFractionFieldNumber = 11;
        private readonly static float LongTrackConfidenceFractionDefaultValue = 0.25F;

        private float longTrackConfidenceFraction_;
        /// <summary>
        /// Determines with fraction of long tracks is considered to be sufficient
        /// for highly confident bias seed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LongTrackConfidenceFraction {
          get { if ((_hasBits0 & 1024) != 0) { return longTrackConfidenceFraction_; } else { return LongTrackConfidenceFractionDefaultValue; } }
          set {
            _hasBits0 |= 1024;
            longTrackConfidenceFraction_ = value;
          }
        }
        /// <summary>Gets whether the "long_track_confidence_fraction" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLongTrackConfidenceFraction {
          get { return (_hasBits0 & 1024) != 0; }
        }
        /// <summary>Clears the value of the "long_track_confidence_fraction" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLongTrackConfidenceFraction() {
          _hasBits0 &= ~1024;
        }

        /// <summary>Field number for the "seed_priors_from_bias" field.</summary>
        public const int SeedPriorsFromBiasFieldNumber = 14;
        private readonly static bool SeedPriorsFromBiasDefaultValue = false;

        private bool seedPriorsFromBias_;
        /// <summary>
        /// If activated, uses the irls weights from the estimation of the lower
        /// degree of freedom model to seed the bias of the higher degree of freedom
        /// model. This improves rigidity of the computed motion.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SeedPriorsFromBias {
          get { if ((_hasBits0 & 8192) != 0) { return seedPriorsFromBias_; } else { return SeedPriorsFromBiasDefaultValue; } }
          set {
            _hasBits0 |= 8192;
            seedPriorsFromBias_ = value;
          }
        }
        /// <summary>Gets whether the "seed_priors_from_bias" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSeedPriorsFromBias {
          get { return (_hasBits0 & 8192) != 0; }
        }
        /// <summary>Clears the value of the "seed_priors_from_bias" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSeedPriorsFromBias() {
          _hasBits0 &= ~8192;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LongFeatureBiasOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LongFeatureBiasOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TotalRounds != other.TotalRounds) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InlierBias, other.InlierBias)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OutlierBias, other.OutlierBias)) return false;
          if (NumIrlsObservations != other.NumIrlsObservations) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxIrlsChangeRatio, other.MaxIrlsChangeRatio)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InlierIrlsWeight, other.InlierIrlsWeight)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BiasStdev, other.BiasStdev)) return false;
          if (UseSpatialBias != other.UseSpatialBias) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GridSize, other.GridSize)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SpatialSigma, other.SpatialSigma)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ColorSigma, other.ColorSigma)) return false;
          if (LongTrackThreshold != other.LongTrackThreshold) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LongTrackConfidenceFraction, other.LongTrackConfidenceFraction)) return false;
          if (SeedPriorsFromBias != other.SeedPriorsFromBias) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTotalRounds) hash ^= TotalRounds.GetHashCode();
          if (HasInlierBias) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InlierBias);
          if (HasOutlierBias) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OutlierBias);
          if (HasNumIrlsObservations) hash ^= NumIrlsObservations.GetHashCode();
          if (HasMaxIrlsChangeRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxIrlsChangeRatio);
          if (HasInlierIrlsWeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InlierIrlsWeight);
          if (HasBiasStdev) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BiasStdev);
          if (HasUseSpatialBias) hash ^= UseSpatialBias.GetHashCode();
          if (HasGridSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GridSize);
          if (HasSpatialSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SpatialSigma);
          if (HasColorSigma) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ColorSigma);
          if (HasLongTrackThreshold) hash ^= LongTrackThreshold.GetHashCode();
          if (HasLongTrackConfidenceFraction) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LongTrackConfidenceFraction);
          if (HasSeedPriorsFromBias) hash ^= SeedPriorsFromBias.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasInlierBias) {
            output.WriteRawTag(13);
            output.WriteFloat(InlierBias);
          }
          if (HasOutlierBias) {
            output.WriteRawTag(21);
            output.WriteFloat(OutlierBias);
          }
          if (HasNumIrlsObservations) {
            output.WriteRawTag(24);
            output.WriteInt32(NumIrlsObservations);
          }
          if (HasMaxIrlsChangeRatio) {
            output.WriteRawTag(37);
            output.WriteFloat(MaxIrlsChangeRatio);
          }
          if (HasInlierIrlsWeight) {
            output.WriteRawTag(45);
            output.WriteFloat(InlierIrlsWeight);
          }
          if (HasUseSpatialBias) {
            output.WriteRawTag(48);
            output.WriteBool(UseSpatialBias);
          }
          if (HasGridSize) {
            output.WriteRawTag(61);
            output.WriteFloat(GridSize);
          }
          if (HasSpatialSigma) {
            output.WriteRawTag(69);
            output.WriteFloat(SpatialSigma);
          }
          if (HasColorSigma) {
            output.WriteRawTag(77);
            output.WriteFloat(ColorSigma);
          }
          if (HasLongTrackThreshold) {
            output.WriteRawTag(80);
            output.WriteInt32(LongTrackThreshold);
          }
          if (HasLongTrackConfidenceFraction) {
            output.WriteRawTag(93);
            output.WriteFloat(LongTrackConfidenceFraction);
          }
          if (HasBiasStdev) {
            output.WriteRawTag(101);
            output.WriteFloat(BiasStdev);
          }
          if (HasTotalRounds) {
            output.WriteRawTag(104);
            output.WriteInt32(TotalRounds);
          }
          if (HasSeedPriorsFromBias) {
            output.WriteRawTag(112);
            output.WriteBool(SeedPriorsFromBias);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasInlierBias) {
            output.WriteRawTag(13);
            output.WriteFloat(InlierBias);
          }
          if (HasOutlierBias) {
            output.WriteRawTag(21);
            output.WriteFloat(OutlierBias);
          }
          if (HasNumIrlsObservations) {
            output.WriteRawTag(24);
            output.WriteInt32(NumIrlsObservations);
          }
          if (HasMaxIrlsChangeRatio) {
            output.WriteRawTag(37);
            output.WriteFloat(MaxIrlsChangeRatio);
          }
          if (HasInlierIrlsWeight) {
            output.WriteRawTag(45);
            output.WriteFloat(InlierIrlsWeight);
          }
          if (HasUseSpatialBias) {
            output.WriteRawTag(48);
            output.WriteBool(UseSpatialBias);
          }
          if (HasGridSize) {
            output.WriteRawTag(61);
            output.WriteFloat(GridSize);
          }
          if (HasSpatialSigma) {
            output.WriteRawTag(69);
            output.WriteFloat(SpatialSigma);
          }
          if (HasColorSigma) {
            output.WriteRawTag(77);
            output.WriteFloat(ColorSigma);
          }
          if (HasLongTrackThreshold) {
            output.WriteRawTag(80);
            output.WriteInt32(LongTrackThreshold);
          }
          if (HasLongTrackConfidenceFraction) {
            output.WriteRawTag(93);
            output.WriteFloat(LongTrackConfidenceFraction);
          }
          if (HasBiasStdev) {
            output.WriteRawTag(101);
            output.WriteFloat(BiasStdev);
          }
          if (HasTotalRounds) {
            output.WriteRawTag(104);
            output.WriteInt32(TotalRounds);
          }
          if (HasSeedPriorsFromBias) {
            output.WriteRawTag(112);
            output.WriteBool(SeedPriorsFromBias);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasTotalRounds) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(TotalRounds);
          }
          if (HasInlierBias) {
            size += 1 + 4;
          }
          if (HasOutlierBias) {
            size += 1 + 4;
          }
          if (HasNumIrlsObservations) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumIrlsObservations);
          }
          if (HasMaxIrlsChangeRatio) {
            size += 1 + 4;
          }
          if (HasInlierIrlsWeight) {
            size += 1 + 4;
          }
          if (HasBiasStdev) {
            size += 1 + 4;
          }
          if (HasUseSpatialBias) {
            size += 1 + 1;
          }
          if (HasGridSize) {
            size += 1 + 4;
          }
          if (HasSpatialSigma) {
            size += 1 + 4;
          }
          if (HasColorSigma) {
            size += 1 + 4;
          }
          if (HasLongTrackThreshold) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(LongTrackThreshold);
          }
          if (HasLongTrackConfidenceFraction) {
            size += 1 + 4;
          }
          if (HasSeedPriorsFromBias) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LongFeatureBiasOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasTotalRounds) {
            TotalRounds = other.TotalRounds;
          }
          if (other.HasInlierBias) {
            InlierBias = other.InlierBias;
          }
          if (other.HasOutlierBias) {
            OutlierBias = other.OutlierBias;
          }
          if (other.HasNumIrlsObservations) {
            NumIrlsObservations = other.NumIrlsObservations;
          }
          if (other.HasMaxIrlsChangeRatio) {
            MaxIrlsChangeRatio = other.MaxIrlsChangeRatio;
          }
          if (other.HasInlierIrlsWeight) {
            InlierIrlsWeight = other.InlierIrlsWeight;
          }
          if (other.HasBiasStdev) {
            BiasStdev = other.BiasStdev;
          }
          if (other.HasUseSpatialBias) {
            UseSpatialBias = other.UseSpatialBias;
          }
          if (other.HasGridSize) {
            GridSize = other.GridSize;
          }
          if (other.HasSpatialSigma) {
            SpatialSigma = other.SpatialSigma;
          }
          if (other.HasColorSigma) {
            ColorSigma = other.ColorSigma;
          }
          if (other.HasLongTrackThreshold) {
            LongTrackThreshold = other.LongTrackThreshold;
          }
          if (other.HasLongTrackConfidenceFraction) {
            LongTrackConfidenceFraction = other.LongTrackConfidenceFraction;
          }
          if (other.HasSeedPriorsFromBias) {
            SeedPriorsFromBias = other.SeedPriorsFromBias;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                InlierBias = input.ReadFloat();
                break;
              }
              case 21: {
                OutlierBias = input.ReadFloat();
                break;
              }
              case 24: {
                NumIrlsObservations = input.ReadInt32();
                break;
              }
              case 37: {
                MaxIrlsChangeRatio = input.ReadFloat();
                break;
              }
              case 45: {
                InlierIrlsWeight = input.ReadFloat();
                break;
              }
              case 48: {
                UseSpatialBias = input.ReadBool();
                break;
              }
              case 61: {
                GridSize = input.ReadFloat();
                break;
              }
              case 69: {
                SpatialSigma = input.ReadFloat();
                break;
              }
              case 77: {
                ColorSigma = input.ReadFloat();
                break;
              }
              case 80: {
                LongTrackThreshold = input.ReadInt32();
                break;
              }
              case 93: {
                LongTrackConfidenceFraction = input.ReadFloat();
                break;
              }
              case 101: {
                BiasStdev = input.ReadFloat();
                break;
              }
              case 104: {
                TotalRounds = input.ReadInt32();
                break;
              }
              case 112: {
                SeedPriorsFromBias = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                InlierBias = input.ReadFloat();
                break;
              }
              case 21: {
                OutlierBias = input.ReadFloat();
                break;
              }
              case 24: {
                NumIrlsObservations = input.ReadInt32();
                break;
              }
              case 37: {
                MaxIrlsChangeRatio = input.ReadFloat();
                break;
              }
              case 45: {
                InlierIrlsWeight = input.ReadFloat();
                break;
              }
              case 48: {
                UseSpatialBias = input.ReadBool();
                break;
              }
              case 61: {
                GridSize = input.ReadFloat();
                break;
              }
              case 69: {
                SpatialSigma = input.ReadFloat();
                break;
              }
              case 77: {
                ColorSigma = input.ReadFloat();
                break;
              }
              case 80: {
                LongTrackThreshold = input.ReadInt32();
                break;
              }
              case 93: {
                LongTrackConfidenceFraction = input.ReadFloat();
                break;
              }
              case 101: {
                BiasStdev = input.ReadFloat();
                break;
              }
              case 104: {
                TotalRounds = input.ReadInt32();
                break;
              }
              case 112: {
                SeedPriorsFromBias = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// If any parameter of the input flow or estimated translation exceeds these
      /// thresholds we deem the motion INVALID.
      /// </summary>
      public sealed partial class TranslationBounds : pb::IMessage<TranslationBounds>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TranslationBounds> _parser = new pb::MessageParser<TranslationBounds>(() => new TranslationBounds());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TranslationBounds> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslationBounds() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslationBounds(TranslationBounds other) : this() {
          _hasBits0 = other._hasBits0;
          minFeatures_ = other.minFeatures_;
          fracMaxMotionMagnitude_ = other.fracMaxMotionMagnitude_;
          maxMotionStdevThreshold_ = other.maxMotionStdevThreshold_;
          maxMotionStdev_ = other.maxMotionStdev_;
          maxAcceleration_ = other.maxAcceleration_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TranslationBounds Clone() {
          return new TranslationBounds(this);
        }

        /// <summary>Field number for the "min_features" field.</summary>
        public const int MinFeaturesFieldNumber = 1;
        private readonly static int MinFeaturesDefaultValue = 3;

        private int minFeatures_;
        /// <summary>
        /// Absolute minimum of features present.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MinFeatures {
          get { if ((_hasBits0 & 1) != 0) { return minFeatures_; } else { return MinFeaturesDefaultValue; } }
          set {
            _hasBits0 |= 1;
            minFeatures_ = value;
          }
        }
        /// <summary>Gets whether the "min_features" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinFeatures {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "min_features" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinFeatures() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "frac_max_motion_magnitude" field.</summary>
        public const int FracMaxMotionMagnitudeFieldNumber = 2;
        private readonly static float FracMaxMotionMagnitudeDefaultValue = 0.15F;

        private float fracMaxMotionMagnitude_;
        /// <summary>
        /// Max magnitude of the translation expressed w.r.t. frame diameter
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FracMaxMotionMagnitude {
          get { if ((_hasBits0 & 2) != 0) { return fracMaxMotionMagnitude_; } else { return FracMaxMotionMagnitudeDefaultValue; } }
          set {
            _hasBits0 |= 2;
            fracMaxMotionMagnitude_ = value;
          }
        }
        /// <summary>Gets whether the "frac_max_motion_magnitude" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFracMaxMotionMagnitude {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "frac_max_motion_magnitude" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFracMaxMotionMagnitude() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "max_motion_stdev_threshold" field.</summary>
        public const int MaxMotionStdevThresholdFieldNumber = 4;
        private readonly static float MaxMotionStdevThresholdDefaultValue = 0.01F;

        private float maxMotionStdevThreshold_;
        /// <summary>
        /// Motion magnitude is only tested for if standard deviation of estimated
        /// translation exceeds threshold.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MaxMotionStdevThreshold {
          get { if ((_hasBits0 & 8) != 0) { return maxMotionStdevThreshold_; } else { return MaxMotionStdevThresholdDefaultValue; } }
          set {
            _hasBits0 |= 8;
            maxMotionStdevThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "max_motion_stdev_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxMotionStdevThreshold {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "max_motion_stdev_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxMotionStdevThreshold() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "max_motion_stdev" field.</summary>
        public const int MaxMotionStdevFieldNumber = 3;
        private readonly static float MaxMotionStdevDefaultValue = 0.065F;

        private float maxMotionStdev_;
        /// <summary>
        /// Max standard deviation of the estimated translation (normalized to frame
        /// diameter).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MaxMotionStdev {
          get { if ((_hasBits0 & 4) != 0) { return maxMotionStdev_; } else { return MaxMotionStdevDefaultValue; } }
          set {
            _hasBits0 |= 4;
            maxMotionStdev_ = value;
          }
        }
        /// <summary>Gets whether the "max_motion_stdev" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxMotionStdev {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "max_motion_stdev" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxMotionStdev() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "max_acceleration" field.</summary>
        public const int MaxAccelerationFieldNumber = 5;
        private readonly static float MaxAccelerationDefaultValue = 20F;

        private float maxAcceleration_;
        /// <summary>
        /// Maximum acceleration between frames. Specified relative to minimum
        /// velocity across two adjacent frames (absolute minimum of 0.001 is
        /// enforced, ~1 pix for 480p).
        /// If exceeded for one frame, the whole batch passed to
        /// EstimateMotionsParallel is labeled unstable.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MaxAcceleration {
          get { if ((_hasBits0 & 16) != 0) { return maxAcceleration_; } else { return MaxAccelerationDefaultValue; } }
          set {
            _hasBits0 |= 16;
            maxAcceleration_ = value;
          }
        }
        /// <summary>Gets whether the "max_acceleration" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxAcceleration {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "max_acceleration" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxAcceleration() {
          _hasBits0 &= ~16;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TranslationBounds);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TranslationBounds other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinFeatures != other.MinFeatures) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracMaxMotionMagnitude, other.FracMaxMotionMagnitude)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxMotionStdevThreshold, other.MaxMotionStdevThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxMotionStdev, other.MaxMotionStdev)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAcceleration, other.MaxAcceleration)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMinFeatures) hash ^= MinFeatures.GetHashCode();
          if (HasFracMaxMotionMagnitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracMaxMotionMagnitude);
          if (HasMaxMotionStdevThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxMotionStdevThreshold);
          if (HasMaxMotionStdev) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxMotionStdev);
          if (HasMaxAcceleration) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAcceleration);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasMinFeatures) {
            output.WriteRawTag(8);
            output.WriteInt32(MinFeatures);
          }
          if (HasFracMaxMotionMagnitude) {
            output.WriteRawTag(21);
            output.WriteFloat(FracMaxMotionMagnitude);
          }
          if (HasMaxMotionStdev) {
            output.WriteRawTag(29);
            output.WriteFloat(MaxMotionStdev);
          }
          if (HasMaxMotionStdevThreshold) {
            output.WriteRawTag(37);
            output.WriteFloat(MaxMotionStdevThreshold);
          }
          if (HasMaxAcceleration) {
            output.WriteRawTag(45);
            output.WriteFloat(MaxAcceleration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMinFeatures) {
            output.WriteRawTag(8);
            output.WriteInt32(MinFeatures);
          }
          if (HasFracMaxMotionMagnitude) {
            output.WriteRawTag(21);
            output.WriteFloat(FracMaxMotionMagnitude);
          }
          if (HasMaxMotionStdev) {
            output.WriteRawTag(29);
            output.WriteFloat(MaxMotionStdev);
          }
          if (HasMaxMotionStdevThreshold) {
            output.WriteRawTag(37);
            output.WriteFloat(MaxMotionStdevThreshold);
          }
          if (HasMaxAcceleration) {
            output.WriteRawTag(45);
            output.WriteFloat(MaxAcceleration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasMinFeatures) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinFeatures);
          }
          if (HasFracMaxMotionMagnitude) {
            size += 1 + 4;
          }
          if (HasMaxMotionStdevThreshold) {
            size += 1 + 4;
          }
          if (HasMaxMotionStdev) {
            size += 1 + 4;
          }
          if (HasMaxAcceleration) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TranslationBounds other) {
          if (other == null) {
            return;
          }
          if (other.HasMinFeatures) {
            MinFeatures = other.MinFeatures;
          }
          if (other.HasFracMaxMotionMagnitude) {
            FracMaxMotionMagnitude = other.FracMaxMotionMagnitude;
          }
          if (other.HasMaxMotionStdevThreshold) {
            MaxMotionStdevThreshold = other.MaxMotionStdevThreshold;
          }
          if (other.HasMaxMotionStdev) {
            MaxMotionStdev = other.MaxMotionStdev;
          }
          if (other.HasMaxAcceleration) {
            MaxAcceleration = other.MaxAcceleration;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MinFeatures = input.ReadInt32();
                break;
              }
              case 21: {
                FracMaxMotionMagnitude = input.ReadFloat();
                break;
              }
              case 29: {
                MaxMotionStdev = input.ReadFloat();
                break;
              }
              case 37: {
                MaxMotionStdevThreshold = input.ReadFloat();
                break;
              }
              case 45: {
                MaxAcceleration = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                MinFeatures = input.ReadInt32();
                break;
              }
              case 21: {
                FracMaxMotionMagnitude = input.ReadFloat();
                break;
              }
              case 29: {
                MaxMotionStdev = input.ReadFloat();
                break;
              }
              case 37: {
                MaxMotionStdevThreshold = input.ReadFloat();
                break;
              }
              case 45: {
                MaxAcceleration = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// If any test/bound is violated, the motion is deemed UNSTABLE.
      /// </summary>
      public sealed partial class SimilarityBounds : pb::IMessage<SimilarityBounds>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SimilarityBounds> _parser = new pb::MessageParser<SimilarityBounds>(() => new SimilarityBounds());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SimilarityBounds> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SimilarityBounds() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SimilarityBounds(SimilarityBounds other) : this() {
          _hasBits0 = other._hasBits0;
          onlyStableInput_ = other.onlyStableInput_;
          minInlierFraction_ = other.minInlierFraction_;
          minInliers_ = other.minInliers_;
          lowerScale_ = other.lowerScale_;
          upperScale_ = other.upperScale_;
          limitRotation_ = other.limitRotation_;
          inlierThreshold_ = other.inlierThreshold_;
          fracInlierThreshold_ = other.fracInlierThreshold_;
          strictInlierThreshold_ = other.strictInlierThreshold_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SimilarityBounds Clone() {
          return new SimilarityBounds(this);
        }

        /// <summary>Field number for the "only_stable_input" field.</summary>
        public const int OnlyStableInputFieldNumber = 1;
        private readonly static bool OnlyStableInputDefaultValue = true;

        private bool onlyStableInput_;
        /// <summary>
        /// Input frame has to be labeled stable, i.e. enough features and coverage
        /// present.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool OnlyStableInput {
          get { if ((_hasBits0 & 1) != 0) { return onlyStableInput_; } else { return OnlyStableInputDefaultValue; } }
          set {
            _hasBits0 |= 1;
            onlyStableInput_ = value;
          }
        }
        /// <summary>Gets whether the "only_stable_input" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOnlyStableInput {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "only_stable_input" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOnlyStableInput() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "min_inlier_fraction" field.</summary>
        public const int MinInlierFractionFieldNumber = 2;
        private readonly static float MinInlierFractionDefaultValue = 0.2F;

        private float minInlierFraction_;
        /// <summary>
        /// Minimum number of inlier features (absolute and as fraction of total
        /// number of features).
        /// TODO: Dataset run setting this to 0.15
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinInlierFraction {
          get { if ((_hasBits0 & 2) != 0) { return minInlierFraction_; } else { return MinInlierFractionDefaultValue; } }
          set {
            _hasBits0 |= 2;
            minInlierFraction_ = value;
          }
        }
        /// <summary>Gets whether the "min_inlier_fraction" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinInlierFraction {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "min_inlier_fraction" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinInlierFraction() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "min_inliers" field.</summary>
        public const int MinInliersFieldNumber = 3;
        private readonly static float MinInliersDefaultValue = 30F;

        private float minInliers_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinInliers {
          get { if ((_hasBits0 & 4) != 0) { return minInliers_; } else { return MinInliersDefaultValue; } }
          set {
            _hasBits0 |= 4;
            minInliers_ = value;
          }
        }
        /// <summary>Gets whether the "min_inliers" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinInliers {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "min_inliers" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinInliers() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "lower_scale" field.</summary>
        public const int LowerScaleFieldNumber = 4;
        private readonly static float LowerScaleDefaultValue = 0.8F;

        private float lowerScale_;
        /// <summary>
        /// Bounds on valid similarities. We use larger values compared to
        /// homographies. Note: Bounds are necessary,  to guarantee invertability
        /// of the resulting similarity.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LowerScale {
          get { if ((_hasBits0 & 8) != 0) { return lowerScale_; } else { return LowerScaleDefaultValue; } }
          set {
            _hasBits0 |= 8;
            lowerScale_ = value;
          }
        }
        /// <summary>Gets whether the "lower_scale" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLowerScale {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "lower_scale" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLowerScale() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "upper_scale" field.</summary>
        public const int UpperScaleFieldNumber = 5;
        private readonly static float UpperScaleDefaultValue = 1.25F;

        private float upperScale_;
        /// <summary>
        /// 1 / 0.8.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float UpperScale {
          get { if ((_hasBits0 & 16) != 0) { return upperScale_; } else { return UpperScaleDefaultValue; } }
          set {
            _hasBits0 |= 16;
            upperScale_ = value;
          }
        }
        /// <summary>Gets whether the "upper_scale" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUpperScale {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "upper_scale" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUpperScale() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "limit_rotation" field.</summary>
        public const int LimitRotationFieldNumber = 6;
        private readonly static float LimitRotationDefaultValue = 0.25F;

        private float limitRotation_;
        /// <summary>
        /// 15 degrees.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LimitRotation {
          get { if ((_hasBits0 & 32) != 0) { return limitRotation_; } else { return LimitRotationDefaultValue; } }
          set {
            _hasBits0 |= 32;
            limitRotation_ = value;
          }
        }
        /// <summary>Gets whether the "limit_rotation" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLimitRotation {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "limit_rotation" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLimitRotation() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "inlier_threshold" field.</summary>
        public const int InlierThresholdFieldNumber = 7;
        private readonly static float InlierThresholdDefaultValue = 4F;

        private float inlierThreshold_;
        /// <summary>
        /// Thresholds for a feature to be considered inlier w.r.t similarity
        /// transform, expressed in terms of pixel residual error. Max of absolute
        /// and fractional thresholds is used.
        /// Ratio of inliers that pass regular and strict thresholds are storred in
        /// CameraMotion.
        ///
        /// TODO: Just use lin_sim_inlier_threshold directly, however that
        /// recomputes the error, and requires regression testing. Using an extra
        /// fractional inlier threshold for now.
        ///
        /// Absolute in pixels.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float InlierThreshold {
          get { if ((_hasBits0 & 64) != 0) { return inlierThreshold_; } else { return InlierThresholdDefaultValue; } }
          set {
            _hasBits0 |= 64;
            inlierThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "inlier_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasInlierThreshold {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "inlier_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInlierThreshold() {
          _hasBits0 &= ~64;
        }

        /// <summary>Field number for the "frac_inlier_threshold" field.</summary>
        public const int FracInlierThresholdFieldNumber = 8;
        private readonly static float FracInlierThresholdDefaultValue = 0F;

        private float fracInlierThreshold_;
        /// <summary>
        /// Scaled by frame diameter.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FracInlierThreshold {
          get { if ((_hasBits0 & 128) != 0) { return fracInlierThreshold_; } else { return FracInlierThresholdDefaultValue; } }
          set {
            _hasBits0 |= 128;
            fracInlierThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "frac_inlier_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFracInlierThreshold {
          get { return (_hasBits0 & 128) != 0; }
        }
        /// <summary>Clears the value of the "frac_inlier_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFracInlierThreshold() {
          _hasBits0 &= ~128;
        }

        /// <summary>Field number for the "strict_inlier_threshold" field.</summary>
        public const int StrictInlierThresholdFieldNumber = 9;
        private readonly static float StrictInlierThresholdDefaultValue = 0.5F;

        private float strictInlierThreshold_;
        /// <summary>
        /// TODO: Revisit after frame selection change.
        /// Absolute in pixels.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float StrictInlierThreshold {
          get { if ((_hasBits0 & 256) != 0) { return strictInlierThreshold_; } else { return StrictInlierThresholdDefaultValue; } }
          set {
            _hasBits0 |= 256;
            strictInlierThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "strict_inlier_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStrictInlierThreshold {
          get { return (_hasBits0 & 256) != 0; }
        }
        /// <summary>Clears the value of the "strict_inlier_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStrictInlierThreshold() {
          _hasBits0 &= ~256;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SimilarityBounds);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SimilarityBounds other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (OnlyStableInput != other.OnlyStableInput) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinInlierFraction, other.MinInlierFraction)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinInliers, other.MinInliers)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LowerScale, other.LowerScale)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(UpperScale, other.UpperScale)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LimitRotation, other.LimitRotation)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InlierThreshold, other.InlierThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracInlierThreshold, other.FracInlierThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StrictInlierThreshold, other.StrictInlierThreshold)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasOnlyStableInput) hash ^= OnlyStableInput.GetHashCode();
          if (HasMinInlierFraction) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinInlierFraction);
          if (HasMinInliers) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinInliers);
          if (HasLowerScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LowerScale);
          if (HasUpperScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(UpperScale);
          if (HasLimitRotation) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LimitRotation);
          if (HasInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InlierThreshold);
          if (HasFracInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracInlierThreshold);
          if (HasStrictInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StrictInlierThreshold);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasOnlyStableInput) {
            output.WriteRawTag(8);
            output.WriteBool(OnlyStableInput);
          }
          if (HasMinInlierFraction) {
            output.WriteRawTag(21);
            output.WriteFloat(MinInlierFraction);
          }
          if (HasMinInliers) {
            output.WriteRawTag(29);
            output.WriteFloat(MinInliers);
          }
          if (HasLowerScale) {
            output.WriteRawTag(37);
            output.WriteFloat(LowerScale);
          }
          if (HasUpperScale) {
            output.WriteRawTag(45);
            output.WriteFloat(UpperScale);
          }
          if (HasLimitRotation) {
            output.WriteRawTag(53);
            output.WriteFloat(LimitRotation);
          }
          if (HasInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(InlierThreshold);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(69);
            output.WriteFloat(FracInlierThreshold);
          }
          if (HasStrictInlierThreshold) {
            output.WriteRawTag(77);
            output.WriteFloat(StrictInlierThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasOnlyStableInput) {
            output.WriteRawTag(8);
            output.WriteBool(OnlyStableInput);
          }
          if (HasMinInlierFraction) {
            output.WriteRawTag(21);
            output.WriteFloat(MinInlierFraction);
          }
          if (HasMinInliers) {
            output.WriteRawTag(29);
            output.WriteFloat(MinInliers);
          }
          if (HasLowerScale) {
            output.WriteRawTag(37);
            output.WriteFloat(LowerScale);
          }
          if (HasUpperScale) {
            output.WriteRawTag(45);
            output.WriteFloat(UpperScale);
          }
          if (HasLimitRotation) {
            output.WriteRawTag(53);
            output.WriteFloat(LimitRotation);
          }
          if (HasInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(InlierThreshold);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(69);
            output.WriteFloat(FracInlierThreshold);
          }
          if (HasStrictInlierThreshold) {
            output.WriteRawTag(77);
            output.WriteFloat(StrictInlierThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasOnlyStableInput) {
            size += 1 + 1;
          }
          if (HasMinInlierFraction) {
            size += 1 + 4;
          }
          if (HasMinInliers) {
            size += 1 + 4;
          }
          if (HasLowerScale) {
            size += 1 + 4;
          }
          if (HasUpperScale) {
            size += 1 + 4;
          }
          if (HasLimitRotation) {
            size += 1 + 4;
          }
          if (HasInlierThreshold) {
            size += 1 + 4;
          }
          if (HasFracInlierThreshold) {
            size += 1 + 4;
          }
          if (HasStrictInlierThreshold) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SimilarityBounds other) {
          if (other == null) {
            return;
          }
          if (other.HasOnlyStableInput) {
            OnlyStableInput = other.OnlyStableInput;
          }
          if (other.HasMinInlierFraction) {
            MinInlierFraction = other.MinInlierFraction;
          }
          if (other.HasMinInliers) {
            MinInliers = other.MinInliers;
          }
          if (other.HasLowerScale) {
            LowerScale = other.LowerScale;
          }
          if (other.HasUpperScale) {
            UpperScale = other.UpperScale;
          }
          if (other.HasLimitRotation) {
            LimitRotation = other.LimitRotation;
          }
          if (other.HasInlierThreshold) {
            InlierThreshold = other.InlierThreshold;
          }
          if (other.HasFracInlierThreshold) {
            FracInlierThreshold = other.FracInlierThreshold;
          }
          if (other.HasStrictInlierThreshold) {
            StrictInlierThreshold = other.StrictInlierThreshold;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                OnlyStableInput = input.ReadBool();
                break;
              }
              case 21: {
                MinInlierFraction = input.ReadFloat();
                break;
              }
              case 29: {
                MinInliers = input.ReadFloat();
                break;
              }
              case 37: {
                LowerScale = input.ReadFloat();
                break;
              }
              case 45: {
                UpperScale = input.ReadFloat();
                break;
              }
              case 53: {
                LimitRotation = input.ReadFloat();
                break;
              }
              case 61: {
                InlierThreshold = input.ReadFloat();
                break;
              }
              case 69: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
              case 77: {
                StrictInlierThreshold = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                OnlyStableInput = input.ReadBool();
                break;
              }
              case 21: {
                MinInlierFraction = input.ReadFloat();
                break;
              }
              case 29: {
                MinInliers = input.ReadFloat();
                break;
              }
              case 37: {
                LowerScale = input.ReadFloat();
                break;
              }
              case 45: {
                UpperScale = input.ReadFloat();
                break;
              }
              case 53: {
                LimitRotation = input.ReadFloat();
                break;
              }
              case 61: {
                InlierThreshold = input.ReadFloat();
                break;
              }
              case 69: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
              case 77: {
                StrictInlierThreshold = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// If any parameter of the estimated homography exceeds these bounds,
      /// we deem it UNSTABLE_SIM and use estimated similarity instead.
      /// </summary>
      public sealed partial class HomographyBounds : pb::IMessage<HomographyBounds>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HomographyBounds> _parser = new pb::MessageParser<HomographyBounds>(() => new HomographyBounds());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HomographyBounds> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HomographyBounds() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HomographyBounds(HomographyBounds other) : this() {
          _hasBits0 = other._hasBits0;
          lowerScale_ = other.lowerScale_;
          upperScale_ = other.upperScale_;
          limitRotation_ = other.limitRotation_;
          limitPerspective_ = other.limitPerspective_;
          registrationThreshold_ = other.registrationThreshold_;
          fracRegistrationThreshold_ = other.fracRegistrationThreshold_;
          minInlierCoverage_ = other.minInlierCoverage_;
          fracInlierThreshold_ = other.fracInlierThreshold_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HomographyBounds Clone() {
          return new HomographyBounds(this);
        }

        /// <summary>Field number for the "lower_scale" field.</summary>
        public const int LowerScaleFieldNumber = 1;
        private readonly static float LowerScaleDefaultValue = 0.8F;

        private float lowerScale_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LowerScale {
          get { if ((_hasBits0 & 1) != 0) { return lowerScale_; } else { return LowerScaleDefaultValue; } }
          set {
            _hasBits0 |= 1;
            lowerScale_ = value;
          }
        }
        /// <summary>Gets whether the "lower_scale" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLowerScale {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "lower_scale" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLowerScale() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "upper_scale" field.</summary>
        public const int UpperScaleFieldNumber = 2;
        private readonly static float UpperScaleDefaultValue = 1.25F;

        private float upperScale_;
        /// <summary>
        /// 1 / 0.8.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float UpperScale {
          get { if ((_hasBits0 & 2) != 0) { return upperScale_; } else { return UpperScaleDefaultValue; } }
          set {
            _hasBits0 |= 2;
            upperScale_ = value;
          }
        }
        /// <summary>Gets whether the "upper_scale" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUpperScale {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "upper_scale" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUpperScale() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "limit_rotation" field.</summary>
        public const int LimitRotationFieldNumber = 3;
        private readonly static float LimitRotationDefaultValue = 0.25F;

        private float limitRotation_;
        /// <summary>
        /// 15 degrees.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LimitRotation {
          get { if ((_hasBits0 & 4) != 0) { return limitRotation_; } else { return LimitRotationDefaultValue; } }
          set {
            _hasBits0 |= 4;
            limitRotation_ = value;
          }
        }
        /// <summary>Gets whether the "limit_rotation" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLimitRotation {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "limit_rotation" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLimitRotation() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "limit_perspective" field.</summary>
        public const int LimitPerspectiveFieldNumber = 4;
        private readonly static float LimitPerspectiveDefaultValue = 0.0004F;

        private float limitPerspective_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LimitPerspective {
          get { if ((_hasBits0 & 8) != 0) { return limitPerspective_; } else { return LimitPerspectiveDefaultValue; } }
          set {
            _hasBits0 |= 8;
            limitPerspective_ = value;
          }
        }
        /// <summary>Gets whether the "limit_perspective" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLimitPerspective {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "limit_perspective" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLimitPerspective() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "registration_threshold" field.</summary>
        public const int RegistrationThresholdFieldNumber = 5;
        private readonly static float RegistrationThresholdDefaultValue = 0.1F;

        private float registrationThreshold_;
        /// <summary>
        /// Inlier coverage is only tested for if average homography error exceeds
        /// registration_thresholds. Max of the following two thresholds is used.
        ///
        /// Absolute in pixels.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float RegistrationThreshold {
          get { if ((_hasBits0 & 16) != 0) { return registrationThreshold_; } else { return RegistrationThresholdDefaultValue; } }
          set {
            _hasBits0 |= 16;
            registrationThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "registration_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRegistrationThreshold {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "registration_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRegistrationThreshold() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "frac_registration_threshold" field.</summary>
        public const int FracRegistrationThresholdFieldNumber = 8;
        private readonly static float FracRegistrationThresholdDefaultValue = 0F;

        private float fracRegistrationThreshold_;
        /// <summary>
        /// Scaled by frame diameter.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FracRegistrationThreshold {
          get { if ((_hasBits0 & 128) != 0) { return fracRegistrationThreshold_; } else { return FracRegistrationThresholdDefaultValue; } }
          set {
            _hasBits0 |= 128;
            fracRegistrationThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "frac_registration_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFracRegistrationThreshold {
          get { return (_hasBits0 & 128) != 0; }
        }
        /// <summary>Clears the value of the "frac_registration_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFracRegistrationThreshold() {
          _hasBits0 &= ~128;
        }

        /// <summary>Field number for the "min_inlier_coverage" field.</summary>
        public const int MinInlierCoverageFieldNumber = 6;
        private readonly static float MinInlierCoverageDefaultValue = 0.3F;

        private float minInlierCoverage_;
        /// <summary>
        /// Minimum fraction of inlier features w.r.t. frame area.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinInlierCoverage {
          get { if ((_hasBits0 & 32) != 0) { return minInlierCoverage_; } else { return MinInlierCoverageDefaultValue; } }
          set {
            _hasBits0 |= 32;
            minInlierCoverage_ = value;
          }
        }
        /// <summary>Gets whether the "min_inlier_coverage" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinInlierCoverage {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "min_inlier_coverage" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinInlierCoverage() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "frac_inlier_threshold" field.</summary>
        public const int FracInlierThresholdFieldNumber = 7;
        private readonly static float FracInlierThresholdDefaultValue = 0.002F;

        private float fracInlierThreshold_;
        /// <summary>
        /// Grid coverage inlier threshold. Pixel errors below this
        /// threshold are considered inliers. Defined w.r.t. frame diameter, approx.
        /// 1.5 for 16:9 SD video (480p), i.e. threshold is multiplied by frame
        /// diameter.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FracInlierThreshold {
          get { if ((_hasBits0 & 64) != 0) { return fracInlierThreshold_; } else { return FracInlierThresholdDefaultValue; } }
          set {
            _hasBits0 |= 64;
            fracInlierThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "frac_inlier_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFracInlierThreshold {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "frac_inlier_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFracInlierThreshold() {
          _hasBits0 &= ~64;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HomographyBounds);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HomographyBounds other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LowerScale, other.LowerScale)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(UpperScale, other.UpperScale)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LimitRotation, other.LimitRotation)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LimitPerspective, other.LimitPerspective)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RegistrationThreshold, other.RegistrationThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracRegistrationThreshold, other.FracRegistrationThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinInlierCoverage, other.MinInlierCoverage)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracInlierThreshold, other.FracInlierThreshold)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasLowerScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LowerScale);
          if (HasUpperScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(UpperScale);
          if (HasLimitRotation) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LimitRotation);
          if (HasLimitPerspective) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LimitPerspective);
          if (HasRegistrationThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RegistrationThreshold);
          if (HasFracRegistrationThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracRegistrationThreshold);
          if (HasMinInlierCoverage) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinInlierCoverage);
          if (HasFracInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracInlierThreshold);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasLowerScale) {
            output.WriteRawTag(13);
            output.WriteFloat(LowerScale);
          }
          if (HasUpperScale) {
            output.WriteRawTag(21);
            output.WriteFloat(UpperScale);
          }
          if (HasLimitRotation) {
            output.WriteRawTag(29);
            output.WriteFloat(LimitRotation);
          }
          if (HasLimitPerspective) {
            output.WriteRawTag(37);
            output.WriteFloat(LimitPerspective);
          }
          if (HasRegistrationThreshold) {
            output.WriteRawTag(45);
            output.WriteFloat(RegistrationThreshold);
          }
          if (HasMinInlierCoverage) {
            output.WriteRawTag(53);
            output.WriteFloat(MinInlierCoverage);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(FracInlierThreshold);
          }
          if (HasFracRegistrationThreshold) {
            output.WriteRawTag(69);
            output.WriteFloat(FracRegistrationThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasLowerScale) {
            output.WriteRawTag(13);
            output.WriteFloat(LowerScale);
          }
          if (HasUpperScale) {
            output.WriteRawTag(21);
            output.WriteFloat(UpperScale);
          }
          if (HasLimitRotation) {
            output.WriteRawTag(29);
            output.WriteFloat(LimitRotation);
          }
          if (HasLimitPerspective) {
            output.WriteRawTag(37);
            output.WriteFloat(LimitPerspective);
          }
          if (HasRegistrationThreshold) {
            output.WriteRawTag(45);
            output.WriteFloat(RegistrationThreshold);
          }
          if (HasMinInlierCoverage) {
            output.WriteRawTag(53);
            output.WriteFloat(MinInlierCoverage);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(FracInlierThreshold);
          }
          if (HasFracRegistrationThreshold) {
            output.WriteRawTag(69);
            output.WriteFloat(FracRegistrationThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasLowerScale) {
            size += 1 + 4;
          }
          if (HasUpperScale) {
            size += 1 + 4;
          }
          if (HasLimitRotation) {
            size += 1 + 4;
          }
          if (HasLimitPerspective) {
            size += 1 + 4;
          }
          if (HasRegistrationThreshold) {
            size += 1 + 4;
          }
          if (HasFracRegistrationThreshold) {
            size += 1 + 4;
          }
          if (HasMinInlierCoverage) {
            size += 1 + 4;
          }
          if (HasFracInlierThreshold) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HomographyBounds other) {
          if (other == null) {
            return;
          }
          if (other.HasLowerScale) {
            LowerScale = other.LowerScale;
          }
          if (other.HasUpperScale) {
            UpperScale = other.UpperScale;
          }
          if (other.HasLimitRotation) {
            LimitRotation = other.LimitRotation;
          }
          if (other.HasLimitPerspective) {
            LimitPerspective = other.LimitPerspective;
          }
          if (other.HasRegistrationThreshold) {
            RegistrationThreshold = other.RegistrationThreshold;
          }
          if (other.HasFracRegistrationThreshold) {
            FracRegistrationThreshold = other.FracRegistrationThreshold;
          }
          if (other.HasMinInlierCoverage) {
            MinInlierCoverage = other.MinInlierCoverage;
          }
          if (other.HasFracInlierThreshold) {
            FracInlierThreshold = other.FracInlierThreshold;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                LowerScale = input.ReadFloat();
                break;
              }
              case 21: {
                UpperScale = input.ReadFloat();
                break;
              }
              case 29: {
                LimitRotation = input.ReadFloat();
                break;
              }
              case 37: {
                LimitPerspective = input.ReadFloat();
                break;
              }
              case 45: {
                RegistrationThreshold = input.ReadFloat();
                break;
              }
              case 53: {
                MinInlierCoverage = input.ReadFloat();
                break;
              }
              case 61: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
              case 69: {
                FracRegistrationThreshold = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                LowerScale = input.ReadFloat();
                break;
              }
              case 21: {
                UpperScale = input.ReadFloat();
                break;
              }
              case 29: {
                LimitRotation = input.ReadFloat();
                break;
              }
              case 37: {
                LimitPerspective = input.ReadFloat();
                break;
              }
              case 45: {
                RegistrationThreshold = input.ReadFloat();
                break;
              }
              case 53: {
                MinInlierCoverage = input.ReadFloat();
                break;
              }
              case 61: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
              case 69: {
                FracRegistrationThreshold = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// If any parameter of the estimated homography mixture exceeds these bounds,
      /// we deem it UNSTABLE_HOMOG and use the estimated homography instead.
      /// </summary>
      public sealed partial class MixtureHomographyBounds : pb::IMessage<MixtureHomographyBounds>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MixtureHomographyBounds> _parser = new pb::MessageParser<MixtureHomographyBounds>(() => new MixtureHomographyBounds());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<MixtureHomographyBounds> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MixtureHomographyBounds() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MixtureHomographyBounds(MixtureHomographyBounds other) : this() {
          _hasBits0 = other._hasBits0;
          minInlierCoverage_ = other.minInlierCoverage_;
          maxAdjacentOutlierBlocks_ = other.maxAdjacentOutlierBlocks_;
          maxAdjacentEmptyBlocks_ = other.maxAdjacentEmptyBlocks_;
          fracInlierThreshold_ = other.fracInlierThreshold_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MixtureHomographyBounds Clone() {
          return new MixtureHomographyBounds(this);
        }

        /// <summary>Field number for the "min_inlier_coverage" field.</summary>
        public const int MinInlierCoverageFieldNumber = 1;
        private readonly static float MinInlierCoverageDefaultValue = 0.4F;

        private float minInlierCoverage_;
        /// <summary>
        /// Minimum fraction of inlier features w.r.t. block area.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinInlierCoverage {
          get { if ((_hasBits0 & 1) != 0) { return minInlierCoverage_; } else { return MinInlierCoverageDefaultValue; } }
          set {
            _hasBits0 |= 1;
            minInlierCoverage_ = value;
          }
        }
        /// <summary>Gets whether the "min_inlier_coverage" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMinInlierCoverage {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "min_inlier_coverage" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMinInlierCoverage() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "max_adjacent_outlier_blocks" field.</summary>
        public const int MaxAdjacentOutlierBlocksFieldNumber = 2;
        private readonly static int MaxAdjacentOutlierBlocksDefaultValue = 5;

        private int maxAdjacentOutlierBlocks_;
        /// <summary>
        /// Each block is tested to be stable, regarding the outliers.
        /// A frame is labeled unstable, if more or equal than the specified adjacent
        /// blocks are labeled outliers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MaxAdjacentOutlierBlocks {
          get { if ((_hasBits0 & 2) != 0) { return maxAdjacentOutlierBlocks_; } else { return MaxAdjacentOutlierBlocksDefaultValue; } }
          set {
            _hasBits0 |= 2;
            maxAdjacentOutlierBlocks_ = value;
          }
        }
        /// <summary>Gets whether the "max_adjacent_outlier_blocks" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxAdjacentOutlierBlocks {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "max_adjacent_outlier_blocks" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxAdjacentOutlierBlocks() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "max_adjacent_empty_blocks" field.</summary>
        public const int MaxAdjacentEmptyBlocksFieldNumber = 3;
        private readonly static int MaxAdjacentEmptyBlocksDefaultValue = 3;

        private int maxAdjacentEmptyBlocks_;
        /// <summary>
        /// Maximum number of adjacent empty blocks (no inliers).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MaxAdjacentEmptyBlocks {
          get { if ((_hasBits0 & 4) != 0) { return maxAdjacentEmptyBlocks_; } else { return MaxAdjacentEmptyBlocksDefaultValue; } }
          set {
            _hasBits0 |= 4;
            maxAdjacentEmptyBlocks_ = value;
          }
        }
        /// <summary>Gets whether the "max_adjacent_empty_blocks" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxAdjacentEmptyBlocks {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "max_adjacent_empty_blocks" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxAdjacentEmptyBlocks() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "frac_inlier_threshold" field.</summary>
        public const int FracInlierThresholdFieldNumber = 7;
        private readonly static float FracInlierThresholdDefaultValue = 0.0025F;

        private float fracInlierThreshold_;
        /// <summary>
        /// Grid coverage threshold inlier threshold. See identical parameter in
        /// HomographyBounds.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float FracInlierThreshold {
          get { if ((_hasBits0 & 8) != 0) { return fracInlierThreshold_; } else { return FracInlierThresholdDefaultValue; } }
          set {
            _hasBits0 |= 8;
            fracInlierThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "frac_inlier_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFracInlierThreshold {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "frac_inlier_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFracInlierThreshold() {
          _hasBits0 &= ~8;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as MixtureHomographyBounds);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(MixtureHomographyBounds other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinInlierCoverage, other.MinInlierCoverage)) return false;
          if (MaxAdjacentOutlierBlocks != other.MaxAdjacentOutlierBlocks) return false;
          if (MaxAdjacentEmptyBlocks != other.MaxAdjacentEmptyBlocks) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(FracInlierThreshold, other.FracInlierThreshold)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMinInlierCoverage) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinInlierCoverage);
          if (HasMaxAdjacentOutlierBlocks) hash ^= MaxAdjacentOutlierBlocks.GetHashCode();
          if (HasMaxAdjacentEmptyBlocks) hash ^= MaxAdjacentEmptyBlocks.GetHashCode();
          if (HasFracInlierThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(FracInlierThreshold);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasMinInlierCoverage) {
            output.WriteRawTag(13);
            output.WriteFloat(MinInlierCoverage);
          }
          if (HasMaxAdjacentOutlierBlocks) {
            output.WriteRawTag(16);
            output.WriteInt32(MaxAdjacentOutlierBlocks);
          }
          if (HasMaxAdjacentEmptyBlocks) {
            output.WriteRawTag(24);
            output.WriteInt32(MaxAdjacentEmptyBlocks);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(FracInlierThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMinInlierCoverage) {
            output.WriteRawTag(13);
            output.WriteFloat(MinInlierCoverage);
          }
          if (HasMaxAdjacentOutlierBlocks) {
            output.WriteRawTag(16);
            output.WriteInt32(MaxAdjacentOutlierBlocks);
          }
          if (HasMaxAdjacentEmptyBlocks) {
            output.WriteRawTag(24);
            output.WriteInt32(MaxAdjacentEmptyBlocks);
          }
          if (HasFracInlierThreshold) {
            output.WriteRawTag(61);
            output.WriteFloat(FracInlierThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasMinInlierCoverage) {
            size += 1 + 4;
          }
          if (HasMaxAdjacentOutlierBlocks) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxAdjacentOutlierBlocks);
          }
          if (HasMaxAdjacentEmptyBlocks) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxAdjacentEmptyBlocks);
          }
          if (HasFracInlierThreshold) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(MixtureHomographyBounds other) {
          if (other == null) {
            return;
          }
          if (other.HasMinInlierCoverage) {
            MinInlierCoverage = other.MinInlierCoverage;
          }
          if (other.HasMaxAdjacentOutlierBlocks) {
            MaxAdjacentOutlierBlocks = other.MaxAdjacentOutlierBlocks;
          }
          if (other.HasMaxAdjacentEmptyBlocks) {
            MaxAdjacentEmptyBlocks = other.MaxAdjacentEmptyBlocks;
          }
          if (other.HasFracInlierThreshold) {
            FracInlierThreshold = other.FracInlierThreshold;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                MinInlierCoverage = input.ReadFloat();
                break;
              }
              case 16: {
                MaxAdjacentOutlierBlocks = input.ReadInt32();
                break;
              }
              case 24: {
                MaxAdjacentEmptyBlocks = input.ReadInt32();
                break;
              }
              case 61: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                MinInlierCoverage = input.ReadFloat();
                break;
              }
              case 16: {
                MaxAdjacentOutlierBlocks = input.ReadInt32();
                break;
              }
              case 24: {
                MaxAdjacentEmptyBlocks = input.ReadInt32();
                break;
              }
              case 61: {
                FracInlierThreshold = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class OverlayDetectionOptions : pb::IMessage<OverlayDetectionOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OverlayDetectionOptions> _parser = new pb::MessageParser<OverlayDetectionOptions>(() => new OverlayDetectionOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OverlayDetectionOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[9]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OverlayDetectionOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OverlayDetectionOptions(OverlayDetectionOptions other) : this() {
          _hasBits0 = other._hasBits0;
          analysisMaskSize_ = other.analysisMaskSize_;
          strictNearZeroMotion_ = other.strictNearZeroMotion_;
          strictMaxTranslationRatio_ = other.strictMaxTranslationRatio_;
          strictMinTexturedness_ = other.strictMinTexturedness_;
          looseNearZeroMotion_ = other.looseNearZeroMotion_;
          overlayMinRatio_ = other.overlayMinRatio_;
          overlayMinFeatures_ = other.overlayMinFeatures_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OverlayDetectionOptions Clone() {
          return new OverlayDetectionOptions(this);
        }

        /// <summary>Field number for the "analysis_mask_size" field.</summary>
        public const int AnalysisMaskSizeFieldNumber = 1;
        private readonly static int AnalysisMaskSizeDefaultValue = 10;

        private int analysisMaskSize_;
        /// <summary>
        /// Potential overlay features are aggregated over a mask with cells
        /// mask_size x mask_size as specified below.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int AnalysisMaskSize {
          get { if ((_hasBits0 & 1) != 0) { return analysisMaskSize_; } else { return AnalysisMaskSizeDefaultValue; } }
          set {
            _hasBits0 |= 1;
            analysisMaskSize_ = value;
          }
        }
        /// <summary>Gets whether the "analysis_mask_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAnalysisMaskSize {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "analysis_mask_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAnalysisMaskSize() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "strict_near_zero_motion" field.</summary>
        public const int StrictNearZeroMotionFieldNumber = 2;
        private readonly static float StrictNearZeroMotionDefaultValue = 0.2F;

        private float strictNearZeroMotion_;
        /// <summary>
        /// A feature is a strict overlay feature if its motion is less than
        /// near_zero_motion and AND less than max_translation_ratio times the
        /// estimated translation magnitude at that frame AND is texturedness is
        /// sufficiently high.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float StrictNearZeroMotion {
          get { if ((_hasBits0 & 2) != 0) { return strictNearZeroMotion_; } else { return StrictNearZeroMotionDefaultValue; } }
          set {
            _hasBits0 |= 2;
            strictNearZeroMotion_ = value;
          }
        }
        /// <summary>Gets whether the "strict_near_zero_motion" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStrictNearZeroMotion {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "strict_near_zero_motion" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStrictNearZeroMotion() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "strict_max_translation_ratio" field.</summary>
        public const int StrictMaxTranslationRatioFieldNumber = 3;
        private readonly static float StrictMaxTranslationRatioDefaultValue = 0.2F;

        private float strictMaxTranslationRatio_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float StrictMaxTranslationRatio {
          get { if ((_hasBits0 & 4) != 0) { return strictMaxTranslationRatio_; } else { return StrictMaxTranslationRatioDefaultValue; } }
          set {
            _hasBits0 |= 4;
            strictMaxTranslationRatio_ = value;
          }
        }
        /// <summary>Gets whether the "strict_max_translation_ratio" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStrictMaxTranslationRatio {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "strict_max_translation_ratio" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStrictMaxTranslationRatio() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "strict_min_texturedness" field.</summary>
        public const int StrictMinTexturednessFieldNumber = 5;
        private readonly static float StrictMinTexturednessDefaultValue = 0.1F;

        private float strictMinTexturedness_;
        /// <summary>
        /// Minimum texturedness of a feature to be considered an overlay.
        /// Motivation: Overlays are mostly text or graphics, i.e. have visually
        /// distinguished features.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float StrictMinTexturedness {
          get { if ((_hasBits0 & 16) != 0) { return strictMinTexturedness_; } else { return StrictMinTexturednessDefaultValue; } }
          set {
            _hasBits0 |= 16;
            strictMinTexturedness_ = value;
          }
        }
        /// <summary>Gets whether the "strict_min_texturedness" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStrictMinTexturedness {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "strict_min_texturedness" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStrictMinTexturedness() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "loose_near_zero_motion" field.</summary>
        public const int LooseNearZeroMotionFieldNumber = 4;
        private readonly static float LooseNearZeroMotionDefaultValue = 1F;

        private float looseNearZeroMotion_;
        /// <summary>
        /// A feature is a loose overlay feature if its motion is less than
        /// loose_near_zero_motion.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float LooseNearZeroMotion {
          get { if ((_hasBits0 & 8) != 0) { return looseNearZeroMotion_; } else { return LooseNearZeroMotionDefaultValue; } }
          set {
            _hasBits0 |= 8;
            looseNearZeroMotion_ = value;
          }
        }
        /// <summary>Gets whether the "loose_near_zero_motion" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLooseNearZeroMotion {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "loose_near_zero_motion" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLooseNearZeroMotion() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "overlay_min_ratio" field.</summary>
        public const int OverlayMinRatioFieldNumber = 6;
        private readonly static float OverlayMinRatioDefaultValue = 0.3F;

        private float overlayMinRatio_;
        /// <summary>
        /// Minimum fraction of strict overlay features within a cell to be
        /// considered an overlay cell.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float OverlayMinRatio {
          get { if ((_hasBits0 & 32) != 0) { return overlayMinRatio_; } else { return OverlayMinRatioDefaultValue; } }
          set {
            _hasBits0 |= 32;
            overlayMinRatio_ = value;
          }
        }
        /// <summary>Gets whether the "overlay_min_ratio" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOverlayMinRatio {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "overlay_min_ratio" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOverlayMinRatio() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "overlay_min_features" field.</summary>
        public const int OverlayMinFeaturesFieldNumber = 7;
        private readonly static float OverlayMinFeaturesDefaultValue = 10F;

        private float overlayMinFeatures_;
        /// <summary>
        /// Absolute minimum number of strict overlay features within a cell to be
        /// considered an overlay cel..
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float OverlayMinFeatures {
          get { if ((_hasBits0 & 64) != 0) { return overlayMinFeatures_; } else { return OverlayMinFeaturesDefaultValue; } }
          set {
            _hasBits0 |= 64;
            overlayMinFeatures_ = value;
          }
        }
        /// <summary>Gets whether the "overlay_min_features" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOverlayMinFeatures {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "overlay_min_features" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOverlayMinFeatures() {
          _hasBits0 &= ~64;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OverlayDetectionOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OverlayDetectionOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (AnalysisMaskSize != other.AnalysisMaskSize) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StrictNearZeroMotion, other.StrictNearZeroMotion)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StrictMaxTranslationRatio, other.StrictMaxTranslationRatio)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StrictMinTexturedness, other.StrictMinTexturedness)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LooseNearZeroMotion, other.LooseNearZeroMotion)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlayMinRatio, other.OverlayMinRatio)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlayMinFeatures, other.OverlayMinFeatures)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasAnalysisMaskSize) hash ^= AnalysisMaskSize.GetHashCode();
          if (HasStrictNearZeroMotion) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StrictNearZeroMotion);
          if (HasStrictMaxTranslationRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StrictMaxTranslationRatio);
          if (HasStrictMinTexturedness) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StrictMinTexturedness);
          if (HasLooseNearZeroMotion) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LooseNearZeroMotion);
          if (HasOverlayMinRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlayMinRatio);
          if (HasOverlayMinFeatures) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlayMinFeatures);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasAnalysisMaskSize) {
            output.WriteRawTag(8);
            output.WriteInt32(AnalysisMaskSize);
          }
          if (HasStrictNearZeroMotion) {
            output.WriteRawTag(21);
            output.WriteFloat(StrictNearZeroMotion);
          }
          if (HasStrictMaxTranslationRatio) {
            output.WriteRawTag(29);
            output.WriteFloat(StrictMaxTranslationRatio);
          }
          if (HasLooseNearZeroMotion) {
            output.WriteRawTag(37);
            output.WriteFloat(LooseNearZeroMotion);
          }
          if (HasStrictMinTexturedness) {
            output.WriteRawTag(45);
            output.WriteFloat(StrictMinTexturedness);
          }
          if (HasOverlayMinRatio) {
            output.WriteRawTag(53);
            output.WriteFloat(OverlayMinRatio);
          }
          if (HasOverlayMinFeatures) {
            output.WriteRawTag(61);
            output.WriteFloat(OverlayMinFeatures);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasAnalysisMaskSize) {
            output.WriteRawTag(8);
            output.WriteInt32(AnalysisMaskSize);
          }
          if (HasStrictNearZeroMotion) {
            output.WriteRawTag(21);
            output.WriteFloat(StrictNearZeroMotion);
          }
          if (HasStrictMaxTranslationRatio) {
            output.WriteRawTag(29);
            output.WriteFloat(StrictMaxTranslationRatio);
          }
          if (HasLooseNearZeroMotion) {
            output.WriteRawTag(37);
            output.WriteFloat(LooseNearZeroMotion);
          }
          if (HasStrictMinTexturedness) {
            output.WriteRawTag(45);
            output.WriteFloat(StrictMinTexturedness);
          }
          if (HasOverlayMinRatio) {
            output.WriteRawTag(53);
            output.WriteFloat(OverlayMinRatio);
          }
          if (HasOverlayMinFeatures) {
            output.WriteRawTag(61);
            output.WriteFloat(OverlayMinFeatures);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasAnalysisMaskSize) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(AnalysisMaskSize);
          }
          if (HasStrictNearZeroMotion) {
            size += 1 + 4;
          }
          if (HasStrictMaxTranslationRatio) {
            size += 1 + 4;
          }
          if (HasStrictMinTexturedness) {
            size += 1 + 4;
          }
          if (HasLooseNearZeroMotion) {
            size += 1 + 4;
          }
          if (HasOverlayMinRatio) {
            size += 1 + 4;
          }
          if (HasOverlayMinFeatures) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OverlayDetectionOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasAnalysisMaskSize) {
            AnalysisMaskSize = other.AnalysisMaskSize;
          }
          if (other.HasStrictNearZeroMotion) {
            StrictNearZeroMotion = other.StrictNearZeroMotion;
          }
          if (other.HasStrictMaxTranslationRatio) {
            StrictMaxTranslationRatio = other.StrictMaxTranslationRatio;
          }
          if (other.HasStrictMinTexturedness) {
            StrictMinTexturedness = other.StrictMinTexturedness;
          }
          if (other.HasLooseNearZeroMotion) {
            LooseNearZeroMotion = other.LooseNearZeroMotion;
          }
          if (other.HasOverlayMinRatio) {
            OverlayMinRatio = other.OverlayMinRatio;
          }
          if (other.HasOverlayMinFeatures) {
            OverlayMinFeatures = other.OverlayMinFeatures;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                AnalysisMaskSize = input.ReadInt32();
                break;
              }
              case 21: {
                StrictNearZeroMotion = input.ReadFloat();
                break;
              }
              case 29: {
                StrictMaxTranslationRatio = input.ReadFloat();
                break;
              }
              case 37: {
                LooseNearZeroMotion = input.ReadFloat();
                break;
              }
              case 45: {
                StrictMinTexturedness = input.ReadFloat();
                break;
              }
              case 53: {
                OverlayMinRatio = input.ReadFloat();
                break;
              }
              case 61: {
                OverlayMinFeatures = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                AnalysisMaskSize = input.ReadInt32();
                break;
              }
              case 21: {
                StrictNearZeroMotion = input.ReadFloat();
                break;
              }
              case 29: {
                StrictMaxTranslationRatio = input.ReadFloat();
                break;
              }
              case 37: {
                LooseNearZeroMotion = input.ReadFloat();
                break;
              }
              case 45: {
                StrictMinTexturedness = input.ReadFloat();
                break;
              }
              case 53: {
                OverlayMinRatio = input.ReadFloat();
                break;
              }
              case 61: {
                OverlayMinFeatures = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Shot boundaries are introduced in 3 different scenarios:
      /// a) Frame has zero tracked features w.r.t. previous frame
      /// b) Estimated motion is deemed invalid (CameraMotion::INVALID).
      /// c) Visual consistency is above threshold of two adjacent frames.
      /// </summary>
      public sealed partial class ShotBoundaryOptions : pb::IMessage<ShotBoundaryOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ShotBoundaryOptions> _parser = new pb::MessageParser<ShotBoundaryOptions>(() => new ShotBoundaryOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ShotBoundaryOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.MotionEstimationOptions.Descriptor.NestedTypes[10]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ShotBoundaryOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ShotBoundaryOptions(ShotBoundaryOptions other) : this() {
          _hasBits0 = other._hasBits0;
          motionConsistencyThreshold_ = other.motionConsistencyThreshold_;
          appearanceConsistencyThreshold_ = other.appearanceConsistencyThreshold_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ShotBoundaryOptions Clone() {
          return new ShotBoundaryOptions(this);
        }

        /// <summary>Field number for the "motion_consistency_threshold" field.</summary>
        public const int MotionConsistencyThresholdFieldNumber = 1;
        private readonly static float MotionConsistencyThresholdDefaultValue = 0.02F;

        private float motionConsistencyThreshold_;
        /// <summary>
        /// After cases a &amp; b are determined from features/camera motion, they
        /// are verified by ensuring visual consistency is above specified threshold,
        /// if visual consistency has been computed. Only if this is case will the
        /// frame be labeled as shot boundary. Motivation is, that there should
        /// always be some (even small) measurable increase in the frame difference
        /// at a shot boundary.
        /// Verification is only performed if visual_consistency has been evaluated
        /// (value >= 0).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MotionConsistencyThreshold {
          get { if ((_hasBits0 & 1) != 0) { return motionConsistencyThreshold_; } else { return MotionConsistencyThresholdDefaultValue; } }
          set {
            _hasBits0 |= 1;
            motionConsistencyThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "motion_consistency_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMotionConsistencyThreshold {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "motion_consistency_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMotionConsistencyThreshold() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "appearance_consistency_threshold" field.</summary>
        public const int AppearanceConsistencyThresholdFieldNumber = 2;
        private readonly static float AppearanceConsistencyThresholdDefaultValue = 0.075F;

        private float appearanceConsistencyThreshold_;
        /// <summary>
        /// Threshold for case c). Sometimes, motion estimation will miss shot
        /// boundaries. We define shot boundaries for which the visual consistency is
        /// higher than the specified threshold for at least two adjacent frames.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float AppearanceConsistencyThreshold {
          get { if ((_hasBits0 & 2) != 0) { return appearanceConsistencyThreshold_; } else { return AppearanceConsistencyThresholdDefaultValue; } }
          set {
            _hasBits0 |= 2;
            appearanceConsistencyThreshold_ = value;
          }
        }
        /// <summary>Gets whether the "appearance_consistency_threshold" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAppearanceConsistencyThreshold {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "appearance_consistency_threshold" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAppearanceConsistencyThreshold() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ShotBoundaryOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ShotBoundaryOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MotionConsistencyThreshold, other.MotionConsistencyThreshold)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AppearanceConsistencyThreshold, other.AppearanceConsistencyThreshold)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMotionConsistencyThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MotionConsistencyThreshold);
          if (HasAppearanceConsistencyThreshold) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AppearanceConsistencyThreshold);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasMotionConsistencyThreshold) {
            output.WriteRawTag(13);
            output.WriteFloat(MotionConsistencyThreshold);
          }
          if (HasAppearanceConsistencyThreshold) {
            output.WriteRawTag(21);
            output.WriteFloat(AppearanceConsistencyThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMotionConsistencyThreshold) {
            output.WriteRawTag(13);
            output.WriteFloat(MotionConsistencyThreshold);
          }
          if (HasAppearanceConsistencyThreshold) {
            output.WriteRawTag(21);
            output.WriteFloat(AppearanceConsistencyThreshold);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasMotionConsistencyThreshold) {
            size += 1 + 4;
          }
          if (HasAppearanceConsistencyThreshold) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ShotBoundaryOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasMotionConsistencyThreshold) {
            MotionConsistencyThreshold = other.MotionConsistencyThreshold;
          }
          if (other.HasAppearanceConsistencyThreshold) {
            AppearanceConsistencyThreshold = other.AppearanceConsistencyThreshold;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                MotionConsistencyThreshold = input.ReadFloat();
                break;
              }
              case 21: {
                AppearanceConsistencyThreshold = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 13: {
                MotionConsistencyThreshold = input.ReadFloat();
                break;
              }
              case 21: {
                AppearanceConsistencyThreshold = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code

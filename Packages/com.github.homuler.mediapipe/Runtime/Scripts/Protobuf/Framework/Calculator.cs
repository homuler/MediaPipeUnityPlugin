// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/framework/calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/framework/calculator.proto</summary>
  public static partial class CalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/framework/calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiRtZWRpYXBpcGUvZnJhbWV3b3JrL2NhbGN1bGF0b3IucHJvdG8SCW1lZGlh",
            "cGlwZRosbWVkaWFwaXBlL2ZyYW1ld29yay9jYWxjdWxhdG9yX29wdGlvbnMu",
            "cHJvdG8aGWdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG8aK21lZGlhcGlwZS9m",
            "cmFtZXdvcmsvbWVkaWFwaXBlX29wdGlvbnMucHJvdG8aKG1lZGlhcGlwZS9m",
            "cmFtZXdvcmsvcGFja2V0X2ZhY3RvcnkucHJvdG8aKm1lZGlhcGlwZS9mcmFt",
            "ZXdvcmsvcGFja2V0X2dlbmVyYXRvci5wcm90bxoobWVkaWFwaXBlL2ZyYW1l",
            "d29yay9zdGF0dXNfaGFuZGxlci5wcm90bxoobWVkaWFwaXBlL2ZyYW1ld29y",
            "ay9zdHJlYW1faGFuZGxlci5wcm90byJaCg5FeGVjdXRvckNvbmZpZxIMCgRu",
            "YW1lGAEgASgJEgwKBHR5cGUYAiABKAkSLAoHb3B0aW9ucxgDIAEoCzIbLm1l",
            "ZGlhcGlwZS5NZWRpYVBpcGVPcHRpb25zIpECCg9JbnB1dENvbGxlY3Rpb24S",
            "DAoEbmFtZRgBIAEoCRIYChBzaWRlX3BhY2tldF9uYW1lGAIgAygJEhwKE2V4",
            "dGVybmFsX2lucHV0X25hbWUY6gcgAygJEjgKCmlucHV0X3R5cGUYAyABKA4y",
            "JC5tZWRpYXBpcGUuSW5wdXRDb2xsZWN0aW9uLklucHV0VHlwZRIRCglmaWxl",
            "X25hbWUYBCABKAkiawoJSW5wdXRUeXBlEgsKB1VOS05PV04QABIMCghSRUNP",
            "UkRJTxABEhQKEEZPUkVJR05fUkVDT1JESU8QAhIUChBGT1JFSUdOX0NTVl9U",
            "RVhUEAMSFwoTSU5WQUxJRF9VUFBFUl9CT1VORBAEIkoKEklucHV0Q29sbGVj",
            "dGlvblNldBI0ChBpbnB1dF9jb2xsZWN0aW9uGAEgAygLMhoubWVkaWFwaXBl",
            "LklucHV0Q29sbGVjdGlvbiI3Cg9JbnB1dFN0cmVhbUluZm8SEQoJdGFnX2lu",
            "ZGV4GAEgASgJEhEKCWJhY2tfZWRnZRgCIAEoCCLRBAoOUHJvZmlsZXJDb25m",
            "aWcSJAocaGlzdG9ncmFtX2ludGVydmFsX3NpemVfdXNlYxgBIAEoAxIfChdu",
            "dW1faGlzdG9ncmFtX2ludGVydmFscxgCIAEoAxInChtlbmFibGVfaW5wdXRf",
            "b3V0cHV0X2xhdGVuY3kYAyABKAhCAhgBEhcKD2VuYWJsZV9wcm9maWxlchgE",
            "IAEoCBIdChVlbmFibGVfc3RyZWFtX2xhdGVuY3kYBSABKAgSLQoldXNlX3Bh",
            "Y2tldF90aW1lc3RhbXBfZm9yX2FkZGVkX3BhY2tldBgGIAEoCBIaChJ0cmFj",
            "ZV9sb2dfY2FwYWNpdHkYByABKAMSIgoadHJhY2VfZXZlbnRfdHlwZXNfZGlz",
            "YWJsZWQYCCADKAUSFgoOdHJhY2VfbG9nX3BhdGgYCSABKAkSFwoPdHJhY2Vf",
            "bG9nX2NvdW50GAogASgFEh8KF3RyYWNlX2xvZ19pbnRlcnZhbF91c2VjGAsg",
            "ASgDEh0KFXRyYWNlX2xvZ19tYXJnaW5fdXNlYxgMIAEoAxIlChl0cmFjZV9s",
            "b2dfZHVyYXRpb25fZXZlbnRzGA0gASgIQgIYARIgChh0cmFjZV9sb2dfaW50",
            "ZXJ2YWxfY291bnQYDiABKAUSGgoSdHJhY2VfbG9nX2Rpc2FibGVkGA8gASgI",
            "EhUKDXRyYWNlX2VuYWJsZWQYECABKAgSIAoYdHJhY2VfbG9nX2luc3RhbnRf",
            "ZXZlbnRzGBEgASgIEhkKEWNhbGN1bGF0b3JfZmlsdGVyGBIgASgJIlgKFkdy",
            "YXBoUnVudGltZUluZm9Db25maWcSIQoZZW5hYmxlX2dyYXBoX3J1bnRpbWVf",
            "aW5mbxgBIAEoCBIbChNjYXB0dXJlX3BlcmlvZF9tc2VjGAIgASgNIq0LChVD",
            "YWxjdWxhdG9yR3JhcGhDb25maWcSMwoEbm9kZRgBIAMoCzIlLm1lZGlhcGlw",
            "ZS5DYWxjdWxhdG9yR3JhcGhDb25maWcuTm9kZRI2Cg5wYWNrZXRfZmFjdG9y",
            "eRgGIAMoCzIeLm1lZGlhcGlwZS5QYWNrZXRGYWN0b3J5Q29uZmlnEj4KEHBh",
            "Y2tldF9nZW5lcmF0b3IYByADKAsyIC5tZWRpYXBpcGUuUGFja2V0R2VuZXJh",
            "dG9yQ29uZmlnQgIYARITCgtudW1fdGhyZWFkcxgIIAEoBRI2Cg5zdGF0dXNf",
            "aGFuZGxlchgJIAMoCzIeLm1lZGlhcGlwZS5TdGF0dXNIYW5kbGVyQ29uZmln",
            "EhQKDGlucHV0X3N0cmVhbRgKIAMoCRIVCg1vdXRwdXRfc3RyZWFtGA8gAygJ",
            "EhkKEWlucHV0X3NpZGVfcGFja2V0GBAgAygJEhoKEm91dHB1dF9zaWRlX3Bh",
            "Y2tldBgRIAMoCRIWCg5tYXhfcXVldWVfc2l6ZRgLIAEoBRIXCg9yZXBvcnRf",
            "ZGVhZGxvY2sYFSABKAgSNwoMcnVudGltZV9pbmZvGBYgASgLMiEubWVkaWFw",
            "aXBlLkdyYXBoUnVudGltZUluZm9Db25maWcSQQoUaW5wdXRfc3RyZWFtX2hh",
            "bmRsZXIYDCABKAsyIy5tZWRpYXBpcGUuSW5wdXRTdHJlYW1IYW5kbGVyQ29u",
            "ZmlnEkMKFW91dHB1dF9zdHJlYW1faGFuZGxlchgNIAEoCzIkLm1lZGlhcGlw",
            "ZS5PdXRwdXRTdHJlYW1IYW5kbGVyQ29uZmlnEisKCGV4ZWN1dG9yGA4gAygL",
            "MhkubWVkaWFwaXBlLkV4ZWN1dG9yQ29uZmlnEjIKD3Byb2ZpbGVyX2NvbmZp",
            "ZxgSIAEoCzIZLm1lZGlhcGlwZS5Qcm9maWxlckNvbmZpZxIPCgdwYWNrYWdl",
            "GBMgASgJEgwKBHR5cGUYFCABKAkSLQoHb3B0aW9ucxjpByABKAsyGy5tZWRp",
            "YXBpcGUuTWVkaWFQaXBlT3B0aW9ucxIsCg1ncmFwaF9vcHRpb25zGOoHIAMo",
            "CzIULmdvb2dsZS5wcm90b2J1Zi5Bbnka5gQKBE5vZGUSDAoEbmFtZRgBIAEo",
            "CRISCgpjYWxjdWxhdG9yGAIgASgJEhQKDGlucHV0X3N0cmVhbRgDIAMoCRIV",
            "Cg1vdXRwdXRfc3RyZWFtGAQgAygJEhkKEWlucHV0X3NpZGVfcGFja2V0GAUg",
            "AygJEhoKEm91dHB1dF9zaWRlX3BhY2tldBgGIAMoCRItCgdvcHRpb25zGAcg",
            "ASgLMhwubWVkaWFwaXBlLkNhbGN1bGF0b3JPcHRpb25zEioKDG5vZGVfb3B0",
            "aW9ucxgIIAMoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnkSFAoMc291cmNlX2xh",
            "eWVyGAkgASgFEhgKEGJ1ZmZlcl9zaXplX2hpbnQYCiABKAUSQQoUaW5wdXRf",
            "c3RyZWFtX2hhbmRsZXIYCyABKAsyIy5tZWRpYXBpcGUuSW5wdXRTdHJlYW1I",
            "YW5kbGVyQ29uZmlnEkMKFW91dHB1dF9zdHJlYW1faGFuZGxlchgMIAEoCzIk",
            "Lm1lZGlhcGlwZS5PdXRwdXRTdHJlYW1IYW5kbGVyQ29uZmlnEjUKEWlucHV0",
            "X3N0cmVhbV9pbmZvGA0gAygLMhoubWVkaWFwaXBlLklucHV0U3RyZWFtSW5m",
            "bxIQCghleGVjdXRvchgOIAEoCRI2Cg9wcm9maWxlcl9jb25maWcYDyABKAsy",
            "GS5tZWRpYXBpcGUuUHJvZmlsZXJDb25maWdCAhgBEhUKDW1heF9pbl9mbGln",
            "aHQYECABKAUSFAoMb3B0aW9uX3ZhbHVlGBEgAygJEhcKDmV4dGVybmFsX2lu",
            "cHV0GO0HIAMoCUItChpjb20uZ29vZ2xlLm1lZGlhcGlwZS5wcm90b0IPQ2Fs",
            "Y3VsYXRvclByb3RvUABiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorOptionsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Mediapipe.MediapipeOptionsReflection.Descriptor, global::Mediapipe.PacketFactoryReflection.Descriptor, global::Mediapipe.PacketGeneratorReflection.Descriptor, global::Mediapipe.StatusHandlerReflection.Descriptor, global::Mediapipe.StreamHandlerReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ExecutorConfig), global::Mediapipe.ExecutorConfig.Parser, new[]{ "Name", "Type", "Options" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InputCollection), global::Mediapipe.InputCollection.Parser, new[]{ "Name", "SidePacketName", "ExternalInputName", "InputType", "FileName" }, null, new[]{ typeof(global::Mediapipe.InputCollection.Types.InputType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InputCollectionSet), global::Mediapipe.InputCollectionSet.Parser, new[]{ "InputCollection" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.InputStreamInfo), global::Mediapipe.InputStreamInfo.Parser, new[]{ "TagIndex", "BackEdge" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.ProfilerConfig), global::Mediapipe.ProfilerConfig.Parser, new[]{ "HistogramIntervalSizeUsec", "NumHistogramIntervals", "EnableInputOutputLatency", "EnableProfiler", "EnableStreamLatency", "UsePacketTimestampForAddedPacket", "TraceLogCapacity", "TraceEventTypesDisabled", "TraceLogPath", "TraceLogCount", "TraceLogIntervalUsec", "TraceLogMarginUsec", "TraceLogDurationEvents", "TraceLogIntervalCount", "TraceLogDisabled", "TraceEnabled", "TraceLogInstantEvents", "CalculatorFilter" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.GraphRuntimeInfoConfig), global::Mediapipe.GraphRuntimeInfoConfig.Parser, new[]{ "EnableGraphRuntimeInfo", "CapturePeriodMsec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.CalculatorGraphConfig), global::Mediapipe.CalculatorGraphConfig.Parser, new[]{ "Node", "PacketFactory", "PacketGenerator", "NumThreads", "StatusHandler", "InputStream", "OutputStream", "InputSidePacket", "OutputSidePacket", "MaxQueueSize", "ReportDeadlock", "RuntimeInfo", "InputStreamHandler", "OutputStreamHandler", "Executor", "ProfilerConfig", "Package", "Type", "Options", "GraphOptions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.CalculatorGraphConfig.Types.Node), global::Mediapipe.CalculatorGraphConfig.Types.Node.Parser, new[]{ "Name", "Calculator", "InputStream", "OutputStream", "InputSidePacket", "OutputSidePacket", "Options", "NodeOptions", "SourceLayer", "BufferSizeHint", "InputStreamHandler", "OutputStreamHandler", "InputStreamInfo", "Executor", "ProfilerConfig", "MaxInFlight", "OptionValue", "ExternalInput" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Describes a MediaPipe Executor.
  /// </summary>
  public sealed partial class ExecutorConfig : pb::IMessage<ExecutorConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExecutorConfig> _parser = new pb::MessageParser<ExecutorConfig>(() => new ExecutorConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExecutorConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecutorConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecutorConfig(ExecutorConfig other) : this() {
      name_ = other.name_;
      type_ = other.type_;
      options_ = other.options_ != null ? other.options_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecutorConfig Clone() {
      return new ExecutorConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the executor (used by a CalculatorGraphConfig::Node or
    /// PacketGeneratorConfig to specify which executor it will execute on).
    /// This field must be unique within a CalculatorGraphConfig. If this field
    /// is omitted or is an empty string, the ExecutorConfig describes the
    /// default executor.
    ///
    /// NOTE: The names "default" and "gpu" are reserved and must not be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private string type_ = "";
    /// <summary>
    /// The registered type of the executor. For example: "ThreadPoolExecutor".
    /// The framework will create an executor of this type (with the options in
    /// the options field) for the CalculatorGraph.
    ///
    /// The ExecutorConfig for the default executor may omit this field and let
    /// the framework choose an appropriate executor type. Note: If the options
    /// field is used in this case, it should contain the
    /// ThreadPoolExecutorOptions.
    ///
    /// If the ExecutorConfig for an additional (non-default) executor omits this
    /// field, the executor must be created outside the CalculatorGraph and
    /// passed to the CalculatorGraph for use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 3;
    private global::Mediapipe.MediaPipeOptions options_;
    /// <summary>
    /// The options passed to the Executor. The extension in the options field
    /// must match the type field. For example, if the type field is
    /// "ThreadPoolExecutor", then the options field should contain the
    /// ThreadPoolExecutorOptions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MediaPipeOptions Options {
      get { return options_; }
      set {
        options_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExecutorConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExecutorConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(Options, other.Options)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Type.Length != 0) hash ^= Type.GetHashCode();
      if (options_ != null) hash ^= Options.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (options_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Options);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (options_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Options);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Type.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (options_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExecutorConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Type.Length != 0) {
        Type = other.Type;
      }
      if (other.options_ != null) {
        if (options_ == null) {
          Options = new global::Mediapipe.MediaPipeOptions();
        }
        Options.MergeFrom(other.Options);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
          case 26: {
            if (options_ == null) {
              Options = new global::Mediapipe.MediaPipeOptions();
            }
            input.ReadMessage(Options);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
          case 26: {
            if (options_ == null) {
              Options = new global::Mediapipe.MediaPipeOptions();
            }
            input.ReadMessage(Options);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A collection of input data to a CalculatorGraph.
  /// </summary>
  public sealed partial class InputCollection : pb::IMessage<InputCollection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InputCollection> _parser = new pb::MessageParser<InputCollection>(() => new InputCollection());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InputCollection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollection(InputCollection other) : this() {
      name_ = other.name_;
      sidePacketName_ = other.sidePacketName_.Clone();
      externalInputName_ = other.externalInputName_.Clone();
      inputType_ = other.inputType_;
      fileName_ = other.fileName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollection Clone() {
      return new InputCollection(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the input collection.  Name must match [a-z_][a-z0-9_]*
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "side_packet_name" field.</summary>
    public const int SidePacketNameFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_sidePacketName_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> sidePacketName_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The names of each side packet.  The number of side_packet_name
    /// must match the number of packets generated by the input file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> SidePacketName {
      get { return sidePacketName_; }
    }

    /// <summary>Field number for the "external_input_name" field.</summary>
    public const int ExternalInputNameFieldNumber = 1002;
    private static readonly pb::FieldCodec<string> _repeated_externalInputName_codec
        = pb::FieldCodec.ForString(8018);
    private readonly pbc::RepeatedField<string> externalInputName_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// DEPRECATED: old way of referring to side_packet_name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ExternalInputName {
      get { return externalInputName_; }
    }

    /// <summary>Field number for the "input_type" field.</summary>
    public const int InputTypeFieldNumber = 3;
    private global::Mediapipe.InputCollection.Types.InputType inputType_ = global::Mediapipe.InputCollection.Types.InputType.Unknown;
    /// <summary>
    /// Sets the source of the input collection data.
    /// The default value is UNKNOWN.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.InputCollection.Types.InputType InputType {
      get { return inputType_; }
      set {
        inputType_ = value;
      }
    }

    /// <summary>Field number for the "file_name" field.</summary>
    public const int FileNameFieldNumber = 4;
    private string fileName_ = "";
    /// <summary>
    /// A file name pointing to the data.  The format of the data is
    /// specified by the "input_type" field.  Multiple shards may be
    /// specified using @N or glob expressions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FileName {
      get { return fileName_; }
      set {
        fileName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InputCollection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InputCollection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!sidePacketName_.Equals(other.sidePacketName_)) return false;
      if(!externalInputName_.Equals(other.externalInputName_)) return false;
      if (InputType != other.InputType) return false;
      if (FileName != other.FileName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= sidePacketName_.GetHashCode();
      hash ^= externalInputName_.GetHashCode();
      if (InputType != global::Mediapipe.InputCollection.Types.InputType.Unknown) hash ^= InputType.GetHashCode();
      if (FileName.Length != 0) hash ^= FileName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      sidePacketName_.WriteTo(output, _repeated_sidePacketName_codec);
      if (InputType != global::Mediapipe.InputCollection.Types.InputType.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) InputType);
      }
      if (FileName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(FileName);
      }
      externalInputName_.WriteTo(output, _repeated_externalInputName_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      sidePacketName_.WriteTo(ref output, _repeated_sidePacketName_codec);
      if (InputType != global::Mediapipe.InputCollection.Types.InputType.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) InputType);
      }
      if (FileName.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(FileName);
      }
      externalInputName_.WriteTo(ref output, _repeated_externalInputName_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += sidePacketName_.CalculateSize(_repeated_sidePacketName_codec);
      size += externalInputName_.CalculateSize(_repeated_externalInputName_codec);
      if (InputType != global::Mediapipe.InputCollection.Types.InputType.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InputType);
      }
      if (FileName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FileName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InputCollection other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      sidePacketName_.Add(other.sidePacketName_);
      externalInputName_.Add(other.externalInputName_);
      if (other.InputType != global::Mediapipe.InputCollection.Types.InputType.Unknown) {
        InputType = other.InputType;
      }
      if (other.FileName.Length != 0) {
        FileName = other.FileName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            sidePacketName_.AddEntriesFrom(input, _repeated_sidePacketName_codec);
            break;
          }
          case 24: {
            InputType = (global::Mediapipe.InputCollection.Types.InputType) input.ReadEnum();
            break;
          }
          case 34: {
            FileName = input.ReadString();
            break;
          }
          case 8018: {
            externalInputName_.AddEntriesFrom(input, _repeated_externalInputName_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            sidePacketName_.AddEntriesFrom(ref input, _repeated_sidePacketName_codec);
            break;
          }
          case 24: {
            InputType = (global::Mediapipe.InputCollection.Types.InputType) input.ReadEnum();
            break;
          }
          case 34: {
            FileName = input.ReadString();
            break;
          }
          case 8018: {
            externalInputName_.AddEntriesFrom(ref input, _repeated_externalInputName_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the InputCollection message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The input can be specified in several ways.
      /// </summary>
      public enum InputType {
        /// <summary>
        /// An invalid default value.  This value is guaranteed to be the
        /// lowest enum value (i.e. don't add negative enum values).
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// A recordio where each record is a serialized PacketManagerConfig.
        /// Each PacketManagerConfig must have the same number of packet
        /// factories in it as the number of side packet names.  Furthermore,
        /// the output side packet name field in each PacketFactoryConfig
        /// must not be set.  This is the most general input, and allows
        /// multiple side packet values to be set in arbitrarily complicated
        /// ways before each run.
        /// </summary>
        [pbr::OriginalName("RECORDIO")] Recordio = 1,
        /// <summary>
        /// A recordio where each record is a serialized packet payload.
        /// For example a recordio of serialized OmniaFeature protos dumped
        /// from Omnia.
        /// </summary>
        [pbr::OriginalName("FOREIGN_RECORDIO")] ForeignRecordio = 2,
        /// <summary>
        /// A text file where each line is a comma separated list. The number
        /// of elements for each csv string must be the same as the number
        /// of side_packet_name (and the order must match).  Each line must
        /// be less than 1MiB in size.  Lines comprising of only whitespace
        /// or only whitespace and a pound comment will be skipped.
        /// </summary>
        [pbr::OriginalName("FOREIGN_CSV_TEXT")] ForeignCsvText = 3,
        /// <summary>
        /// This and all higher values are invalid.  Update this value to
        /// always be larger than any other enum values you add.
        /// </summary>
        [pbr::OriginalName("INVALID_UPPER_BOUND")] InvalidUpperBound = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// A convenient way to specify a number of InputCollections.
  /// </summary>
  public sealed partial class InputCollectionSet : pb::IMessage<InputCollectionSet>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InputCollectionSet> _parser = new pb::MessageParser<InputCollectionSet>(() => new InputCollectionSet());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InputCollectionSet> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollectionSet() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollectionSet(InputCollectionSet other) : this() {
      inputCollection_ = other.inputCollection_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputCollectionSet Clone() {
      return new InputCollectionSet(this);
    }

    /// <summary>Field number for the "input_collection" field.</summary>
    public const int InputCollectionFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mediapipe.InputCollection> _repeated_inputCollection_codec
        = pb::FieldCodec.ForMessage(10, global::Mediapipe.InputCollection.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.InputCollection> inputCollection_ = new pbc::RepeatedField<global::Mediapipe.InputCollection>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.InputCollection> InputCollection {
      get { return inputCollection_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InputCollectionSet);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InputCollectionSet other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!inputCollection_.Equals(other.inputCollection_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= inputCollection_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      inputCollection_.WriteTo(output, _repeated_inputCollection_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      inputCollection_.WriteTo(ref output, _repeated_inputCollection_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += inputCollection_.CalculateSize(_repeated_inputCollection_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InputCollectionSet other) {
      if (other == null) {
        return;
      }
      inputCollection_.Add(other.inputCollection_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            inputCollection_.AddEntriesFrom(input, _repeated_inputCollection_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            inputCollection_.AddEntriesFrom(ref input, _repeated_inputCollection_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Additional information about an input stream.
  /// </summary>
  public sealed partial class InputStreamInfo : pb::IMessage<InputStreamInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InputStreamInfo> _parser = new pb::MessageParser<InputStreamInfo>(() => new InputStreamInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InputStreamInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputStreamInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputStreamInfo(InputStreamInfo other) : this() {
      tagIndex_ = other.tagIndex_;
      backEdge_ = other.backEdge_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputStreamInfo Clone() {
      return new InputStreamInfo(this);
    }

    /// <summary>Field number for the "tag_index" field.</summary>
    public const int TagIndexFieldNumber = 1;
    private string tagIndex_ = "";
    /// <summary>
    /// A description of the input stream.
    /// This description uses the Calculator visible specification of
    /// a stream.  The format is a tag, then an index with both being
    /// optional.  If the tag is missing it is assumed to be "" and if
    /// the index is missing then it is assumed to be 0.  If the index
    /// is provided then a colon (':') must be used.
    /// Examples:
    ///   "TAG"     -> tag "TAG",   index 0
    ///   ""        -> tag "",      index 0
    ///   ":0"      -> tag "",      index 0
    ///   ":3"      -> tag "",      index 3
    ///   "VIDEO:0" -> tag "VIDEO", index 0
    ///   "VIDEO:2" -> tag "VIDEO", index 2
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TagIndex {
      get { return tagIndex_; }
      set {
        tagIndex_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "back_edge" field.</summary>
    public const int BackEdgeFieldNumber = 2;
    private bool backEdge_;
    /// <summary>
    /// Whether the input stream is a back edge.
    /// By default, MediaPipe requires graphs to be acyclic and treats cycles in a
    /// graph as errors. To allow MediaPipe to accept a cyclic graph, set the
    /// back_edge fields of the input streams that are back edges to true. A
    /// cyclic graph usually has an obvious forward direction, and a back edge
    /// goes in the opposite direction. For a formal definition of a back edge,
    /// please see https://en.wikipedia.org/wiki/Depth-first_search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool BackEdge {
      get { return backEdge_; }
      set {
        backEdge_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InputStreamInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InputStreamInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TagIndex != other.TagIndex) return false;
      if (BackEdge != other.BackEdge) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TagIndex.Length != 0) hash ^= TagIndex.GetHashCode();
      if (BackEdge != false) hash ^= BackEdge.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TagIndex.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TagIndex);
      }
      if (BackEdge != false) {
        output.WriteRawTag(16);
        output.WriteBool(BackEdge);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TagIndex.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TagIndex);
      }
      if (BackEdge != false) {
        output.WriteRawTag(16);
        output.WriteBool(BackEdge);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TagIndex.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TagIndex);
      }
      if (BackEdge != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InputStreamInfo other) {
      if (other == null) {
        return;
      }
      if (other.TagIndex.Length != 0) {
        TagIndex = other.TagIndex;
      }
      if (other.BackEdge != false) {
        BackEdge = other.BackEdge;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TagIndex = input.ReadString();
            break;
          }
          case 16: {
            BackEdge = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TagIndex = input.ReadString();
            break;
          }
          case 16: {
            BackEdge = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configs for the profiler for a calculator. Not applicable to subgraphs.
  /// </summary>
  public sealed partial class ProfilerConfig : pb::IMessage<ProfilerConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProfilerConfig> _parser = new pb::MessageParser<ProfilerConfig>(() => new ProfilerConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProfilerConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProfilerConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProfilerConfig(ProfilerConfig other) : this() {
      histogramIntervalSizeUsec_ = other.histogramIntervalSizeUsec_;
      numHistogramIntervals_ = other.numHistogramIntervals_;
      enableInputOutputLatency_ = other.enableInputOutputLatency_;
      enableProfiler_ = other.enableProfiler_;
      enableStreamLatency_ = other.enableStreamLatency_;
      usePacketTimestampForAddedPacket_ = other.usePacketTimestampForAddedPacket_;
      traceLogCapacity_ = other.traceLogCapacity_;
      traceEventTypesDisabled_ = other.traceEventTypesDisabled_.Clone();
      traceLogPath_ = other.traceLogPath_;
      traceLogCount_ = other.traceLogCount_;
      traceLogIntervalUsec_ = other.traceLogIntervalUsec_;
      traceLogMarginUsec_ = other.traceLogMarginUsec_;
      traceLogDurationEvents_ = other.traceLogDurationEvents_;
      traceLogIntervalCount_ = other.traceLogIntervalCount_;
      traceLogDisabled_ = other.traceLogDisabled_;
      traceEnabled_ = other.traceEnabled_;
      traceLogInstantEvents_ = other.traceLogInstantEvents_;
      calculatorFilter_ = other.calculatorFilter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProfilerConfig Clone() {
      return new ProfilerConfig(this);
    }

    /// <summary>Field number for the "histogram_interval_size_usec" field.</summary>
    public const int HistogramIntervalSizeUsecFieldNumber = 1;
    private long histogramIntervalSizeUsec_;
    /// <summary>
    /// Size of the runtimes histogram intervals (in microseconds) to generate the
    /// histogram of the Process() time. The last interval extends to +inf.
    /// If not specified, the interval is 1000000 usec = 1 sec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HistogramIntervalSizeUsec {
      get { return histogramIntervalSizeUsec_; }
      set {
        histogramIntervalSizeUsec_ = value;
      }
    }

    /// <summary>Field number for the "num_histogram_intervals" field.</summary>
    public const int NumHistogramIntervalsFieldNumber = 2;
    private long numHistogramIntervals_;
    /// <summary>
    /// Number of intervals to generate the histogram of the Process() runtime.
    /// If not specified, one interval is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long NumHistogramIntervals {
      get { return numHistogramIntervals_; }
      set {
        numHistogramIntervals_ = value;
      }
    }

    /// <summary>Field number for the "enable_input_output_latency" field.</summary>
    public const int EnableInputOutputLatencyFieldNumber = 3;
    private bool enableInputOutputLatency_;
    /// <summary>
    /// TODO: clean up after migration to MediaPipeProfiler.
    /// DEPRECATED: If true, the profiler also profiles the input output latency.
    /// Should be true only if the packet timestamps corresponds to the
    /// microseconds wall time from epoch.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableInputOutputLatency {
      get { return enableInputOutputLatency_; }
      set {
        enableInputOutputLatency_ = value;
      }
    }

    /// <summary>Field number for the "enable_profiler" field.</summary>
    public const int EnableProfilerFieldNumber = 4;
    private bool enableProfiler_;
    /// <summary>
    /// If true, the profiler starts profiling when graph is initialized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableProfiler {
      get { return enableProfiler_; }
      set {
        enableProfiler_ = value;
      }
    }

    /// <summary>Field number for the "enable_stream_latency" field.</summary>
    public const int EnableStreamLatencyFieldNumber = 5;
    private bool enableStreamLatency_;
    /// <summary>
    /// If true, the profiler also profiles the stream latency and input-output
    /// latency.
    /// No-op if enable_profiler is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableStreamLatency {
      get { return enableStreamLatency_; }
      set {
        enableStreamLatency_ = value;
      }
    }

    /// <summary>Field number for the "use_packet_timestamp_for_added_packet" field.</summary>
    public const int UsePacketTimestampForAddedPacketFieldNumber = 6;
    private bool usePacketTimestampForAddedPacket_;
    /// <summary>
    /// If true, the profiler uses packet timestamp (as production time and source
    /// production time) for packets added by calling
    /// CalculatorGraph::AddPacketToInputStream().
    /// If false, uses profiler's clock.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UsePacketTimestampForAddedPacket {
      get { return usePacketTimestampForAddedPacket_; }
      set {
        usePacketTimestampForAddedPacket_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_capacity" field.</summary>
    public const int TraceLogCapacityFieldNumber = 7;
    private long traceLogCapacity_;
    /// <summary>
    /// The maximum number of trace events buffered in memory.
    /// The default value buffers up to 20000 events.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TraceLogCapacity {
      get { return traceLogCapacity_; }
      set {
        traceLogCapacity_ = value;
      }
    }

    /// <summary>Field number for the "trace_event_types_disabled" field.</summary>
    public const int TraceEventTypesDisabledFieldNumber = 8;
    private static readonly pb::FieldCodec<int> _repeated_traceEventTypesDisabled_codec
        = pb::FieldCodec.ForInt32(66);
    private readonly pbc::RepeatedField<int> traceEventTypesDisabled_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Trace event types that are not logged.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> TraceEventTypesDisabled {
      get { return traceEventTypesDisabled_; }
    }

    /// <summary>Field number for the "trace_log_path" field.</summary>
    public const int TraceLogPathFieldNumber = 9;
    private string traceLogPath_ = "";
    /// <summary>
    /// The output directory and base-name prefix for trace log files.
    /// Log files are written to: StrCat(trace_log_path, index, ".binarypb")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TraceLogPath {
      get { return traceLogPath_; }
      set {
        traceLogPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trace_log_count" field.</summary>
    public const int TraceLogCountFieldNumber = 10;
    private int traceLogCount_;
    /// <summary>
    /// The number of trace log files retained.
    /// The trace log files are named "trace_0.log" through "trace_k.log".
    /// The default value specifies 2 output files retained.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TraceLogCount {
      get { return traceLogCount_; }
      set {
        traceLogCount_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_interval_usec" field.</summary>
    public const int TraceLogIntervalUsecFieldNumber = 11;
    private long traceLogIntervalUsec_;
    /// <summary>
    /// The interval in microseconds between trace log output.
    /// The default value specifies trace log output once every 0.5 sec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TraceLogIntervalUsec {
      get { return traceLogIntervalUsec_; }
      set {
        traceLogIntervalUsec_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_margin_usec" field.</summary>
    public const int TraceLogMarginUsecFieldNumber = 12;
    private long traceLogMarginUsec_;
    /// <summary>
    /// The interval in microseconds between TimeNow and the highest times
    /// included in trace log output.  This margin allows time for events
    /// to be appended to the TraceBuffer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TraceLogMarginUsec {
      get { return traceLogMarginUsec_; }
      set {
        traceLogMarginUsec_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_duration_events" field.</summary>
    public const int TraceLogDurationEventsFieldNumber = 13;
    private bool traceLogDurationEvents_;
    /// <summary>
    /// Deprecated, replaced by trace_log_instant_events.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TraceLogDurationEvents {
      get { return traceLogDurationEvents_; }
      set {
        traceLogDurationEvents_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_interval_count" field.</summary>
    public const int TraceLogIntervalCountFieldNumber = 14;
    private int traceLogIntervalCount_;
    /// <summary>
    /// The number of trace log intervals per file. The total log duration is:
    /// trace_log_interval_usec * trace_log_file_count * trace_log_interval_count.
    /// The default value specifies 10 intervals per file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TraceLogIntervalCount {
      get { return traceLogIntervalCount_; }
      set {
        traceLogIntervalCount_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_disabled" field.</summary>
    public const int TraceLogDisabledFieldNumber = 15;
    private bool traceLogDisabled_;
    /// <summary>
    /// An option to turn ON/OFF writing trace files to disk. Saving trace files to
    /// disk is enabled by default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TraceLogDisabled {
      get { return traceLogDisabled_; }
      set {
        traceLogDisabled_ = value;
      }
    }

    /// <summary>Field number for the "trace_enabled" field.</summary>
    public const int TraceEnabledFieldNumber = 16;
    private bool traceEnabled_;
    /// <summary>
    /// If true, tracer timing events are recorded and reported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TraceEnabled {
      get { return traceEnabled_; }
      set {
        traceEnabled_ = value;
      }
    }

    /// <summary>Field number for the "trace_log_instant_events" field.</summary>
    public const int TraceLogInstantEventsFieldNumber = 17;
    private bool traceLogInstantEvents_;
    /// <summary>
    /// False specifies an event for each calculator invocation.
    /// True specifies a separate event for each start and finish time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TraceLogInstantEvents {
      get { return traceLogInstantEvents_; }
      set {
        traceLogInstantEvents_ = value;
      }
    }

    /// <summary>Field number for the "calculator_filter" field.</summary>
    public const int CalculatorFilterFieldNumber = 18;
    private string calculatorFilter_ = "";
    /// <summary>
    /// Limits calculator-profile histograms to a subset of calculators.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CalculatorFilter {
      get { return calculatorFilter_; }
      set {
        calculatorFilter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProfilerConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProfilerConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HistogramIntervalSizeUsec != other.HistogramIntervalSizeUsec) return false;
      if (NumHistogramIntervals != other.NumHistogramIntervals) return false;
      if (EnableInputOutputLatency != other.EnableInputOutputLatency) return false;
      if (EnableProfiler != other.EnableProfiler) return false;
      if (EnableStreamLatency != other.EnableStreamLatency) return false;
      if (UsePacketTimestampForAddedPacket != other.UsePacketTimestampForAddedPacket) return false;
      if (TraceLogCapacity != other.TraceLogCapacity) return false;
      if(!traceEventTypesDisabled_.Equals(other.traceEventTypesDisabled_)) return false;
      if (TraceLogPath != other.TraceLogPath) return false;
      if (TraceLogCount != other.TraceLogCount) return false;
      if (TraceLogIntervalUsec != other.TraceLogIntervalUsec) return false;
      if (TraceLogMarginUsec != other.TraceLogMarginUsec) return false;
      if (TraceLogDurationEvents != other.TraceLogDurationEvents) return false;
      if (TraceLogIntervalCount != other.TraceLogIntervalCount) return false;
      if (TraceLogDisabled != other.TraceLogDisabled) return false;
      if (TraceEnabled != other.TraceEnabled) return false;
      if (TraceLogInstantEvents != other.TraceLogInstantEvents) return false;
      if (CalculatorFilter != other.CalculatorFilter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HistogramIntervalSizeUsec != 0L) hash ^= HistogramIntervalSizeUsec.GetHashCode();
      if (NumHistogramIntervals != 0L) hash ^= NumHistogramIntervals.GetHashCode();
      if (EnableInputOutputLatency != false) hash ^= EnableInputOutputLatency.GetHashCode();
      if (EnableProfiler != false) hash ^= EnableProfiler.GetHashCode();
      if (EnableStreamLatency != false) hash ^= EnableStreamLatency.GetHashCode();
      if (UsePacketTimestampForAddedPacket != false) hash ^= UsePacketTimestampForAddedPacket.GetHashCode();
      if (TraceLogCapacity != 0L) hash ^= TraceLogCapacity.GetHashCode();
      hash ^= traceEventTypesDisabled_.GetHashCode();
      if (TraceLogPath.Length != 0) hash ^= TraceLogPath.GetHashCode();
      if (TraceLogCount != 0) hash ^= TraceLogCount.GetHashCode();
      if (TraceLogIntervalUsec != 0L) hash ^= TraceLogIntervalUsec.GetHashCode();
      if (TraceLogMarginUsec != 0L) hash ^= TraceLogMarginUsec.GetHashCode();
      if (TraceLogDurationEvents != false) hash ^= TraceLogDurationEvents.GetHashCode();
      if (TraceLogIntervalCount != 0) hash ^= TraceLogIntervalCount.GetHashCode();
      if (TraceLogDisabled != false) hash ^= TraceLogDisabled.GetHashCode();
      if (TraceEnabled != false) hash ^= TraceEnabled.GetHashCode();
      if (TraceLogInstantEvents != false) hash ^= TraceLogInstantEvents.GetHashCode();
      if (CalculatorFilter.Length != 0) hash ^= CalculatorFilter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HistogramIntervalSizeUsec != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(HistogramIntervalSizeUsec);
      }
      if (NumHistogramIntervals != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(NumHistogramIntervals);
      }
      if (EnableInputOutputLatency != false) {
        output.WriteRawTag(24);
        output.WriteBool(EnableInputOutputLatency);
      }
      if (EnableProfiler != false) {
        output.WriteRawTag(32);
        output.WriteBool(EnableProfiler);
      }
      if (EnableStreamLatency != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableStreamLatency);
      }
      if (UsePacketTimestampForAddedPacket != false) {
        output.WriteRawTag(48);
        output.WriteBool(UsePacketTimestampForAddedPacket);
      }
      if (TraceLogCapacity != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TraceLogCapacity);
      }
      traceEventTypesDisabled_.WriteTo(output, _repeated_traceEventTypesDisabled_codec);
      if (TraceLogPath.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(TraceLogPath);
      }
      if (TraceLogCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(TraceLogCount);
      }
      if (TraceLogIntervalUsec != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(TraceLogIntervalUsec);
      }
      if (TraceLogMarginUsec != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(TraceLogMarginUsec);
      }
      if (TraceLogDurationEvents != false) {
        output.WriteRawTag(104);
        output.WriteBool(TraceLogDurationEvents);
      }
      if (TraceLogIntervalCount != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(TraceLogIntervalCount);
      }
      if (TraceLogDisabled != false) {
        output.WriteRawTag(120);
        output.WriteBool(TraceLogDisabled);
      }
      if (TraceEnabled != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(TraceEnabled);
      }
      if (TraceLogInstantEvents != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(TraceLogInstantEvents);
      }
      if (CalculatorFilter.Length != 0) {
        output.WriteRawTag(146, 1);
        output.WriteString(CalculatorFilter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HistogramIntervalSizeUsec != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(HistogramIntervalSizeUsec);
      }
      if (NumHistogramIntervals != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(NumHistogramIntervals);
      }
      if (EnableInputOutputLatency != false) {
        output.WriteRawTag(24);
        output.WriteBool(EnableInputOutputLatency);
      }
      if (EnableProfiler != false) {
        output.WriteRawTag(32);
        output.WriteBool(EnableProfiler);
      }
      if (EnableStreamLatency != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableStreamLatency);
      }
      if (UsePacketTimestampForAddedPacket != false) {
        output.WriteRawTag(48);
        output.WriteBool(UsePacketTimestampForAddedPacket);
      }
      if (TraceLogCapacity != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TraceLogCapacity);
      }
      traceEventTypesDisabled_.WriteTo(ref output, _repeated_traceEventTypesDisabled_codec);
      if (TraceLogPath.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(TraceLogPath);
      }
      if (TraceLogCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(TraceLogCount);
      }
      if (TraceLogIntervalUsec != 0L) {
        output.WriteRawTag(88);
        output.WriteInt64(TraceLogIntervalUsec);
      }
      if (TraceLogMarginUsec != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(TraceLogMarginUsec);
      }
      if (TraceLogDurationEvents != false) {
        output.WriteRawTag(104);
        output.WriteBool(TraceLogDurationEvents);
      }
      if (TraceLogIntervalCount != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(TraceLogIntervalCount);
      }
      if (TraceLogDisabled != false) {
        output.WriteRawTag(120);
        output.WriteBool(TraceLogDisabled);
      }
      if (TraceEnabled != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(TraceEnabled);
      }
      if (TraceLogInstantEvents != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(TraceLogInstantEvents);
      }
      if (CalculatorFilter.Length != 0) {
        output.WriteRawTag(146, 1);
        output.WriteString(CalculatorFilter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HistogramIntervalSizeUsec != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HistogramIntervalSizeUsec);
      }
      if (NumHistogramIntervals != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NumHistogramIntervals);
      }
      if (EnableInputOutputLatency != false) {
        size += 1 + 1;
      }
      if (EnableProfiler != false) {
        size += 1 + 1;
      }
      if (EnableStreamLatency != false) {
        size += 1 + 1;
      }
      if (UsePacketTimestampForAddedPacket != false) {
        size += 1 + 1;
      }
      if (TraceLogCapacity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TraceLogCapacity);
      }
      size += traceEventTypesDisabled_.CalculateSize(_repeated_traceEventTypesDisabled_codec);
      if (TraceLogPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TraceLogPath);
      }
      if (TraceLogCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TraceLogCount);
      }
      if (TraceLogIntervalUsec != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TraceLogIntervalUsec);
      }
      if (TraceLogMarginUsec != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TraceLogMarginUsec);
      }
      if (TraceLogDurationEvents != false) {
        size += 1 + 1;
      }
      if (TraceLogIntervalCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TraceLogIntervalCount);
      }
      if (TraceLogDisabled != false) {
        size += 1 + 1;
      }
      if (TraceEnabled != false) {
        size += 2 + 1;
      }
      if (TraceLogInstantEvents != false) {
        size += 2 + 1;
      }
      if (CalculatorFilter.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CalculatorFilter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProfilerConfig other) {
      if (other == null) {
        return;
      }
      if (other.HistogramIntervalSizeUsec != 0L) {
        HistogramIntervalSizeUsec = other.HistogramIntervalSizeUsec;
      }
      if (other.NumHistogramIntervals != 0L) {
        NumHistogramIntervals = other.NumHistogramIntervals;
      }
      if (other.EnableInputOutputLatency != false) {
        EnableInputOutputLatency = other.EnableInputOutputLatency;
      }
      if (other.EnableProfiler != false) {
        EnableProfiler = other.EnableProfiler;
      }
      if (other.EnableStreamLatency != false) {
        EnableStreamLatency = other.EnableStreamLatency;
      }
      if (other.UsePacketTimestampForAddedPacket != false) {
        UsePacketTimestampForAddedPacket = other.UsePacketTimestampForAddedPacket;
      }
      if (other.TraceLogCapacity != 0L) {
        TraceLogCapacity = other.TraceLogCapacity;
      }
      traceEventTypesDisabled_.Add(other.traceEventTypesDisabled_);
      if (other.TraceLogPath.Length != 0) {
        TraceLogPath = other.TraceLogPath;
      }
      if (other.TraceLogCount != 0) {
        TraceLogCount = other.TraceLogCount;
      }
      if (other.TraceLogIntervalUsec != 0L) {
        TraceLogIntervalUsec = other.TraceLogIntervalUsec;
      }
      if (other.TraceLogMarginUsec != 0L) {
        TraceLogMarginUsec = other.TraceLogMarginUsec;
      }
      if (other.TraceLogDurationEvents != false) {
        TraceLogDurationEvents = other.TraceLogDurationEvents;
      }
      if (other.TraceLogIntervalCount != 0) {
        TraceLogIntervalCount = other.TraceLogIntervalCount;
      }
      if (other.TraceLogDisabled != false) {
        TraceLogDisabled = other.TraceLogDisabled;
      }
      if (other.TraceEnabled != false) {
        TraceEnabled = other.TraceEnabled;
      }
      if (other.TraceLogInstantEvents != false) {
        TraceLogInstantEvents = other.TraceLogInstantEvents;
      }
      if (other.CalculatorFilter.Length != 0) {
        CalculatorFilter = other.CalculatorFilter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            HistogramIntervalSizeUsec = input.ReadInt64();
            break;
          }
          case 16: {
            NumHistogramIntervals = input.ReadInt64();
            break;
          }
          case 24: {
            EnableInputOutputLatency = input.ReadBool();
            break;
          }
          case 32: {
            EnableProfiler = input.ReadBool();
            break;
          }
          case 40: {
            EnableStreamLatency = input.ReadBool();
            break;
          }
          case 48: {
            UsePacketTimestampForAddedPacket = input.ReadBool();
            break;
          }
          case 56: {
            TraceLogCapacity = input.ReadInt64();
            break;
          }
          case 66:
          case 64: {
            traceEventTypesDisabled_.AddEntriesFrom(input, _repeated_traceEventTypesDisabled_codec);
            break;
          }
          case 74: {
            TraceLogPath = input.ReadString();
            break;
          }
          case 80: {
            TraceLogCount = input.ReadInt32();
            break;
          }
          case 88: {
            TraceLogIntervalUsec = input.ReadInt64();
            break;
          }
          case 96: {
            TraceLogMarginUsec = input.ReadInt64();
            break;
          }
          case 104: {
            TraceLogDurationEvents = input.ReadBool();
            break;
          }
          case 112: {
            TraceLogIntervalCount = input.ReadInt32();
            break;
          }
          case 120: {
            TraceLogDisabled = input.ReadBool();
            break;
          }
          case 128: {
            TraceEnabled = input.ReadBool();
            break;
          }
          case 136: {
            TraceLogInstantEvents = input.ReadBool();
            break;
          }
          case 146: {
            CalculatorFilter = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            HistogramIntervalSizeUsec = input.ReadInt64();
            break;
          }
          case 16: {
            NumHistogramIntervals = input.ReadInt64();
            break;
          }
          case 24: {
            EnableInputOutputLatency = input.ReadBool();
            break;
          }
          case 32: {
            EnableProfiler = input.ReadBool();
            break;
          }
          case 40: {
            EnableStreamLatency = input.ReadBool();
            break;
          }
          case 48: {
            UsePacketTimestampForAddedPacket = input.ReadBool();
            break;
          }
          case 56: {
            TraceLogCapacity = input.ReadInt64();
            break;
          }
          case 66:
          case 64: {
            traceEventTypesDisabled_.AddEntriesFrom(ref input, _repeated_traceEventTypesDisabled_codec);
            break;
          }
          case 74: {
            TraceLogPath = input.ReadString();
            break;
          }
          case 80: {
            TraceLogCount = input.ReadInt32();
            break;
          }
          case 88: {
            TraceLogIntervalUsec = input.ReadInt64();
            break;
          }
          case 96: {
            TraceLogMarginUsec = input.ReadInt64();
            break;
          }
          case 104: {
            TraceLogDurationEvents = input.ReadBool();
            break;
          }
          case 112: {
            TraceLogIntervalCount = input.ReadInt32();
            break;
          }
          case 120: {
            TraceLogDisabled = input.ReadBool();
            break;
          }
          case 128: {
            TraceEnabled = input.ReadBool();
            break;
          }
          case 136: {
            TraceLogInstantEvents = input.ReadBool();
            break;
          }
          case 146: {
            CalculatorFilter = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for the runtime info logger. It collects runtime information
  /// and statistics about calculators and their input streams at the configured
  /// capture rate and writes them to LOG(INFO). It can be used to inspect a
  /// stalled graph by understanding which calculators are waiting for input
  /// packets to triger their Process() method.
  /// </summary>
  public sealed partial class GraphRuntimeInfoConfig : pb::IMessage<GraphRuntimeInfoConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GraphRuntimeInfoConfig> _parser = new pb::MessageParser<GraphRuntimeInfoConfig>(() => new GraphRuntimeInfoConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GraphRuntimeInfoConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GraphRuntimeInfoConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GraphRuntimeInfoConfig(GraphRuntimeInfoConfig other) : this() {
      enableGraphRuntimeInfo_ = other.enableGraphRuntimeInfo_;
      capturePeriodMsec_ = other.capturePeriodMsec_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GraphRuntimeInfoConfig Clone() {
      return new GraphRuntimeInfoConfig(this);
    }

    /// <summary>Field number for the "enable_graph_runtime_info" field.</summary>
    public const int EnableGraphRuntimeInfoFieldNumber = 1;
    private bool enableGraphRuntimeInfo_;
    /// <summary>
    /// If true, the runtime info logger is enabled and runs in the background.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableGraphRuntimeInfo {
      get { return enableGraphRuntimeInfo_; }
      set {
        enableGraphRuntimeInfo_ = value;
      }
    }

    /// <summary>Field number for the "capture_period_msec" field.</summary>
    public const int CapturePeriodMsecFieldNumber = 2;
    private uint capturePeriodMsec_;
    /// <summary>
    /// The period in seconds at which the runtime info logger is updated. The
    /// default value is 10 secods.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint CapturePeriodMsec {
      get { return capturePeriodMsec_; }
      set {
        capturePeriodMsec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GraphRuntimeInfoConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GraphRuntimeInfoConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnableGraphRuntimeInfo != other.EnableGraphRuntimeInfo) return false;
      if (CapturePeriodMsec != other.CapturePeriodMsec) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (EnableGraphRuntimeInfo != false) hash ^= EnableGraphRuntimeInfo.GetHashCode();
      if (CapturePeriodMsec != 0) hash ^= CapturePeriodMsec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (EnableGraphRuntimeInfo != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnableGraphRuntimeInfo);
      }
      if (CapturePeriodMsec != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(CapturePeriodMsec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (EnableGraphRuntimeInfo != false) {
        output.WriteRawTag(8);
        output.WriteBool(EnableGraphRuntimeInfo);
      }
      if (CapturePeriodMsec != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(CapturePeriodMsec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (EnableGraphRuntimeInfo != false) {
        size += 1 + 1;
      }
      if (CapturePeriodMsec != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CapturePeriodMsec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GraphRuntimeInfoConfig other) {
      if (other == null) {
        return;
      }
      if (other.EnableGraphRuntimeInfo != false) {
        EnableGraphRuntimeInfo = other.EnableGraphRuntimeInfo;
      }
      if (other.CapturePeriodMsec != 0) {
        CapturePeriodMsec = other.CapturePeriodMsec;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnableGraphRuntimeInfo = input.ReadBool();
            break;
          }
          case 16: {
            CapturePeriodMsec = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnableGraphRuntimeInfo = input.ReadBool();
            break;
          }
          case 16: {
            CapturePeriodMsec = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes the topology and function of a MediaPipe Graph.  The graph of
  /// Nodes must be a Directed Acyclic Graph (DAG) except as annotated by
  /// "back_edge" in InputStreamInfo.  Use a mediapipe::CalculatorGraph object to
  /// run the graph.
  /// </summary>
  public sealed partial class CalculatorGraphConfig : pb::IMessage<CalculatorGraphConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CalculatorGraphConfig> _parser = new pb::MessageParser<CalculatorGraphConfig>(() => new CalculatorGraphConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CalculatorGraphConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.CalculatorReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CalculatorGraphConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CalculatorGraphConfig(CalculatorGraphConfig other) : this() {
      node_ = other.node_.Clone();
      packetFactory_ = other.packetFactory_.Clone();
      packetGenerator_ = other.packetGenerator_.Clone();
      numThreads_ = other.numThreads_;
      statusHandler_ = other.statusHandler_.Clone();
      inputStream_ = other.inputStream_.Clone();
      outputStream_ = other.outputStream_.Clone();
      inputSidePacket_ = other.inputSidePacket_.Clone();
      outputSidePacket_ = other.outputSidePacket_.Clone();
      maxQueueSize_ = other.maxQueueSize_;
      reportDeadlock_ = other.reportDeadlock_;
      runtimeInfo_ = other.runtimeInfo_ != null ? other.runtimeInfo_.Clone() : null;
      inputStreamHandler_ = other.inputStreamHandler_ != null ? other.inputStreamHandler_.Clone() : null;
      outputStreamHandler_ = other.outputStreamHandler_ != null ? other.outputStreamHandler_.Clone() : null;
      executor_ = other.executor_.Clone();
      profilerConfig_ = other.profilerConfig_ != null ? other.profilerConfig_.Clone() : null;
      package_ = other.package_;
      type_ = other.type_;
      options_ = other.options_ != null ? other.options_.Clone() : null;
      graphOptions_ = other.graphOptions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CalculatorGraphConfig Clone() {
      return new CalculatorGraphConfig(this);
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Mediapipe.CalculatorGraphConfig.Types.Node> _repeated_node_codec
        = pb::FieldCodec.ForMessage(10, global::Mediapipe.CalculatorGraphConfig.Types.Node.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.CalculatorGraphConfig.Types.Node> node_ = new pbc::RepeatedField<global::Mediapipe.CalculatorGraphConfig.Types.Node>();
    /// <summary>
    /// The nodes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.CalculatorGraphConfig.Types.Node> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "packet_factory" field.</summary>
    public const int PacketFactoryFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Mediapipe.PacketFactoryConfig> _repeated_packetFactory_codec
        = pb::FieldCodec.ForMessage(50, global::Mediapipe.PacketFactoryConfig.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.PacketFactoryConfig> packetFactory_ = new pbc::RepeatedField<global::Mediapipe.PacketFactoryConfig>();
    /// <summary>
    /// Create a side packet using a PacketFactory.  This side packet is
    /// created as close to the worker that does the work as possible.  A
    /// PacketFactory is basically a PacketGenerator that takes no input side
    /// packets and produces a single output side packet.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.PacketFactoryConfig> PacketFactory {
      get { return packetFactory_; }
    }

    /// <summary>Field number for the "packet_generator" field.</summary>
    public const int PacketGeneratorFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Mediapipe.PacketGeneratorConfig> _repeated_packetGenerator_codec
        = pb::FieldCodec.ForMessage(58, global::Mediapipe.PacketGeneratorConfig.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.PacketGeneratorConfig> packetGenerator_ = new pbc::RepeatedField<global::Mediapipe.PacketGeneratorConfig>();
    /// <summary>
    /// Configs for PacketGenerators.  Generators take zero or more
    /// input side packets and produce any number of output side
    /// packets.  For example, MediaDecoderCalculator takes an input
    /// side packet with type DeletingFile.  However, most users want
    /// to specify videos by ContentIdHex (i.e. video id).  By using
    /// the VideoIdToLocalFileGenerator, a user can specify a video id
    /// (as a string) and obtain a DeletingFile to use with the decoder.
    /// PacketGenerators can take as a input side packet the output side
    /// packet of another PacketGenerator.  The graph of PacketGenerators
    /// must be a directed acyclic graph.
    /// DEPRECATED: Use a Node to generate side packets.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.PacketGeneratorConfig> PacketGenerator {
      get { return packetGenerator_; }
    }

    /// <summary>Field number for the "num_threads" field.</summary>
    public const int NumThreadsFieldNumber = 8;
    private int numThreads_;
    /// <summary>
    /// Number of threads for running calculators in multithreaded mode.
    /// If not specified, the scheduler will pick an appropriate number
    /// of threads depending on the number of available processors.
    /// To run on the calling thread, specify "ApplicationThreadExecutor"
    /// see: http://g3doc/mediapipe/g3doc/running.md.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumThreads {
      get { return numThreads_; }
      set {
        numThreads_ = value;
      }
    }

    /// <summary>Field number for the "status_handler" field.</summary>
    public const int StatusHandlerFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Mediapipe.StatusHandlerConfig> _repeated_statusHandler_codec
        = pb::FieldCodec.ForMessage(74, global::Mediapipe.StatusHandlerConfig.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.StatusHandlerConfig> statusHandler_ = new pbc::RepeatedField<global::Mediapipe.StatusHandlerConfig>();
    /// <summary>
    /// Configs for StatusHandlers that will be called after each call to
    /// Run() on the graph.  StatusHandlers take zero or more input side
    /// packets and the absl::Status returned by a graph run.  For example,
    /// a StatusHandler could store information about graph failures and
    /// their causes for later monitoring.  Note that graph failures during
    /// initialization may cause required input side packets (created by a
    /// PacketFactory or PacketGenerator) to be missing.  In these cases,
    /// the handler with missing input side packets will be skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.StatusHandlerConfig> StatusHandler {
      get { return statusHandler_; }
    }

    /// <summary>Field number for the "input_stream" field.</summary>
    public const int InputStreamFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_inputStream_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> inputStream_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specify input streams to the entire graph.  Streams specified here may have
    /// packets added to them using CalculatorGraph::AddPacketToInputStream.  This
    /// works much like a source calculator, except that the source is outside of
    /// the mediapipe graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> InputStream {
      get { return inputStream_; }
    }

    /// <summary>Field number for the "output_stream" field.</summary>
    public const int OutputStreamFieldNumber = 15;
    private static readonly pb::FieldCodec<string> _repeated_outputStream_codec
        = pb::FieldCodec.ForString(122);
    private readonly pbc::RepeatedField<string> outputStream_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output streams for the graph when used as a subgraph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OutputStream {
      get { return outputStream_; }
    }

    /// <summary>Field number for the "input_side_packet" field.</summary>
    public const int InputSidePacketFieldNumber = 16;
    private static readonly pb::FieldCodec<string> _repeated_inputSidePacket_codec
        = pb::FieldCodec.ForString(130);
    private readonly pbc::RepeatedField<string> inputSidePacket_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Input side packets for the graph when used as a subgraph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> InputSidePacket {
      get { return inputSidePacket_; }
    }

    /// <summary>Field number for the "output_side_packet" field.</summary>
    public const int OutputSidePacketFieldNumber = 17;
    private static readonly pb::FieldCodec<string> _repeated_outputSidePacket_codec
        = pb::FieldCodec.ForString(138);
    private readonly pbc::RepeatedField<string> outputSidePacket_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output side packets for the graph when used as a subgraph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OutputSidePacket {
      get { return outputSidePacket_; }
    }

    /// <summary>Field number for the "max_queue_size" field.</summary>
    public const int MaxQueueSizeFieldNumber = 11;
    private int maxQueueSize_;
    /// <summary>
    /// Maximum queue size of any input stream in the graph. This can be used to
    /// control the memory usage of a MediaPipe graph by preventing fast sources
    /// from flooding the graph with packets. Any source that is connected to an
    /// input stream that has hit its maximum capacity will not be scheduled until
    /// the queue size falls under the specified limits, or if the scheduler queue
    /// is empty and no other nodes are running (to prevent possible deadlocks due
    /// to a incorrectly specified value). This global parameter is set to 100
    /// packets by default to enable pipelining. If any node indicates that it
    /// buffers packets before emitting them, then the max(buffer_size_hint,
    /// max_queue_size) is used. Set this parameter to -1 to disable throttling
    /// (i.e. the graph will use as much memory as it requires). If not specified,
    /// the limit is 100 packets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxQueueSize {
      get { return maxQueueSize_; }
      set {
        maxQueueSize_ = value;
      }
    }

    /// <summary>Field number for the "report_deadlock" field.</summary>
    public const int ReportDeadlockFieldNumber = 21;
    private bool reportDeadlock_;
    /// <summary>
    /// If true, the graph run fails with an error when throttling prevents all
    /// calculators from running.  If false, max_queue_size for an input stream
    /// is adjusted when throttling prevents all calculators from running.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReportDeadlock {
      get { return reportDeadlock_; }
      set {
        reportDeadlock_ = value;
      }
    }

    /// <summary>Field number for the "runtime_info" field.</summary>
    public const int RuntimeInfoFieldNumber = 22;
    private global::Mediapipe.GraphRuntimeInfoConfig runtimeInfo_;
    /// <summary>
    /// Enable the collection of runtime information and statistics about
    /// calculators and their input streams.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.GraphRuntimeInfoConfig RuntimeInfo {
      get { return runtimeInfo_; }
      set {
        runtimeInfo_ = value;
      }
    }

    /// <summary>Field number for the "input_stream_handler" field.</summary>
    public const int InputStreamHandlerFieldNumber = 12;
    private global::Mediapipe.InputStreamHandlerConfig inputStreamHandler_;
    /// <summary>
    /// Config for this graph's InputStreamHandler.
    /// If unspecified, the framework will automatically install the default
    /// handler, which works as follows.
    /// The calculator's Process() method is called for timestamp t when:
    /// - at least one stream has a packet available at t; and,
    /// - all other streams either have packets at t, or it is known that they will
    /// not have packets at t (i.e. their next timestamp bound is greater than t).
    /// The handler then provides all available packets with timestamp t, with no
    /// preprocessing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.InputStreamHandlerConfig InputStreamHandler {
      get { return inputStreamHandler_; }
      set {
        inputStreamHandler_ = value;
      }
    }

    /// <summary>Field number for the "output_stream_handler" field.</summary>
    public const int OutputStreamHandlerFieldNumber = 13;
    private global::Mediapipe.OutputStreamHandlerConfig outputStreamHandler_;
    /// <summary>
    /// Config for this graph's OutputStreamHandler.
    /// If unspecified, the default output stream handler will be automatically
    /// installed by the framework which does not modify any outgoing packets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.OutputStreamHandlerConfig OutputStreamHandler {
      get { return outputStreamHandler_; }
      set {
        outputStreamHandler_ = value;
      }
    }

    /// <summary>Field number for the "executor" field.</summary>
    public const int ExecutorFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Mediapipe.ExecutorConfig> _repeated_executor_codec
        = pb::FieldCodec.ForMessage(114, global::Mediapipe.ExecutorConfig.Parser);
    private readonly pbc::RepeatedField<global::Mediapipe.ExecutorConfig> executor_ = new pbc::RepeatedField<global::Mediapipe.ExecutorConfig>();
    /// <summary>
    /// Configs for Executors.
    /// The names of the executors must be distinct. The default executor, whose
    /// name is the empty string, is predefined. The num_threads field of the
    /// CalculatorGraphConfig specifies the number of threads in the default
    /// executor. If the config for the default executor is specified, the
    /// CalculatorGraphConfig must not have the num_threads field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Mediapipe.ExecutorConfig> Executor {
      get { return executor_; }
    }

    /// <summary>Field number for the "profiler_config" field.</summary>
    public const int ProfilerConfigFieldNumber = 18;
    private global::Mediapipe.ProfilerConfig profilerConfig_;
    /// <summary>
    /// The default profiler-config for all calculators.  If set, this defines the
    /// profiling settings such as num_histogram_intervals for every calculator in
    /// the graph.  Each of these settings can be overridden by the
    /// |profiler_config| specified for a node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.ProfilerConfig ProfilerConfig {
      get { return profilerConfig_; }
      set {
        profilerConfig_ = value;
      }
    }

    /// <summary>Field number for the "package" field.</summary>
    public const int PackageFieldNumber = 19;
    private string package_ = "";
    /// <summary>
    /// The namespace used for class name lookup within this graph.
    /// An unqualified or partially qualified class name is looked up in
    /// this namespace first and then in enclosing namespaces.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Package {
      get { return package_; }
      set {
        package_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 20;
    private string type_ = "";
    /// <summary>
    /// The type name for the graph config, used for registering and referencing
    /// the graph config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 1001;
    private global::Mediapipe.MediaPipeOptions options_;
    /// <summary>
    /// The types and default values for graph options, in proto2 syntax.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mediapipe.MediaPipeOptions Options {
      get { return options_; }
      set {
        options_ = value;
      }
    }

    /// <summary>Field number for the "graph_options" field.</summary>
    public const int GraphOptionsFieldNumber = 1002;
    private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Any> _repeated_graphOptions_codec
        = pb::FieldCodec.ForMessage(8018, global::Google.Protobuf.WellKnownTypes.Any.Parser);
    private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> graphOptions_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The types and default values for graph options, in proto3 syntax.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> GraphOptions {
      get { return graphOptions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CalculatorGraphConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CalculatorGraphConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!node_.Equals(other.node_)) return false;
      if(!packetFactory_.Equals(other.packetFactory_)) return false;
      if(!packetGenerator_.Equals(other.packetGenerator_)) return false;
      if (NumThreads != other.NumThreads) return false;
      if(!statusHandler_.Equals(other.statusHandler_)) return false;
      if(!inputStream_.Equals(other.inputStream_)) return false;
      if(!outputStream_.Equals(other.outputStream_)) return false;
      if(!inputSidePacket_.Equals(other.inputSidePacket_)) return false;
      if(!outputSidePacket_.Equals(other.outputSidePacket_)) return false;
      if (MaxQueueSize != other.MaxQueueSize) return false;
      if (ReportDeadlock != other.ReportDeadlock) return false;
      if (!object.Equals(RuntimeInfo, other.RuntimeInfo)) return false;
      if (!object.Equals(InputStreamHandler, other.InputStreamHandler)) return false;
      if (!object.Equals(OutputStreamHandler, other.OutputStreamHandler)) return false;
      if(!executor_.Equals(other.executor_)) return false;
      if (!object.Equals(ProfilerConfig, other.ProfilerConfig)) return false;
      if (Package != other.Package) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(Options, other.Options)) return false;
      if(!graphOptions_.Equals(other.graphOptions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= node_.GetHashCode();
      hash ^= packetFactory_.GetHashCode();
      hash ^= packetGenerator_.GetHashCode();
      if (NumThreads != 0) hash ^= NumThreads.GetHashCode();
      hash ^= statusHandler_.GetHashCode();
      hash ^= inputStream_.GetHashCode();
      hash ^= outputStream_.GetHashCode();
      hash ^= inputSidePacket_.GetHashCode();
      hash ^= outputSidePacket_.GetHashCode();
      if (MaxQueueSize != 0) hash ^= MaxQueueSize.GetHashCode();
      if (ReportDeadlock != false) hash ^= ReportDeadlock.GetHashCode();
      if (runtimeInfo_ != null) hash ^= RuntimeInfo.GetHashCode();
      if (inputStreamHandler_ != null) hash ^= InputStreamHandler.GetHashCode();
      if (outputStreamHandler_ != null) hash ^= OutputStreamHandler.GetHashCode();
      hash ^= executor_.GetHashCode();
      if (profilerConfig_ != null) hash ^= ProfilerConfig.GetHashCode();
      if (Package.Length != 0) hash ^= Package.GetHashCode();
      if (Type.Length != 0) hash ^= Type.GetHashCode();
      if (options_ != null) hash ^= Options.GetHashCode();
      hash ^= graphOptions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      node_.WriteTo(output, _repeated_node_codec);
      packetFactory_.WriteTo(output, _repeated_packetFactory_codec);
      packetGenerator_.WriteTo(output, _repeated_packetGenerator_codec);
      if (NumThreads != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(NumThreads);
      }
      statusHandler_.WriteTo(output, _repeated_statusHandler_codec);
      inputStream_.WriteTo(output, _repeated_inputStream_codec);
      if (MaxQueueSize != 0) {
        output.WriteRawTag(88);
        output.WriteInt32(MaxQueueSize);
      }
      if (inputStreamHandler_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(InputStreamHandler);
      }
      if (outputStreamHandler_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(OutputStreamHandler);
      }
      executor_.WriteTo(output, _repeated_executor_codec);
      outputStream_.WriteTo(output, _repeated_outputStream_codec);
      inputSidePacket_.WriteTo(output, _repeated_inputSidePacket_codec);
      outputSidePacket_.WriteTo(output, _repeated_outputSidePacket_codec);
      if (profilerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ProfilerConfig);
      }
      if (Package.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(Package);
      }
      if (Type.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(Type);
      }
      if (ReportDeadlock != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReportDeadlock);
      }
      if (runtimeInfo_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(RuntimeInfo);
      }
      if (options_ != null) {
        output.WriteRawTag(202, 62);
        output.WriteMessage(Options);
      }
      graphOptions_.WriteTo(output, _repeated_graphOptions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      node_.WriteTo(ref output, _repeated_node_codec);
      packetFactory_.WriteTo(ref output, _repeated_packetFactory_codec);
      packetGenerator_.WriteTo(ref output, _repeated_packetGenerator_codec);
      if (NumThreads != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(NumThreads);
      }
      statusHandler_.WriteTo(ref output, _repeated_statusHandler_codec);
      inputStream_.WriteTo(ref output, _repeated_inputStream_codec);
      if (MaxQueueSize != 0) {
        output.WriteRawTag(88);
        output.WriteInt32(MaxQueueSize);
      }
      if (inputStreamHandler_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(InputStreamHandler);
      }
      if (outputStreamHandler_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(OutputStreamHandler);
      }
      executor_.WriteTo(ref output, _repeated_executor_codec);
      outputStream_.WriteTo(ref output, _repeated_outputStream_codec);
      inputSidePacket_.WriteTo(ref output, _repeated_inputSidePacket_codec);
      outputSidePacket_.WriteTo(ref output, _repeated_outputSidePacket_codec);
      if (profilerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ProfilerConfig);
      }
      if (Package.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(Package);
      }
      if (Type.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(Type);
      }
      if (ReportDeadlock != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ReportDeadlock);
      }
      if (runtimeInfo_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(RuntimeInfo);
      }
      if (options_ != null) {
        output.WriteRawTag(202, 62);
        output.WriteMessage(Options);
      }
      graphOptions_.WriteTo(ref output, _repeated_graphOptions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += node_.CalculateSize(_repeated_node_codec);
      size += packetFactory_.CalculateSize(_repeated_packetFactory_codec);
      size += packetGenerator_.CalculateSize(_repeated_packetGenerator_codec);
      if (NumThreads != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumThreads);
      }
      size += statusHandler_.CalculateSize(_repeated_statusHandler_codec);
      size += inputStream_.CalculateSize(_repeated_inputStream_codec);
      size += outputStream_.CalculateSize(_repeated_outputStream_codec);
      size += inputSidePacket_.CalculateSize(_repeated_inputSidePacket_codec);
      size += outputSidePacket_.CalculateSize(_repeated_outputSidePacket_codec);
      if (MaxQueueSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxQueueSize);
      }
      if (ReportDeadlock != false) {
        size += 2 + 1;
      }
      if (runtimeInfo_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RuntimeInfo);
      }
      if (inputStreamHandler_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputStreamHandler);
      }
      if (outputStreamHandler_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputStreamHandler);
      }
      size += executor_.CalculateSize(_repeated_executor_codec);
      if (profilerConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ProfilerConfig);
      }
      if (Package.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Package);
      }
      if (Type.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (options_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Options);
      }
      size += graphOptions_.CalculateSize(_repeated_graphOptions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CalculatorGraphConfig other) {
      if (other == null) {
        return;
      }
      node_.Add(other.node_);
      packetFactory_.Add(other.packetFactory_);
      packetGenerator_.Add(other.packetGenerator_);
      if (other.NumThreads != 0) {
        NumThreads = other.NumThreads;
      }
      statusHandler_.Add(other.statusHandler_);
      inputStream_.Add(other.inputStream_);
      outputStream_.Add(other.outputStream_);
      inputSidePacket_.Add(other.inputSidePacket_);
      outputSidePacket_.Add(other.outputSidePacket_);
      if (other.MaxQueueSize != 0) {
        MaxQueueSize = other.MaxQueueSize;
      }
      if (other.ReportDeadlock != false) {
        ReportDeadlock = other.ReportDeadlock;
      }
      if (other.runtimeInfo_ != null) {
        if (runtimeInfo_ == null) {
          RuntimeInfo = new global::Mediapipe.GraphRuntimeInfoConfig();
        }
        RuntimeInfo.MergeFrom(other.RuntimeInfo);
      }
      if (other.inputStreamHandler_ != null) {
        if (inputStreamHandler_ == null) {
          InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
        }
        InputStreamHandler.MergeFrom(other.InputStreamHandler);
      }
      if (other.outputStreamHandler_ != null) {
        if (outputStreamHandler_ == null) {
          OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
        }
        OutputStreamHandler.MergeFrom(other.OutputStreamHandler);
      }
      executor_.Add(other.executor_);
      if (other.profilerConfig_ != null) {
        if (profilerConfig_ == null) {
          ProfilerConfig = new global::Mediapipe.ProfilerConfig();
        }
        ProfilerConfig.MergeFrom(other.ProfilerConfig);
      }
      if (other.Package.Length != 0) {
        Package = other.Package;
      }
      if (other.Type.Length != 0) {
        Type = other.Type;
      }
      if (other.options_ != null) {
        if (options_ == null) {
          Options = new global::Mediapipe.MediaPipeOptions();
        }
        Options.MergeFrom(other.Options);
      }
      graphOptions_.Add(other.graphOptions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 50: {
            packetFactory_.AddEntriesFrom(input, _repeated_packetFactory_codec);
            break;
          }
          case 58: {
            packetGenerator_.AddEntriesFrom(input, _repeated_packetGenerator_codec);
            break;
          }
          case 64: {
            NumThreads = input.ReadInt32();
            break;
          }
          case 74: {
            statusHandler_.AddEntriesFrom(input, _repeated_statusHandler_codec);
            break;
          }
          case 82: {
            inputStream_.AddEntriesFrom(input, _repeated_inputStream_codec);
            break;
          }
          case 88: {
            MaxQueueSize = input.ReadInt32();
            break;
          }
          case 98: {
            if (inputStreamHandler_ == null) {
              InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
            }
            input.ReadMessage(InputStreamHandler);
            break;
          }
          case 106: {
            if (outputStreamHandler_ == null) {
              OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
            }
            input.ReadMessage(OutputStreamHandler);
            break;
          }
          case 114: {
            executor_.AddEntriesFrom(input, _repeated_executor_codec);
            break;
          }
          case 122: {
            outputStream_.AddEntriesFrom(input, _repeated_outputStream_codec);
            break;
          }
          case 130: {
            inputSidePacket_.AddEntriesFrom(input, _repeated_inputSidePacket_codec);
            break;
          }
          case 138: {
            outputSidePacket_.AddEntriesFrom(input, _repeated_outputSidePacket_codec);
            break;
          }
          case 146: {
            if (profilerConfig_ == null) {
              ProfilerConfig = new global::Mediapipe.ProfilerConfig();
            }
            input.ReadMessage(ProfilerConfig);
            break;
          }
          case 154: {
            Package = input.ReadString();
            break;
          }
          case 162: {
            Type = input.ReadString();
            break;
          }
          case 168: {
            ReportDeadlock = input.ReadBool();
            break;
          }
          case 178: {
            if (runtimeInfo_ == null) {
              RuntimeInfo = new global::Mediapipe.GraphRuntimeInfoConfig();
            }
            input.ReadMessage(RuntimeInfo);
            break;
          }
          case 8010: {
            if (options_ == null) {
              Options = new global::Mediapipe.MediaPipeOptions();
            }
            input.ReadMessage(Options);
            break;
          }
          case 8018: {
            graphOptions_.AddEntriesFrom(input, _repeated_graphOptions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            node_.AddEntriesFrom(ref input, _repeated_node_codec);
            break;
          }
          case 50: {
            packetFactory_.AddEntriesFrom(ref input, _repeated_packetFactory_codec);
            break;
          }
          case 58: {
            packetGenerator_.AddEntriesFrom(ref input, _repeated_packetGenerator_codec);
            break;
          }
          case 64: {
            NumThreads = input.ReadInt32();
            break;
          }
          case 74: {
            statusHandler_.AddEntriesFrom(ref input, _repeated_statusHandler_codec);
            break;
          }
          case 82: {
            inputStream_.AddEntriesFrom(ref input, _repeated_inputStream_codec);
            break;
          }
          case 88: {
            MaxQueueSize = input.ReadInt32();
            break;
          }
          case 98: {
            if (inputStreamHandler_ == null) {
              InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
            }
            input.ReadMessage(InputStreamHandler);
            break;
          }
          case 106: {
            if (outputStreamHandler_ == null) {
              OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
            }
            input.ReadMessage(OutputStreamHandler);
            break;
          }
          case 114: {
            executor_.AddEntriesFrom(ref input, _repeated_executor_codec);
            break;
          }
          case 122: {
            outputStream_.AddEntriesFrom(ref input, _repeated_outputStream_codec);
            break;
          }
          case 130: {
            inputSidePacket_.AddEntriesFrom(ref input, _repeated_inputSidePacket_codec);
            break;
          }
          case 138: {
            outputSidePacket_.AddEntriesFrom(ref input, _repeated_outputSidePacket_codec);
            break;
          }
          case 146: {
            if (profilerConfig_ == null) {
              ProfilerConfig = new global::Mediapipe.ProfilerConfig();
            }
            input.ReadMessage(ProfilerConfig);
            break;
          }
          case 154: {
            Package = input.ReadString();
            break;
          }
          case 162: {
            Type = input.ReadString();
            break;
          }
          case 168: {
            ReportDeadlock = input.ReadBool();
            break;
          }
          case 178: {
            if (runtimeInfo_ == null) {
              RuntimeInfo = new global::Mediapipe.GraphRuntimeInfoConfig();
            }
            input.ReadMessage(RuntimeInfo);
            break;
          }
          case 8010: {
            if (options_ == null) {
              Options = new global::Mediapipe.MediaPipeOptions();
            }
            input.ReadMessage(Options);
            break;
          }
          case 8018: {
            graphOptions_.AddEntriesFrom(ref input, _repeated_graphOptions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CalculatorGraphConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// A single node in the DAG.
      /// </summary>
      public sealed partial class Node : pb::IMessage<Node>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Node> _parser = new pb::MessageParser<Node>(() => new Node());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Node> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Mediapipe.CalculatorGraphConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Node() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Node(Node other) : this() {
          name_ = other.name_;
          calculator_ = other.calculator_;
          inputStream_ = other.inputStream_.Clone();
          outputStream_ = other.outputStream_.Clone();
          inputSidePacket_ = other.inputSidePacket_.Clone();
          outputSidePacket_ = other.outputSidePacket_.Clone();
          options_ = other.options_ != null ? other.options_.Clone() : null;
          nodeOptions_ = other.nodeOptions_.Clone();
          sourceLayer_ = other.sourceLayer_;
          bufferSizeHint_ = other.bufferSizeHint_;
          inputStreamHandler_ = other.inputStreamHandler_ != null ? other.inputStreamHandler_.Clone() : null;
          outputStreamHandler_ = other.outputStreamHandler_ != null ? other.outputStreamHandler_.Clone() : null;
          inputStreamInfo_ = other.inputStreamInfo_.Clone();
          executor_ = other.executor_;
          profilerConfig_ = other.profilerConfig_ != null ? other.profilerConfig_.Clone() : null;
          maxInFlight_ = other.maxInFlight_;
          optionValue_ = other.optionValue_.Clone();
          externalInput_ = other.externalInput_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Node Clone() {
          return new Node(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the node.  This field is optional and doesn't generally
        /// need to be specified, but does improve error messaging.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "calculator" field.</summary>
        public const int CalculatorFieldNumber = 2;
        private string calculator_ = "";
        /// <summary>
        /// The registered type of a calculator (provided via REGISTER_CALCULATOR),
        /// or of a subgraph (via REGISTER_MEDIAPIPE_GRAPH).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Calculator {
          get { return calculator_; }
          set {
            calculator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "input_stream" field.</summary>
        public const int InputStreamFieldNumber = 3;
        private static readonly pb::FieldCodec<string> _repeated_inputStream_codec
            = pb::FieldCodec.ForString(26);
        private readonly pbc::RepeatedField<string> inputStream_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// String(s) representing "TAG:name" of the stream(s) from which the current
        /// node will get its inputs. "TAG:" part is optional, see above.
        /// A calculator with no input stream is a source.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> InputStream {
          get { return inputStream_; }
        }

        /// <summary>Field number for the "output_stream" field.</summary>
        public const int OutputStreamFieldNumber = 4;
        private static readonly pb::FieldCodec<string> _repeated_outputStream_codec
            = pb::FieldCodec.ForString(34);
        private readonly pbc::RepeatedField<string> outputStream_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// String(s) representing "TAG:name" of the stream(s) produced by this node.
        /// "TAG:" part is optional, see above. These must be different from any
        /// other output_streams specified for other nodes in the graph.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> OutputStream {
          get { return outputStream_; }
        }

        /// <summary>Field number for the "input_side_packet" field.</summary>
        public const int InputSidePacketFieldNumber = 5;
        private static readonly pb::FieldCodec<string> _repeated_inputSidePacket_codec
            = pb::FieldCodec.ForString(42);
        private readonly pbc::RepeatedField<string> inputSidePacket_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// String(s) representing "TAG:name" of the input side packet(s).
        /// "TAG:" part is optional, see above.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> InputSidePacket {
          get { return inputSidePacket_; }
        }

        /// <summary>Field number for the "output_side_packet" field.</summary>
        public const int OutputSidePacketFieldNumber = 6;
        private static readonly pb::FieldCodec<string> _repeated_outputSidePacket_codec
            = pb::FieldCodec.ForString(50);
        private readonly pbc::RepeatedField<string> outputSidePacket_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// String(s) representing "TAG:name" of the output side packet(s). Only
        /// used by subgraphs.
        /// "TAG:" part is optional, see above.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> OutputSidePacket {
          get { return outputSidePacket_; }
        }

        /// <summary>Field number for the "options" field.</summary>
        public const int OptionsFieldNumber = 7;
        private global::Mediapipe.CalculatorOptions options_;
        /// <summary>
        /// The options passed to the Calculator, in proto2 syntax.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.CalculatorOptions Options {
          get { return options_; }
          set {
            options_ = value;
          }
        }

        /// <summary>Field number for the "node_options" field.</summary>
        public const int NodeOptionsFieldNumber = 8;
        private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Any> _repeated_nodeOptions_codec
            = pb::FieldCodec.ForMessage(66, global::Google.Protobuf.WellKnownTypes.Any.Parser);
        private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> nodeOptions_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any>();
        /// <summary>
        /// The options passed to the Calculator, in proto3 syntax.
        /// Each node_options message must have a different message type.
        /// If the same message type is specified in |options| and |node_options|,
        /// only the message in |options| is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Any> NodeOptions {
          get { return nodeOptions_; }
        }

        /// <summary>Field number for the "source_layer" field.</summary>
        public const int SourceLayerFieldNumber = 9;
        private int sourceLayer_;
        /// <summary>
        /// For a Source Calculator (i.e. a calculator with no inputs),
        /// this is the "layer" on which the calculator is executed.  For a
        /// non-source calculator (i.e. a calculator with one or more input
        /// streams) this field has no effect.  The sources on each layer
        /// are completely exhausted before Process() is called on any source
        /// calculator on a higher numbered layer.
        /// Example:
        ///   Decoder -> Median Frame (requires all frames) -> Image Subtraction
        ///           --------------------------------------->
        /// The entire video will be buffered on the edge from the decoder
        /// to the Image subtraction.  To fix this problem, layers can be used.
        ///   Decoder (layer 0) -> Median Frame -> Image Subtraction
        ///   Decoder (layer 1) ----------------->
        /// The frames from layer 0 will no longer be buffered, but the video
        /// will be decoded again instead.  Note, that different options can
        /// be used in the second decoder.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int SourceLayer {
          get { return sourceLayer_; }
          set {
            sourceLayer_ = value;
          }
        }

        /// <summary>Field number for the "buffer_size_hint" field.</summary>
        public const int BufferSizeHintFieldNumber = 10;
        private int bufferSizeHint_;
        /// <summary>
        /// Optional parameter that allows the user to indicate to the scheduler that
        /// this node has a buffering behavior (i.e. waits for a bunch of packets
        /// before emitting any) and specify the size of the buffer that is built up.
        /// The scheduler will then try to keep the maximum size of any input queues
        /// in the graph to remain below the maximum of all buffer_size_hints and
        /// max_queue_size (if specified). The ideal value is typically something
        /// larger than the actual number of buffered packets to maintain pipelining.
        /// The default value 0 indicates that the node has no buffering behavior.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int BufferSizeHint {
          get { return bufferSizeHint_; }
          set {
            bufferSizeHint_ = value;
          }
        }

        /// <summary>Field number for the "input_stream_handler" field.</summary>
        public const int InputStreamHandlerFieldNumber = 11;
        private global::Mediapipe.InputStreamHandlerConfig inputStreamHandler_;
        /// <summary>
        /// Config for this node's InputStreamHandler.
        /// If unspecified, the graph-level input stream handler will be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.InputStreamHandlerConfig InputStreamHandler {
          get { return inputStreamHandler_; }
          set {
            inputStreamHandler_ = value;
          }
        }

        /// <summary>Field number for the "output_stream_handler" field.</summary>
        public const int OutputStreamHandlerFieldNumber = 12;
        private global::Mediapipe.OutputStreamHandlerConfig outputStreamHandler_;
        /// <summary>
        /// Config for this node's OutputStreamHandler.
        /// If unspecified, the graph-level output stream handler will be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.OutputStreamHandlerConfig OutputStreamHandler {
          get { return outputStreamHandler_; }
          set {
            outputStreamHandler_ = value;
          }
        }

        /// <summary>Field number for the "input_stream_info" field.</summary>
        public const int InputStreamInfoFieldNumber = 13;
        private static readonly pb::FieldCodec<global::Mediapipe.InputStreamInfo> _repeated_inputStreamInfo_codec
            = pb::FieldCodec.ForMessage(106, global::Mediapipe.InputStreamInfo.Parser);
        private readonly pbc::RepeatedField<global::Mediapipe.InputStreamInfo> inputStreamInfo_ = new pbc::RepeatedField<global::Mediapipe.InputStreamInfo>();
        /// <summary>
        /// Additional information about an input stream. The |name| field of the
        /// InputStreamInfo must match an input_stream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Mediapipe.InputStreamInfo> InputStreamInfo {
          get { return inputStreamInfo_; }
        }

        /// <summary>Field number for the "executor" field.</summary>
        public const int ExecutorFieldNumber = 14;
        private string executor_ = "";
        /// <summary>
        /// Set the executor which the calculator will execute on.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Executor {
          get { return executor_; }
          set {
            executor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "profiler_config" field.</summary>
        public const int ProfilerConfigFieldNumber = 15;
        private global::Mediapipe.ProfilerConfig profilerConfig_;
        /// <summary>
        /// TODO: Remove from Node when switched to Profiler.
        /// DEPRECATED: Configs for the profiler.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Mediapipe.ProfilerConfig ProfilerConfig {
          get { return profilerConfig_; }
          set {
            profilerConfig_ = value;
          }
        }

        /// <summary>Field number for the "max_in_flight" field.</summary>
        public const int MaxInFlightFieldNumber = 16;
        private int maxInFlight_;
        /// <summary>
        /// The maximum number of invocations that can be executed in parallel.
        /// If not specified, the limit is one invocation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MaxInFlight {
          get { return maxInFlight_; }
          set {
            maxInFlight_ = value;
          }
        }

        /// <summary>Field number for the "option_value" field.</summary>
        public const int OptionValueFieldNumber = 17;
        private static readonly pb::FieldCodec<string> _repeated_optionValue_codec
            = pb::FieldCodec.ForString(138);
        private readonly pbc::RepeatedField<string> optionValue_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Defines an option value for this Node from graph options or packets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> OptionValue {
          get { return optionValue_; }
        }

        /// <summary>Field number for the "external_input" field.</summary>
        public const int ExternalInputFieldNumber = 1005;
        private static readonly pb::FieldCodec<string> _repeated_externalInput_codec
            = pb::FieldCodec.ForString(8042);
        private readonly pbc::RepeatedField<string> externalInput_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// DEPRECATED: For backwards compatibility we allow users to
        /// specify the old name for "input_side_packet" in proto configs.
        /// These are automatically converted to input_side_packets during
        /// config canonicalization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> ExternalInput {
          get { return externalInput_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Node);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Node other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Calculator != other.Calculator) return false;
          if(!inputStream_.Equals(other.inputStream_)) return false;
          if(!outputStream_.Equals(other.outputStream_)) return false;
          if(!inputSidePacket_.Equals(other.inputSidePacket_)) return false;
          if(!outputSidePacket_.Equals(other.outputSidePacket_)) return false;
          if (!object.Equals(Options, other.Options)) return false;
          if(!nodeOptions_.Equals(other.nodeOptions_)) return false;
          if (SourceLayer != other.SourceLayer) return false;
          if (BufferSizeHint != other.BufferSizeHint) return false;
          if (!object.Equals(InputStreamHandler, other.InputStreamHandler)) return false;
          if (!object.Equals(OutputStreamHandler, other.OutputStreamHandler)) return false;
          if(!inputStreamInfo_.Equals(other.inputStreamInfo_)) return false;
          if (Executor != other.Executor) return false;
          if (!object.Equals(ProfilerConfig, other.ProfilerConfig)) return false;
          if (MaxInFlight != other.MaxInFlight) return false;
          if(!optionValue_.Equals(other.optionValue_)) return false;
          if(!externalInput_.Equals(other.externalInput_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Calculator.Length != 0) hash ^= Calculator.GetHashCode();
          hash ^= inputStream_.GetHashCode();
          hash ^= outputStream_.GetHashCode();
          hash ^= inputSidePacket_.GetHashCode();
          hash ^= outputSidePacket_.GetHashCode();
          if (options_ != null) hash ^= Options.GetHashCode();
          hash ^= nodeOptions_.GetHashCode();
          if (SourceLayer != 0) hash ^= SourceLayer.GetHashCode();
          if (BufferSizeHint != 0) hash ^= BufferSizeHint.GetHashCode();
          if (inputStreamHandler_ != null) hash ^= InputStreamHandler.GetHashCode();
          if (outputStreamHandler_ != null) hash ^= OutputStreamHandler.GetHashCode();
          hash ^= inputStreamInfo_.GetHashCode();
          if (Executor.Length != 0) hash ^= Executor.GetHashCode();
          if (profilerConfig_ != null) hash ^= ProfilerConfig.GetHashCode();
          if (MaxInFlight != 0) hash ^= MaxInFlight.GetHashCode();
          hash ^= optionValue_.GetHashCode();
          hash ^= externalInput_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Calculator.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Calculator);
          }
          inputStream_.WriteTo(output, _repeated_inputStream_codec);
          outputStream_.WriteTo(output, _repeated_outputStream_codec);
          inputSidePacket_.WriteTo(output, _repeated_inputSidePacket_codec);
          outputSidePacket_.WriteTo(output, _repeated_outputSidePacket_codec);
          if (options_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(Options);
          }
          nodeOptions_.WriteTo(output, _repeated_nodeOptions_codec);
          if (SourceLayer != 0) {
            output.WriteRawTag(72);
            output.WriteInt32(SourceLayer);
          }
          if (BufferSizeHint != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(BufferSizeHint);
          }
          if (inputStreamHandler_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(InputStreamHandler);
          }
          if (outputStreamHandler_ != null) {
            output.WriteRawTag(98);
            output.WriteMessage(OutputStreamHandler);
          }
          inputStreamInfo_.WriteTo(output, _repeated_inputStreamInfo_codec);
          if (Executor.Length != 0) {
            output.WriteRawTag(114);
            output.WriteString(Executor);
          }
          if (profilerConfig_ != null) {
            output.WriteRawTag(122);
            output.WriteMessage(ProfilerConfig);
          }
          if (MaxInFlight != 0) {
            output.WriteRawTag(128, 1);
            output.WriteInt32(MaxInFlight);
          }
          optionValue_.WriteTo(output, _repeated_optionValue_codec);
          externalInput_.WriteTo(output, _repeated_externalInput_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Calculator.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Calculator);
          }
          inputStream_.WriteTo(ref output, _repeated_inputStream_codec);
          outputStream_.WriteTo(ref output, _repeated_outputStream_codec);
          inputSidePacket_.WriteTo(ref output, _repeated_inputSidePacket_codec);
          outputSidePacket_.WriteTo(ref output, _repeated_outputSidePacket_codec);
          if (options_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(Options);
          }
          nodeOptions_.WriteTo(ref output, _repeated_nodeOptions_codec);
          if (SourceLayer != 0) {
            output.WriteRawTag(72);
            output.WriteInt32(SourceLayer);
          }
          if (BufferSizeHint != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(BufferSizeHint);
          }
          if (inputStreamHandler_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(InputStreamHandler);
          }
          if (outputStreamHandler_ != null) {
            output.WriteRawTag(98);
            output.WriteMessage(OutputStreamHandler);
          }
          inputStreamInfo_.WriteTo(ref output, _repeated_inputStreamInfo_codec);
          if (Executor.Length != 0) {
            output.WriteRawTag(114);
            output.WriteString(Executor);
          }
          if (profilerConfig_ != null) {
            output.WriteRawTag(122);
            output.WriteMessage(ProfilerConfig);
          }
          if (MaxInFlight != 0) {
            output.WriteRawTag(128, 1);
            output.WriteInt32(MaxInFlight);
          }
          optionValue_.WriteTo(ref output, _repeated_optionValue_codec);
          externalInput_.WriteTo(ref output, _repeated_externalInput_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Calculator.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Calculator);
          }
          size += inputStream_.CalculateSize(_repeated_inputStream_codec);
          size += outputStream_.CalculateSize(_repeated_outputStream_codec);
          size += inputSidePacket_.CalculateSize(_repeated_inputSidePacket_codec);
          size += outputSidePacket_.CalculateSize(_repeated_outputSidePacket_codec);
          if (options_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
          }
          size += nodeOptions_.CalculateSize(_repeated_nodeOptions_codec);
          if (SourceLayer != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(SourceLayer);
          }
          if (BufferSizeHint != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(BufferSizeHint);
          }
          if (inputStreamHandler_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputStreamHandler);
          }
          if (outputStreamHandler_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputStreamHandler);
          }
          size += inputStreamInfo_.CalculateSize(_repeated_inputStreamInfo_codec);
          if (Executor.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Executor);
          }
          if (profilerConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProfilerConfig);
          }
          if (MaxInFlight != 0) {
            size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxInFlight);
          }
          size += optionValue_.CalculateSize(_repeated_optionValue_codec);
          size += externalInput_.CalculateSize(_repeated_externalInput_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Node other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Calculator.Length != 0) {
            Calculator = other.Calculator;
          }
          inputStream_.Add(other.inputStream_);
          outputStream_.Add(other.outputStream_);
          inputSidePacket_.Add(other.inputSidePacket_);
          outputSidePacket_.Add(other.outputSidePacket_);
          if (other.options_ != null) {
            if (options_ == null) {
              Options = new global::Mediapipe.CalculatorOptions();
            }
            Options.MergeFrom(other.Options);
          }
          nodeOptions_.Add(other.nodeOptions_);
          if (other.SourceLayer != 0) {
            SourceLayer = other.SourceLayer;
          }
          if (other.BufferSizeHint != 0) {
            BufferSizeHint = other.BufferSizeHint;
          }
          if (other.inputStreamHandler_ != null) {
            if (inputStreamHandler_ == null) {
              InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
            }
            InputStreamHandler.MergeFrom(other.InputStreamHandler);
          }
          if (other.outputStreamHandler_ != null) {
            if (outputStreamHandler_ == null) {
              OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
            }
            OutputStreamHandler.MergeFrom(other.OutputStreamHandler);
          }
          inputStreamInfo_.Add(other.inputStreamInfo_);
          if (other.Executor.Length != 0) {
            Executor = other.Executor;
          }
          if (other.profilerConfig_ != null) {
            if (profilerConfig_ == null) {
              ProfilerConfig = new global::Mediapipe.ProfilerConfig();
            }
            ProfilerConfig.MergeFrom(other.ProfilerConfig);
          }
          if (other.MaxInFlight != 0) {
            MaxInFlight = other.MaxInFlight;
          }
          optionValue_.Add(other.optionValue_);
          externalInput_.Add(other.externalInput_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Calculator = input.ReadString();
                break;
              }
              case 26: {
                inputStream_.AddEntriesFrom(input, _repeated_inputStream_codec);
                break;
              }
              case 34: {
                outputStream_.AddEntriesFrom(input, _repeated_outputStream_codec);
                break;
              }
              case 42: {
                inputSidePacket_.AddEntriesFrom(input, _repeated_inputSidePacket_codec);
                break;
              }
              case 50: {
                outputSidePacket_.AddEntriesFrom(input, _repeated_outputSidePacket_codec);
                break;
              }
              case 58: {
                if (options_ == null) {
                  Options = new global::Mediapipe.CalculatorOptions();
                }
                input.ReadMessage(Options);
                break;
              }
              case 66: {
                nodeOptions_.AddEntriesFrom(input, _repeated_nodeOptions_codec);
                break;
              }
              case 72: {
                SourceLayer = input.ReadInt32();
                break;
              }
              case 80: {
                BufferSizeHint = input.ReadInt32();
                break;
              }
              case 90: {
                if (inputStreamHandler_ == null) {
                  InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
                }
                input.ReadMessage(InputStreamHandler);
                break;
              }
              case 98: {
                if (outputStreamHandler_ == null) {
                  OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
                }
                input.ReadMessage(OutputStreamHandler);
                break;
              }
              case 106: {
                inputStreamInfo_.AddEntriesFrom(input, _repeated_inputStreamInfo_codec);
                break;
              }
              case 114: {
                Executor = input.ReadString();
                break;
              }
              case 122: {
                if (profilerConfig_ == null) {
                  ProfilerConfig = new global::Mediapipe.ProfilerConfig();
                }
                input.ReadMessage(ProfilerConfig);
                break;
              }
              case 128: {
                MaxInFlight = input.ReadInt32();
                break;
              }
              case 138: {
                optionValue_.AddEntriesFrom(input, _repeated_optionValue_codec);
                break;
              }
              case 8042: {
                externalInput_.AddEntriesFrom(input, _repeated_externalInput_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Calculator = input.ReadString();
                break;
              }
              case 26: {
                inputStream_.AddEntriesFrom(ref input, _repeated_inputStream_codec);
                break;
              }
              case 34: {
                outputStream_.AddEntriesFrom(ref input, _repeated_outputStream_codec);
                break;
              }
              case 42: {
                inputSidePacket_.AddEntriesFrom(ref input, _repeated_inputSidePacket_codec);
                break;
              }
              case 50: {
                outputSidePacket_.AddEntriesFrom(ref input, _repeated_outputSidePacket_codec);
                break;
              }
              case 58: {
                if (options_ == null) {
                  Options = new global::Mediapipe.CalculatorOptions();
                }
                input.ReadMessage(Options);
                break;
              }
              case 66: {
                nodeOptions_.AddEntriesFrom(ref input, _repeated_nodeOptions_codec);
                break;
              }
              case 72: {
                SourceLayer = input.ReadInt32();
                break;
              }
              case 80: {
                BufferSizeHint = input.ReadInt32();
                break;
              }
              case 90: {
                if (inputStreamHandler_ == null) {
                  InputStreamHandler = new global::Mediapipe.InputStreamHandlerConfig();
                }
                input.ReadMessage(InputStreamHandler);
                break;
              }
              case 98: {
                if (outputStreamHandler_ == null) {
                  OutputStreamHandler = new global::Mediapipe.OutputStreamHandlerConfig();
                }
                input.ReadMessage(OutputStreamHandler);
                break;
              }
              case 106: {
                inputStreamInfo_.AddEntriesFrom(ref input, _repeated_inputStreamInfo_codec);
                break;
              }
              case 114: {
                Executor = input.ReadString();
                break;
              }
              case 122: {
                if (profilerConfig_ == null) {
                  ProfilerConfig = new global::Mediapipe.ProfilerConfig();
                }
                input.ReadMessage(ProfilerConfig);
                break;
              }
              case 128: {
                MaxInFlight = input.ReadInt32();
                break;
              }
              case 138: {
                optionValue_.AddEntriesFrom(ref input, _repeated_optionValue_codec);
                break;
              }
              case 8042: {
                externalInput_.AddEntriesFrom(ref input, _repeated_externalInput_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
